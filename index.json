[{"content":"\r\n\r\n基于贝叶斯定理的朴素贝叶斯算法是利用训练数据并根据特征的取值来计算每个类别被观察到的概率。这里的“朴素”并不意味着算法有限或者效率低下，而是该算法依赖于一个基本假设，即预测变量具有独立性，也就是说假定类中特定特征的存在与任何其他特征的存在无关。虽然有时该条件看起来很难成立，但是在特定情况下，不同情况之间的依赖关系可能会相互清除，即使朴素贝叶斯分类器的朴素性假设不成立，但是依然能够表现出相当好的性能。\r\n\r\n## 一、贝叶斯定理\r\n\r\n考虑两个概率事件A和B，使用乘积法则可以将边缘概率P(A)和P(B)与条件概率P(A|B)和P(B|A)相关联：\r\n\r\n![](/images/article/bayes1.png)\r\n\r\n考虑到交集可以互换，等式的左边是相等的，那么就可以得到贝叶斯定理，如下：\r\n\r\n![](/images/article/bayes2.png)\r\n\r\n还需要再了解一下似然函数，可以简单的理解为是一种关于统计模型参数的函数。在给定输出x时，关于参数θ的似然函数L(θ|x)(在数值上)等于给定参数θ后变量X的概率：L(θ|x)=P(X=x|θ)\r\n\r\n\r\n对贝叶斯定义各部分的解释如下：\r\n\r\n+ 后验概率：即P(A|B)，是在事件B发生的条件下事件A发生的可能性的大小；\r\n+ 先验概率：即P(A)，是根据以往经验和分析得到的某事件的概率；\r\n+ 似然概率：即P(B|A)，似然是关于参数的函数L(θ|x)，即在参数θ给定的条件下，对于观察到的x的值的条件分布，即概率P(X=x|θ)，也就是L(θ|x)=P(X=x|θ)；\r\n+ 边际似然概率(或者归一化因子)：即P(B)，作为上述似然概率的推广，那么边际似然概率也就是在二维随机变量θ与X的分布中，随机变量X的边际概率P(X=x)。\r\n\r\n由于归一化因子常用希腊字母α来表示，那么公式就变为\r\n\r\n![](/images/article/bayes7.png)\r\n\r\n这是在二维特征空间内的贝叶斯定理，推广到多维特征空间，那么贝叶斯定理如下表示\r\n\r\n![](/images/article/bayes8.png)\r\n\r\n在朴素贝叶斯算法中，我们就是通过计算先验概率、似然概率与边际似然概率来估计后验概率发生的可能性，从而实现预测分类。\r\n\r\n## 二、朴素贝叶斯算法\r\n\r\n### 2.1 朴素贝叶斯算法的形象解释\r\n\r\n考虑有如下训练集，其中二维特征空间中绿点有40个，红点为20个，总数为60\r\n\r\n![](/images/article/bayes3.gif)\r\n\r\n我们有先验概率公式\r\n\r\n![](/images/article/bayes4.gif)\r\n\r\n那么我们就可以根据训练集数据得到如下先验概率(根据以往经验分析得到，即根据训练集数据得到单变量的概率分布)\r\n\r\n![](/images/article/bayes5.gif)\r\n\r\n如果此时加入一个新的案例(如下图所示)，我们假定，该案例的类别取决于其附近的案例的类别情况，那么我们不妨以该案例为圆心，画一个包含了一定数量的绿点和红点的圆出来，如下\r\n\r\n![](/images/article/bayes6.gif)\r\n\r\n然后我们计算属于每个类标签的圆中的点的个数。由此我们计算出可能性：\r\n\r\n![](/images/article/bayes7.gif)\r\n\r\n带入数值，从而\r\n\r\n![](/images/article/bayes8.gif)\r\n\r\n![](/images/article/bayes9.gif)\r\n\r\n到了这里，只需要通过贝叶斯定理将先验概率与似然概率综合起来就好了，如下\r\n\r\n![](/images/article/bayes10.gif)\r\n\r\n那么白色案例最终的预测类就是红点。\r\n\r\n即朴素贝叶斯算法则是综合似然概率与先验概率来产生最终的后验概率，即最终的分类预测概率。上述概率并未进行归一化(标准化)操作。但是，这不会影响分类结果，因为它们的归一化常数是相同的。\r\n\r\n## 2.2 朴素贝叶斯算法的数学定义\r\n\r\n考虑一个数据集：\r\n\r\n![](/images/article/bayes11.png)\r\n\r\n以上，为了简单起见，每个向量被表示为：\r\n\r\n![](/images/article/bayes12.png)\r\n\r\n再定义如下目标数据集，分别对应上述数据集案例的类别：\r\n\r\n![](/images/article/bayes13.png)\r\n\r\n那么根据条件独立下的贝叶斯定理，就有：\r\n\r\n![](/images/article/bayes14.png)\r\n\r\n即通过频率计数获得边际先验概率P(y)和条件概率P(xi|y)的值，那么给定输入向量x，预测得到的类就是后验概率最大的类。\r\n\r\n### 2.3 朴素贝叶斯算法的适用范围\r\n\r\n+ 实时预测：朴素贝叶斯训练起来很快。因此，它可以用于实时预测；\r\n+ 多类预测：该算法对于多类预测的性能也是不错的。在这里，我们可以预测多类目标变量的概率；\r\n+ 文本分类/垃圾邮件过滤/情感分析：与其他算法相比，主要用于文本分类的朴素贝叶斯分类器具有更高的成功率。因此，它被广泛用于垃圾邮件过滤（识别垃圾邮件）和情感分析（在社交媒体分析中，以识别积极和消极的客户情绪）；\r\n+ 推荐系统：朴素贝叶斯分类器和协同过滤一起构建一个推荐系统，该系统使用机器学习和数据挖掘技术来过滤看不见的信息并预测用户是否想要给定的资源。\r\n\r\n## 三、R语言中朴素贝叶斯函数及应用\r\n\r\n### 3.1 R语言中朴素贝叶斯函数\r\n\r\n使用e1071添加包中的函数`naiveBayes()`来实现朴素贝叶斯算法，原型如下\r\n\r\n先创建分类器\r\n\r\n```\r\nm \u003c- naiveBayes(train, class, laplace = 0)\r\n```\r\n\r\n+ train：训练集数据框；\r\n+ class：训练集数据框案例对应的类别，是一个因子型向量；\r\n+ laplace：控制拉普拉斯估计得一个数值，默认为0.\r\n\r\n该函数返回一个朴素贝叶斯对象，能够用于预测。\r\n\r\n进行预测\r\n\r\n```\r\np \u003c- predict(m, test, type = \"class\")\r\n```\r\n\r\n+ m：`naiveBayes()`函数得到的模型；\r\n+ test：测试集数据框；\r\n+ type：值为`class`或者`raw\t`，分别对应预测的类与概率。\r\n\r\n该函数返回一个向量，根据type参数的值决定该向量是预测类还是预测类概率。\r\n\r\n### 3.2 R语言中朴素贝叶斯函数应用\r\n\r\n我们使用 [分而治之——决策树学习算法](http://localhost:8000/decision-tree-learning.html) 一文中根据银行贷款数据来建立模型来预测贷款是否违约为例来说明朴素贝叶斯算法，只将C5.0决策树算法调整为朴素贝叶斯，其余代码不变，如下\r\n\r\n```\r\n\u003e credit_train_class \u003c- credit_train$default\r\n\u003e credit_test_class \u003c- credit_test$default\r\n\u003e credit_train \u003c- credit_train[-17]\r\n\u003e credit_test \u003c- credit_test[-17]\r\n\u003e library(e1071)\r\n\u003e m \u003c- naiveBayes(credit_train, credit_train_class)\r\n\u003e p \u003c- predict(m, credit_test)\r\n\u003e prop.table(table(credit_test_class == p))\r\n\r\nFALSE  TRUE \r\n 0.19  0.81 \r\n```\r\n\r\n评估模型效果发现，性能还是可以的。\r\n\r\n### 3.3 调整模型性能\r\n\r\n可以通过调整`naiveBayes()`函数中`laplace`参数的值来调整模型性能。设置`laplace`的值为1试试，如下\r\n```\r\n\u003e m \u003c- naiveBayes(credit_train, credit_train_class, laplace = 1)\r\n\u003e p \u003c- predict(m, credit_test)\r\n\u003e prop.table(table(credit_test_class == p))\r\n\r\nFALSE  TRUE \r\n  0.2   0.8 \r\n```\r\n\r\n模型性能稍微降低，可见之前的拟合效果还是不错的。\r\n\r\n\r\n###### 参考文献\r\n\r\n1. http://www.statsoft.com/Textbook/Naive-Bayes-Classifier\r\n2. Machine Learning Algorithms / Giuseppe Bonaccorso.\r\n3. https://www.analyticsvidhya.com/blog/2017/09/naive-bayes-explained/\r\n\r\n全文完！","cover":"/images/naive-bayes.png","link":"naive-bayes.html","preview":"\u003cp\u003e朴素贝叶斯算法是一种依据贝叶斯定理的分类技术，利用概率原则进行分类，该算法易于构建模型，适用于大规模数据集的分类任务。\u003c/p\u003e\n","title":"概率学习——朴素贝叶斯算法"},{"content":"\r\n\r\n## 一、常量与变量\r\n\r\nErlang中所有的变量名必须以大写字母开头，且变量属于**一次性赋值变量**，即只能被赋值一次，如果试图在变量被设置后再改变它的值就会得到一个错误。\r\n\r\n在Erlang里，变量不过是对某个值的引用，Erlang的实现方式是用指针指向一个包含值得内存区，这个值不能被修改。这样做的好处就是不存在共享内存，也就不存在锁，所以让并发实现的更简单。\r\n\r\n```\r\nC:\\Users\\Administrator\u003eerl\r\nEshell V10.0.1  (abort with ^G)\r\n1\u003e X = 1.\r\n1\r\n2\u003e X.\r\n1\r\n3\u003e X = 2.\r\n** exception error: no match of right hand side value 2\r\n```\r\n\r\n而Erlang中的常量(或者叫原子)是直接以小写字母开头的，可以直接使用，无需定义\r\n\r\n```\r\n4\u003e const.\r\nconst\r\n```\r\n\r\n## 二、常用数据类型(结构)\r\n\r\n### 2.1 整数和浮点数\r\n\r\n作为直接量直接使用，整数相除即使能够除尽得到的结果仍然是浮点数，想获取除数可以使用`div`操作符，想获取余数可以使用`rem`操作符。\r\n\r\n```\r\n5\u003e 5 / 3.\r\n1.6666666666666667\r\n6\u003e 5 div 3.\r\n1\r\n7\u003e 5 rem 3.\r\n2\r\n8\u003e 4 / 2.\r\n2.0\r\n```\r\n\r\nErlang在内部使用64位的IEEE 754-1985浮点数，因此浮点数的程序会存在和C等语言一样的浮点数取整和精度问题。\r\n\r\n### 2.2 原子\r\n\r\n原子类似于C语言中的宏，被用于表示常量值，以小写字母开头，后面可以跟字母、数字、下划线或at符号\r\n\r\n```\r\n9\u003e helloworld.\r\nhelloworld\r\n```\r\n\r\n### 2.3 元组\r\n\r\n元组是由一些**数量固定**的项目归组形成的单一的实体，创建元组的方法就是用大括号将想要表示的值括起来，并用逗号分隔每一部分。类似于C语言中的结构体，C语言中的结构体如下定义\r\n\r\n```\r\nstruct point {\r\n    int x;\r\n    int y;\r\n} P;\r\n```\r\n\r\n而对应的元组如下定义\r\n\r\n```\r\n10\u003e P = {1, 2}.\r\n{1,2}\r\n11\u003e P.\r\n{1,2}\r\n```\r\n\r\n为了指明元组的含义，一般情况下将第一个元素定义为原子类型，如下\r\n\r\n```\r\n12\u003e Q = {point, 1, 2}.\r\n{point,1,2}\r\n13\u003e Q.\r\n{point,1,2}\r\n```\r\n\r\n元组还可以嵌套，例如将如下JSON串利用嵌套的元组表示\r\n\r\n```\r\n{\r\n  \"name\" : \"joe\",\r\n  \"height\" : 1.82,\r\n  \"footsize\" : 42,\r\n  \"eyecolour\" : \"brown\"\r\n}\r\n```\r\n\r\n```\r\n14\u003e Person = {person, {name, joe}, {height, 1.82}, {footsize, 42}, {eyecolour, b\r\nrown}}.\r\n{person,{name,joe},\r\n        {height,1.82},\r\n        {footsize,42},\r\n        {eyecolour,brown}}\r\n15\u003e Person.\r\n{person,{name,joe},\r\n        {height,1.82},\r\n        {footsize,42},\r\n        {eyecolour,brown}}\r\n```\r\n\r\n其实可以看出，把元组大括号的第一个元素定义为常量，就相当于键值对中键的作用，但是并不是可以通过键提取值，而是代表了值的含义是什么。\r\n\r\n但是如何提取元组的值呢？答案是通过模式匹配操作符`=`来实现数据绑定，如下\r\n\r\n```\r\n16\u003e Point = {point, 10, 45}.\r\n{point,10,45}\r\n20\u003e {point, First, Second} = Point.\r\n{point,10,45}\r\n21\u003e First.\r\n10\r\n22\u003e Second.\r\n45\r\n```\r\n\r\n如果不匹配，比如说参数个数不一致，常量绑定值或者其他情况，那么就会提示错误，如下\r\n\r\n```\r\n17\u003e {point, X, Y} = Point.\r\n** exception error: no match of right hand side value {point,10,45}\r\n18\u003e {Point, First, second} = Point.\r\n** exception error: no match of right hand side value {point,10,45}\r\n19\u003e {Point, First, Second} = Point.\r\n** exception error: no match of right hand side value {point,10,45}\r\n20\u003e {point, First, Second} = Point.\r\n```\r\n\r\n再试试提取复杂元组的值，需要注意的是，如果我们对元组当中某个值不感兴趣，那么可以通过占位符`_`将其忽略，这样也省得定义没必要的变量名，如下提取前面定义的Person的元组值\r\n\r\n```\r\n24\u003e {_, {_, Name}, {_, Height}, {_, Footsize}, {_, Eyecolour}} = Person.\r\n{person,{name,joe},\r\n        {height,1.82},\r\n        {footsize,42},\r\n        {eyecolour,brown}}\r\n25\u003e Name.\r\njoe\r\n26\u003e Height.\r\n1.82\r\n28\u003e Footsize.\r\n42\r\n29\u003e Eyecolour.\r\nbrown\r\n```\r\n\r\n怎么样修改值呢？不会的，因为Erlang的变量是不允许修改的！\r\n\r\n### 2.4 列表\r\n\r\n列表是用来存放任意数量的事物的，创建列表的方法就是用中括号将列表元素括起来，并用逗号分隔它们，如下\r\n\r\n```\r\n30\u003e Drawing = [{square, {10, 10}, 10}, {triangle, {15, 10}, {25, 10}, {30, 40}}]\r\n.\r\n[{square,{10,10},10},{triangle,{15,10},{25,10},{30,40}}]\r\n31\u003e Drawing.\r\n[{square,{10,10},10},{triangle,{15,10},{25,10},{30,40}}]\r\n```\r\n\r\n列表可以分为表头和表尾，表头是第一个元素，除过表头的元素全部都是表尾，在多元素的情况下，表尾很有可能是一个列表。由于rlang不支持修改变量，那么拓展列表的办法就是将其赋值给新的变量并定义拓展的元素，如下\r\n\r\n```\r\n32\u003e ThingToBuy = [{apples, 10}, {pears, 6}, {milk, 3}].\r\n[{apples,10},{pears,6},{milk,3}]\r\n33\u003e ThingToBuy1 = [{oranges, 4}, {newspaper, 1} | ThingToBuy].\r\n[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]\r\n```\r\n\r\n列表元素的提取仍然是通过模式匹配操作符`=`来实现数据绑定，不过对于列表，我们可以通过表头表尾的配合来提取元素，如下\r\n\r\n```\r\n34\u003e [Buy1 | ThingToBuy2] = ThingToBuy1.\r\n[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]\r\n35\u003e Buy1.\r\n{oranges,4}\r\n36\u003e ThingToBuy2.\r\n[{newspaper,1},{apples,10},{pears,6},{milk,3}]\r\n```\r\n\r\n上述代码是将表头与表尾分别提取，可以以一次性提取若干的表头，以提取两个表头为例\r\n\r\n```\r\n37\u003e [Buy2, Buy3 | ThingToBuy3] = ThingToBuy1.\r\n[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]\r\n38\u003e Buy2.\r\n{oranges,4}\r\n39\u003e Buy3.\r\n{newspaper,1}\r\n40\u003e ThingToBuy3.\r\n[{apples,10},{pears,6},{milk,3}]\r\n```\r\n\r\n占位符`_`忽略元素同样有用，我们以下忽略列表的前四个元素，只提取最后一个元素\r\n\r\n```\r\n42\u003e [_, _, _, _ | Buy4] = ThingToBuy1.\r\n[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]\r\n43\u003e Buy4.\r\n[{milk,3}]\r\n```\r\n\r\n### 2.5 字符串\r\n\r\n严格来说，Erlang中并没有字符串，想要在Erlang中表示字符串，可以选择由一个整数组成的列表或者一个二进制型。当字符串表示为一个整数列表时，列表中的每个元素都代表了一个Unicode代码点。\r\n\r\n创建字符串最简单的方式就是使用字符串字面量，如下\r\n\r\n```\r\n44\u003e Names = \"Hello, World\".\r\n\"Hello, World\"\r\n```\r\n\r\n其实上述并不是真的字符串，而只是一个列表的简写，这个列表中包含了每个字符的整数字符代码，不信试试看\r\n\r\n可以通过操作符`$`获取某个字符的整数字符代码，如下\r\n\r\n```\r\n45\u003e H = $H.\r\n72\r\n46\u003e E = $e.\r\n101\r\n47\u003e L = $l.\r\n108\r\n48\u003e O = $o.\r\n111\r\n49\u003e Sign = $,.\r\n44\r\n50\u003e Space = $ .\r\n32\r\n51\u003e W = $W.\r\n87\r\n52\u003e R = $r.\r\n114\r\n53\u003e D = $d.\r\n100\r\n54\u003e HelloWorld = [H, E, L, L, O, Sign, Space, W, O, R, L, D].\r\n\"Hello, World\"\r\n```\r\n可见，效果一模一样。","cover":"/images/E-LearningLogo.png","link":"intro-erlang-1.html","preview":"\u003cp\u003e常量与变量、常用数据类型。\u003c/p\u003e\n","title":"Erlang程序设计(一)"},{"content":"\r\n\r\nkNN(k Nearest Neighbor)是一种非参数和惰性学习算法。非参数意味着没有基础数据分布的假设。换句话说，模型结构由数据集特别是训练集确定。在大多数现实世界数据集不遵循数学理论假设的实践中，这是非常有用的。懒惰算法意味着它不需要任何训练数据点就可以生成模型。在分类器的训练阶段会使用所有的训练集数据。但也就意味着扫描数据点时间的增长和内存占用的提高。\r\n\r\n## 一、kNN学习算法的原理\r\n\r\n该算法是基于案例之间的相似度进行分类的，训练集负责训练一个分类器，而测试集直接将案例带入就可以通过k个最相近的训练集案例进行投票以确定最终分类结果。\r\n\r\n首先从字面意思来解释，kNN又名K最近邻，有两层含义，分别是\r\n\r\n+ k：测试集数据的预测类需要由与它最近的K个邻居投票表决而定，哪类邻居的票数多，该案例就属于哪一类；\r\n+ 最近邻：与测试集数据点距离最近的训练集数据，是为该案例的最近邻。\r\n\r\n那么综上所述，k最近邻的本质就是**计算特征空间中测试集案例关于该特征空间中训练集数据点(类)的距离最近的k个训练集数据点(邻居)的距离，测试集案例的预测类通过这k个训练集数据的投票而定，哪一类票数多，测试集案例就属于哪一类**。\r\n\r\n### 1.1 距离的衡量\r\n\r\n同K均值聚类一样，该算法仍然是基于距离的(也可以说是案例之间的相似度，相似度通过距离来衡量)，距离的计算常用的仍然是欧式距离。公式如下\r\n\r\n![](/images/article/k-means1.png)\r\n\r\n其中，x和y分别为需要计算的两个案例，xi和yi分别为两个案例相对应的第i个特征的值。这样就足够度量测试集案例同周边k个相邻训练集案例的距离了，也就能找到最近邻。\r\n\r\n### 1.2 k的选择\r\n\r\n事实上，没有最优的k值适合所有类型的数据集。每个数据集都有自己的要求。如果k值较小，噪声将对结果具有更高的影响而且决策边界不是很平滑。如果k值较大，那么可以较少噪声数据对模型的影响或者减少噪声导致的模型波动，从而使得决策边界更为光滑，但是也意味着昂贵的计算成本。\r\n\r\n我们考虑两种极端的情况，如果k值为1，即测试集案例的预测类只取决于与它最相近的一个训练集数据点的类型，那么单一的近邻会使得噪声数据或者异常值过度影响案例的分类结果，一言堂是不可取的。如果k值非常大，甚至于等于训练集案例中所有观测值的数量，那么过度拟合的风险就极高，颇有一种仗势欺人的感觉。\r\n\r\n![](/images/article/knn1.png)\r\n\r\n因此，合理的k值应该介于这两种极端之间，并考虑训练数据中案例的数量，一种较为常见的做法是设置k值等于训练集中案例数量的平方根，但是对于训练集数据体量庞大的情况下仍然是不可取的。一般情况下k通常取3 — 10之间的某个数，\r\n\r\n![](/images/article/knn2.png)\r\n\r\n### 1.3 特征值标准化\r\n\r\n在应用kNN算法之前，必不可少的操作是将特征值转化到一个合理的区间内。这种操作的合理性在于，如果某个特征具有比其他特征更大的值，那么距离的度量就会强烈地被这个庞大的值所支配，所以必须避免这种情况。\r\n\r\n较为常用的数据标准化方法包括如下两种：\r\n\r\n+ min-max 标准化：就是特征X的每一个值减去该特征的最小值再除以特征X的值域，该方法会将特征值映射到0 — 1范围内，公式如下\r\n\r\n![](/images/article/knn3.png)\r\n\r\n+ z-score 标准化：特征X的每一个值减去特征X的均值，然后再除以特征X的标准差。经过处理的数据符合标准正态分布，即均值为0，标准差为1，公式为\r\n\r\n![](/images/article/knn4.png)\r\n\r\n## 二、R语言中kNN函数及应用\r\n\r\n### 2.1 R语言中kNN函数\r\n\r\n通过使用class添加包中的`knn()`函数来应用KNN算法，原型如下\r\n\r\n创建分类器并进行预测\r\n\r\n```\r\np \u003c- knn(train, test, cl, k)\r\n```\r\n\r\n+ train：一个包含数值型数据的训练集数据框；\r\n+ test：一个包含数值型数的测试集数据框；\r\n+ cl：包含训练集数据每一行分类的一个因子向量；\r\n+ k：标识最近邻数目的一个整数。\r\n\r\n该函数返回一个因子向量，该向量包含测试集数据框中每一行的预测分类。\r\n\r\n### 2.2 R语言中KNN函数应用\r\n\r\n以《Machine Learning With R》一书中的乳腺癌的识别为例，来说明kNN算法对数值型数据的预测分类能力，先读取数据并查看结构\r\n\r\n```\r\n\u003e getwd()\r\n[1] \"C:/Users/Administrator/Documents\"\r\n\u003e setwd(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\docs\\\\Machine-Learning-with-R-datasets-master\")\r\n\u003e wb \u003c- read.csv(\"wisc_bc_data.csv\", stringsAsFactors = FALSE)\r\n\u003e str(wb)\r\n'data.frame':\t569 obs. of  32 variables:\r\n $ id                     : int  842302 842517 84300903 84348301 84358402 843786 844359 84458202 844981 84501001 ...\r\n $ diagnosis              : chr  \"M\" \"M\" \"M\" \"M\" ...\r\n $ radius_mean            : num  18 20.6 19.7 11.4 20.3 ...\r\n $ texture_mean           : num  10.4 17.8 21.2 20.4 14.3 ...\r\n $ perimeter_mean         : num  122.8 132.9 130 77.6 135.1 ...\r\n $ area_mean              : num  1001 1326 1203 386 1297 ...\r\n $ smoothness_mean        : num  0.1184 0.0847 0.1096 0.1425 0.1003 ...\r\n $ compactness_mean       : num  0.2776 0.0786 0.1599 0.2839 0.1328 ...\r\n $ concavity_mean         : num  0.3001 0.0869 0.1974 0.2414 0.198 ...\r\n $ concave.points_mean    : num  0.1471 0.0702 0.1279 0.1052 0.1043 ...\r\n $ symmetry_mean          : num  0.242 0.181 0.207 0.26 0.181 ...\r\n $ fractal_dimension_mean : num  0.0787 0.0567 0.06 0.0974 0.0588 ...\r\n $ radius_se              : num  1.095 0.543 0.746 0.496 0.757 ...\r\n $ texture_se             : num  0.905 0.734 0.787 1.156 0.781 ...\r\n $ perimeter_se           : num  8.59 3.4 4.58 3.44 5.44 ...\r\n $ area_se                : num  153.4 74.1 94 27.2 94.4 ...\r\n $ smoothness_se          : num  0.0064 0.00522 0.00615 0.00911 0.01149 ...\r\n $ compactness_se         : num  0.049 0.0131 0.0401 0.0746 0.0246 ...\r\n $ concavity_se           : num  0.0537 0.0186 0.0383 0.0566 0.0569 ...\r\n $ concave.points_se      : num  0.0159 0.0134 0.0206 0.0187 0.0188 ...\r\n $ symmetry_se            : num  0.03 0.0139 0.0225 0.0596 0.0176 ...\r\n $ fractal_dimension_se   : num  0.00619 0.00353 0.00457 0.00921 0.00511 ...\r\n $ radius_worst           : num  25.4 25 23.6 14.9 22.5 ...\r\n $ texture_worst          : num  17.3 23.4 25.5 26.5 16.7 ...\r\n $ perimeter_worst        : num  184.6 158.8 152.5 98.9 152.2 ...\r\n $ area_worst             : num  2019 1956 1709 568 1575 ...\r\n $ smoothness_worst       : num  0.162 0.124 0.144 0.21 0.137 ...\r\n $ compactness_worst      : num  0.666 0.187 0.424 0.866 0.205 ...\r\n $ concavity_worst        : num  0.712 0.242 0.45 0.687 0.4 ...\r\n $ concave.points_worst   : num  0.265 0.186 0.243 0.258 0.163 ...\r\n $ symmetry_worst         : num  0.46 0.275 0.361 0.664 0.236 ...\r\n $ fractal_dimension_worst: num  0.1189 0.089 0.0876 0.173 0.0768 ...\r\n```\r\n\r\nid列并没有实际意义，应该剔除\r\n\r\n```\r\n\u003e wb \u003c- wb[-1]\r\n```\r\n\r\n预测类特征为diagnosis，应该是一个因子型向量，但是现在明显不是，所以应该转化一下\r\n\r\n```\r\n\u003e str(wb$diagnosis)\r\n chr [1:569] \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" ...\r\n\u003e wb$diagnosis \u003c- factor(wb$diagnosis, levels = c(\"B\", \"M\"), labels = c(\"Benign\", \"Malignant\"))\r\n\u003e str(wb$diagnosis)\r\n Factor w/ 2 levels \"Benign\",\"Malignant\": 2 2 2 2 2 2 2 2 2 2 ...\r\n```\r\n\r\n从上述数据结构也可以看出，某些特征的值非常大，而某些特征的值又很小，所以必须进行标准化操作，如下\r\n\r\n```\r\n\u003e normalize \u003c- function(x) {\r\n+   return ((x - min(x)) / (max(x) - min(x)))\r\n+ }\r\n\u003e wb.normalize \u003c- as.data.frame(lapply(wb[2 : 31], normalize))\r\n```\r\n\r\n然后分别构造训练集与测试集，如下\r\n\r\n```\r\n\u003e wb.normalize.train \u003c- wb.normalize[1 : 469, ]\r\n\u003e wb.normalize.test \u003c- wb.normalize[470 : 569, ]\r\n```\r\n\r\n由于我们标准化的数据剔除了目标特征，在建模阶段需要训练集的目标特征，而在测试集验证中需要测试集的目标特征，所以我们从标准化之前的数据框中提取该列向量，如下\r\n\r\n```\r\n\u003e wb.normalize.train.labels \u003c- wb[1 : 469, 1]\r\n\u003e wb.normalize.test.labels \u003c- wb[470 : 569, 1]\r\n```\r\n\r\n现在就可以创建分类器并预测了，如下\r\n\r\n```\r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 3)\r\n```\r\n\r\n### 2.3 评估模型性能\r\n\r\n```\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.06  0.94 \r\n```\r\n\r\n可见正确率为94%，还是相当不错的，也可以通过双向交叉表来查看，如下\r\n\r\n```\r\n\u003e table(wb.normalize.test.labels, p)\r\n                        p\r\nwb.normalize.test.labels Benign Malignant\r\n               Benign        72         5\r\n               Malignant      1        22\r\n```\r\n\r\n或者\r\n\r\n```\r\n\u003e library(gmodels)\r\n\u003e CrossTable(x = wb.normalize.test.labels, y = p, prop.chisq = FALSE)\r\n\r\n \r\n   Cell Contents\r\n|-------------------------|\r\n|                       N |\r\n|           N / Row Total |\r\n|           N / Col Total |\r\n|         N / Table Total |\r\n|-------------------------|\r\n\r\n \r\nTotal Observations in Table:  100 \r\n\r\n \r\n                         | p \r\nwb.normalize.test.labels |    Benign | Malignant | Row Total | \r\n-------------------------|-----------|-----------|-----------|\r\n                  Benign |        72 |         5 |        77 | \r\n                         |     0.935 |     0.065 |     0.770 | \r\n                         |     0.986 |     0.185 |           | \r\n                         |     0.720 |     0.050 |           | \r\n-------------------------|-----------|-----------|-----------|\r\n               Malignant |         1 |        22 |        23 | \r\n                         |     0.043 |     0.957 |     0.230 | \r\n                         |     0.014 |     0.815 |           | \r\n                         |     0.010 |     0.220 |           | \r\n-------------------------|-----------|-----------|-----------|\r\n            Column Total |        73 |        27 |       100 | \r\n                         |     0.730 |     0.270 |           | \r\n-------------------------|-----------|-----------|-----------|\r\n```\r\n\r\n可见，共有1个原本是Benign的却被预测为Malignant，而有5个原本是Malignant的，却被预测为Benign。\r\n\r\n### 2.4 提高模型的性能\r\n\r\n提高模型的性能可以通过调整k值来实现，试着调大k值\r\n\r\n```\r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 5)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.03  0.97 \r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 7)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.02  0.98 \r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 9)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.02  0.98 \r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 11)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.02  0.98 \r\n```\r\n\r\n可见，分类器表现不错，再试试两个极端的k值？如下\r\n\r\n```\r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 1)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.07  0.93 \r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 469)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.23  0.77 \r\n```\r\n\r\n明显不如介于两个极端之间的K值拟合效果好。\r\n\r\n全文完！","cover":"/images/knn.png","link":"k-nearest-neighbor-algorithm.html","preview":"\u003cp\u003ek最近邻分类器就是把未标记的案例归类为与它们最相似的带有标记的案例所在的类，广泛适用于数据特征与目标类之间的关系众多且复杂，用其它方式难以理解，但是具有相似类的项目又非常类似的分类任务。\u003c/p\u003e\n","title":"懒惰学习——K最近邻学习算法"},{"content":"\r\n\r\n与有监督学习算法不同，无监督学习算法的训练集数据并没有目标特征，我们不知道有哪些类别以及有几个类别，只能通过算法探索将相似度较高或者同质性强的样本聚类在一起，最终实现对无标签案例的分类任务。\r\n\r\n## 一、K均值聚类学习算法\r\n\r\nK均值聚类(K-Means Clustering)是一种数据聚类算法，可用于无监督的机器学习。它能够将类似的非标记数据组合到预定数量的簇中。\r\n\r\n### 1.1 K均值聚类与kNN最近邻的对比\r\n\r\nK均值聚类在某些程度上与kNN最近邻有监督学习算法有相似之处，如下：\r\n\r\n1. 都是将相似度高或者同质性强的样本对象集聚在一起；\r\n2. 都包含一定簇，每个簇代表一类样本；\r\n3. 都是基于距离(特别是欧式距离)的分类或聚类算法。\r\n\r\n二者也有区别，如下：\r\n\r\n1. K均值属于无监督学习算法，kNN属于有监督学习算法；\r\n2. 由于K均值无监督学习算法的特征，数据集并没有目标特征，全靠算法探索；而kNN有监督学习算法则拥有目标特征；\r\n3. kNN被认为是懒惰的、机械的，模型性能或泛化能力高度依赖于训练集数据的泛性，如果训练集数据极具概括性，那么模型的泛化能力很强而且训练时间短，反之则模型泛化能力差；而K均值则由于模型的迭代修正使得预测结果更加稳健；\r\n4. 对模型的评估，kNN显得更加客观公正和简单；但是K均值则需要全方位多角度的评估，且带有主观性。\r\n\r\n### 1.2 K均值聚类的原理\r\n\r\n在训练阶段，**K均值聚类的目标是将n个训练集样本根据其特征集，将样本分配给与某簇相似的或者与某簇质心距离最近的簇中，而与当前簇距离较远的样本归入另外的簇中**。其中，簇是一个对象的集合，**簇中的对象(样本)相似度极高，簇间差异化极大**。\r\n\r\n该算法本质上包含以下步骤：\r\n\r\n1. 首先初始化簇质心，一种办法是从训练集数据中随机选择k个案例(这里的随机并不意味着训练结果的不精确，因为之后会通过迭代重新选择质心优化模型)；\r\n2. 计算训练集各案例到各簇质心的距离，然后将该案例归入距离最小的簇中；\r\n3. 训练集案例分配完毕后，重新计算各簇的质心(通过计算训练集特征空间中各特征的均值构造质心)；重复第2步和第3步，直至迭代操作不会再提升类优度为止。\r\n\r\n### 1.3 K均值通过距离实现类的更新与分配\r\n\r\n通常情况下，K均值使用欧式距离(欧式距离计算两点之间的距离，即两点之间的连线)来计算两个案例之间的距离，公式定义如下：\r\n\r\n![](/images/article/k-means1.png)\r\n\r\n其中，x和y分别代表两个案例，xi与yi分别代表两个案例的第i个特征值。通过使用该距离函数，就可以计算两个案例之间的距离。在K-Means中，我们通过计算某案例与簇质心之间的欧式距离，然后将该案例分配给距离最近的簇。\r\n\r\n但并不意味着K-Means只能使用欧式距离来度量案例之间的距离，其余距离公式如下\r\n\r\n+ 曼哈顿距离：用以标明两个点在标准坐标系上的绝对轴距总和, 又名“城市街区距离”，因为城市两点之间的实际距离并不是两点之间的直线距离(因为有建筑物等阻挡)，只能是两点在标准坐标系上的绝对距离之和。\r\n\r\n![](/images/article/k-means2.png)\r\n\r\n+ 切比雪夫距离：是向量空间中的一种度量，二个点之间的距离定义为其各坐标数值差绝对值的最大值。\r\n\r\n![](/images/article/k-means4.png)\r\n\r\n+ 闵可夫斯基距离：两个n维变量a(a1, a2, ..., an)与 b(b1, b2, ...,   bn)间的闵可夫斯基距离定义为：\r\n\r\n![](/images/article/k-means3.png)\r\n\r\n闵可夫斯基距离中，p是一个可变参数，特别的，当p=1时，就是曼哈顿距离；当p=2时，就是欧氏距离；当p→∞时，就是切比雪夫距离。可见，闵氏距离是一组距离而不是一个距离。\r\n\r\n### 1.4 聚类中K的选择\r\n\r\n影响K均值聚类模型的最重要的因素就是K的选择，过大的K利于提升簇内的同质性与簇间的异质性，但是会有过度拟合的风险，过小的K则无法识别类之间的差异。因此，K的选择应该是合适就好，一般有以下方法：\r\n\r\n+ 如果具备真实分组先验知识，那么我们就会提前知道我们想分为几类，那么K就是几，当然这是最理想的；\r\n+ 如果不具备先验知识，那么一个经验性的规则就是令`K = (n / 2) ^ (1 / 2)`，但是对于大样本而言，这无疑仍然会导一个较大的K值；\r\n+ 一种被称为“肘部法”的技术用于衡量关于K值选择的合适的度。一般情况下，**随着K值的增大，簇内部的同质性增强，同样的，簇间的异质性也会增强；但是随着k值的继续增大，簇内部的同质性仍然在增强，但是簇间的异质性却在降低，因为过度拟合**。**理想的情况是，当簇内的同质性与簇间的异质性达到最大时，就应该立即停止K的增大**，这时，K就是最合适的K。\r\n\r\n## 二、K均值聚类学习算法的数学定义\r\n\r\nK均值聚类在实际应用过程中，是用局部最优解来逐步实现全局最优的。即每一次迭代中根据簇内均值计算簇质心，然后将所有训练集样本重新分配，确保每次迭代中每一个样本都是满足“到达某簇质心的距离最小”这一条件的。数学定义如下\r\n\r\n### 2.1 数学定义\r\n\r\n各簇的定义为：\r\n\r\n![](/images/article/k-means8.png)\r\n\r\n可见，分为了c个簇，所有的训练集样本将会被分配到这c个簇当中；\r\n\r\n初始阶段，簇质心随机选择c个。而更新迭代阶段，簇质心的定义(更新规则)为：\r\n\r\n![](/images/article/k-means6.png)\r\n\r\n即对当前簇中各特征求和再除以簇内样本总数，即求均值，然后就会得到簇质心的坐标。\r\n\r\n而在整个模型训练中，对样本分配簇被定义为：\r\n\r\n![](/images/article/k-means7.png)\r\n\r\n其中xi为训练集中某一个样本的特征向量，uy为簇质心的特征向量，为了与绝对值区分，`||xi-uy||`代表两点之间的距离(可以理解为具体距离公式的统称)，那么整个式子的含义是**计算该样本与各个簇心的距离，并为该样本赋予距离最近的簇心类别，即将该样本纳入该簇当中**。上式也就是为达到全局最优解而拆分的局部最优解。\r\n\r\n### 2.2 算法的规范描述\r\n\r\n基于上述数学定义，那么算法的规范描述为：\r\n\r\n1. 给各个簇中心u1, u2, ..., uc以适当的初始值; \r\n2. 更新样本x1, x2, ..., xn对应的聚类标签y1, y2, ..., yn：\r\n![](/images/article/k-means7.png)\r\n3. 更新各个簇中心u1, u2, ..., uc：\r\n![](/images/article/k-means6.png)\r\n4. 直到聚类标签达到收敛精度为止，否则重复上述2，3步的计算。\r\n\r\n## 三、R语言中K均值聚类函数及应用\r\n\r\n### 3.1 K均值聚类函数\r\n使用stats添加包中的`kmeans()`函数来实现K均值聚类，原型如下\r\n\r\n首先建立模型\r\n\r\n```\r\nclusters \u003c- kmeans(mydata, k)\r\n```\r\n\r\n+ mydata：数值型数据框，包含需要聚类的实例；\r\n+ k：聚类的个数。\r\n\r\n该函数返回一个含有K均值聚类结果的对象。\r\n\r\n然后检查聚类结果\r\n\r\n+ `clusters$cluster`是`kmeans()`函数所给出的类成员变量；\r\n+ `clusters$centers`是含有每个类组合和每一个特征的均值的一个矩阵；\r\n+ `clusters$size`给出每一个类中的实例个数。\r\n\r\n### 3.2 K均值聚类函数应用\r\n\r\n本例使用K均值聚类探索青少年市场细分，共包含30 000名青少年随机案例数据集，由于是无监督机器学习，那么我们不需要拆分数据集为训练集与测试集，所有的数据均为训练集或者样本，首先读取数据\r\n\r\n```\r\n\u003e getwd()\r\n[1] \"C:/Users/Administrator/Documents\"\r\n\u003e setwd(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\docs\\\\Machine-Learning-with-R-datasets-master\")\r\n\u003e tee \u003c- read.csv(\"snsdata.csv\")\r\n\u003e str(tee)\r\n'data.frame':\t30000 obs. of  40 variables:\r\n $ gradyear    : int  2006 2006 2006 2006 2006 2006 2006 2006 2006 2006 ...\r\n $ gender      : Factor w/ 2 levels \"F\",\"M\": 2 1 2 1 NA 1 1 2 1 1 ...\r\n $ age         : num  19 18.8 18.3 18.9 19 ...\r\n $ friends     : int  7 0 69 0 10 142 72 17 52 39 ...\r\n $ basketball  : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ football    : int  0 1 1 0 0 0 0 0 0 0 ...\r\n $ soccer      : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ softball    : int  0 0 0 0 0 0 0 1 0 0 ...\r\n $ volleyball  : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ swimming    : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ cheerleading: int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ baseball    : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ tennis      : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ sports      : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ cute        : int  0 1 0 1 0 0 0 0 0 1 ...\r\n $ sex         : int  0 0 0 0 1 1 0 2 0 0 ...\r\n $ sexy        : int  0 0 0 0 0 0 0 1 0 0 ...\r\n $ hot         : int  0 0 0 0 0 0 0 0 0 1 ...\r\n $ kissed      : int  0 0 0 0 5 0 0 0 0 0 ...\r\n $ dance       : int  1 0 0 0 1 0 0 0 0 0 ...\r\n $ band        : int  0 0 2 0 1 0 1 0 0 0 ...\r\n $ marching    : int  0 0 0 0 0 1 1 0 0 0 ...\r\n $ music       : int  0 2 1 0 3 2 0 1 0 1 ...\r\n $ rock        : int  0 2 0 1 0 0 0 1 0 1 ...\r\n $ god         : int  0 1 0 0 1 0 0 0 0 6 ...\r\n $ church      : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ jesus       : int  0 0 0 0 0 0 0 0 0 2 ...\r\n $ bible       : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ hair        : int  0 6 0 0 1 0 0 0 0 1 ...\r\n $ dress       : int  0 4 0 0 0 1 0 0 0 0 ...\r\n $ blonde      : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ mall        : int  0 1 0 0 0 0 2 0 0 0 ...\r\n $ shopping    : int  0 0 0 0 2 1 0 0 0 1 ...\r\n $ clothes     : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ hollister   : int  0 0 0 0 0 0 2 0 0 0 ...\r\n $ abercrombie : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ die         : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ death       : int  0 0 1 0 0 0 0 0 0 0 ...\r\n $ drunk       : int  0 0 0 0 1 1 0 0 0 0 ...\r\n $ drugs       : int  0 0 0 0 1 0 0 0 0 0 ...\r\n```\r\n\r\n观察到`gender`列存在缺失值，不妨验证一下\r\n\r\n```\r\n\u003e table(tee$gender)\r\n    F     M \r\n22054  5222 \r\n\u003e table(tee$gender, useNA = \"ifany\")\r\n    F     M  \u003cNA\u003e \r\n22054  5222  2724\r\n```\r\n\r\n可见在`gender`列共有2724个缺失值，其它列有缺失值吗，不妨再看看\r\n\r\n```\r\n\u003e summary(tee)\r\n    gradyear     gender           age             friends         basketball     \r\n Min.   :2006   F   :22054   Min.   :  3.086   Min.   :  0.00   Min.   : 0.0000  \r\n 1st Qu.:2007   M   : 5222   1st Qu.: 16.312   1st Qu.:  3.00   1st Qu.: 0.0000  \r\n Median :2008   NA's: 2724   Median : 17.287   Median : 20.00   Median : 0.0000  \r\n Mean   :2008                Mean   : 17.994   Mean   : 30.18   Mean   : 0.2673  \r\n 3rd Qu.:2008                3rd Qu.: 18.259   3rd Qu.: 44.00   3rd Qu.: 0.0000  \r\n Max.   :2009                Max.   :106.927   Max.   :830.00   Max.   :24.0000  \r\n                             NA's   :5086                                        \r\n    football           soccer           softball         volleyball     \r\n Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000  \r\n 1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000  \r\n Median : 0.0000   Median : 0.0000   Median : 0.0000   Median : 0.0000  \r\n Mean   : 0.2523   Mean   : 0.2228   Mean   : 0.1612   Mean   : 0.1431  \r\n 3rd Qu.: 0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.0000  \r\n Max.   :15.0000   Max.   :27.0000   Max.   :17.0000   Max.   :14.0000  \r\n                                                                        \r\n    swimming        cheerleading       baseball           tennis        \r\n Min.   : 0.0000   Min.   :0.0000   Min.   : 0.0000   Min.   : 0.00000  \r\n 1st Qu.: 0.0000   1st Qu.:0.0000   1st Qu.: 0.0000   1st Qu.: 0.00000  \r\n Median : 0.0000   Median :0.0000   Median : 0.0000   Median : 0.00000  \r\n Mean   : 0.1344   Mean   :0.1066   Mean   : 0.1049   Mean   : 0.08733  \r\n 3rd Qu.: 0.0000   3rd Qu.:0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.00000  \r\n Max.   :31.0000   Max.   :9.0000   Max.   :16.0000   Max.   :15.00000  \r\n                                                                        \r\n     sports           cute              sex                sexy        \r\n Min.   : 0.00   Min.   : 0.0000   Min.   :  0.0000   Min.   : 0.0000  \r\n 1st Qu.: 0.00   1st Qu.: 0.0000   1st Qu.:  0.0000   1st Qu.: 0.0000  \r\n Median : 0.00   Median : 0.0000   Median :  0.0000   Median : 0.0000  \r\n Mean   : 0.14   Mean   : 0.3229   Mean   :  0.2094   Mean   : 0.1412  \r\n 3rd Qu.: 0.00   3rd Qu.: 0.0000   3rd Qu.:  0.0000   3rd Qu.: 0.0000  \r\n Max.   :12.00   Max.   :18.0000   Max.   :114.0000   Max.   :18.0000  \r\n                                                                       \r\n      hot              kissed            dance              band        \r\n Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000  \r\n 1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000  \r\n Median : 0.0000   Median : 0.0000   Median : 0.0000   Median : 0.0000  \r\n Mean   : 0.1266   Mean   : 0.1032   Mean   : 0.4252   Mean   : 0.2996  \r\n 3rd Qu.: 0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.0000  \r\n Max.   :10.0000   Max.   :26.0000   Max.   :30.0000   Max.   :66.0000  \r\n                                                                        \r\n    marching           music              rock              god         \r\n Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000  \r\n 1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000  \r\n Median : 0.0000   Median : 0.0000   Median : 0.0000   Median : 0.0000  \r\n Mean   : 0.0406   Mean   : 0.7378   Mean   : 0.2433   Mean   : 0.4653  \r\n 3rd Qu.: 0.0000   3rd Qu.: 1.0000   3rd Qu.: 0.0000   3rd Qu.: 1.0000  \r\n Max.   :11.0000   Max.   :64.0000   Max.   :21.0000   Max.   :79.0000  \r\n                                                                        \r\n     church            jesus             bible               hair        \r\n Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.00000   Min.   : 0.0000  \r\n 1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.00000   1st Qu.: 0.0000  \r\n Median : 0.0000   Median : 0.0000   Median : 0.00000   Median : 0.0000  \r\n Mean   : 0.2482   Mean   : 0.1121   Mean   : 0.02133   Mean   : 0.4226  \r\n 3rd Qu.: 0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.00000   3rd Qu.: 0.0000  \r\n Max.   :44.0000   Max.   :30.0000   Max.   :11.00000   Max.   :37.0000  \r\n                                                                         \r\n     dress           blonde              mall            shopping     \r\n Min.   :0.000   Min.   :  0.0000   Min.   : 0.0000   Min.   : 0.000  \r\n 1st Qu.:0.000   1st Qu.:  0.0000   1st Qu.: 0.0000   1st Qu.: 0.000  \r\n Median :0.000   Median :  0.0000   Median : 0.0000   Median : 0.000  \r\n Mean   :0.111   Mean   :  0.0989   Mean   : 0.2574   Mean   : 0.353  \r\n 3rd Qu.:0.000   3rd Qu.:  0.0000   3rd Qu.: 0.0000   3rd Qu.: 1.000  \r\n Max.   :9.000   Max.   :327.0000   Max.   :12.0000   Max.   :11.000  \r\n                                                                      \r\n    clothes         hollister        abercrombie           die         \r\n Min.   :0.0000   Min.   :0.00000   Min.   :0.00000   Min.   : 0.0000  \r\n 1st Qu.:0.0000   1st Qu.:0.00000   1st Qu.:0.00000   1st Qu.: 0.0000  \r\n Median :0.0000   Median :0.00000   Median :0.00000   Median : 0.0000  \r\n Mean   :0.1485   Mean   :0.06987   Mean   :0.05117   Mean   : 0.1841  \r\n 3rd Qu.:0.0000   3rd Qu.:0.00000   3rd Qu.:0.00000   3rd Qu.: 0.0000  \r\n Max.   :8.0000   Max.   :9.00000   Max.   :8.00000   Max.   :22.0000  \r\n                                                                       \r\n     death             drunk             drugs         \r\n Min.   : 0.0000   Min.   :0.00000   Min.   : 0.00000  \r\n 1st Qu.: 0.0000   1st Qu.:0.00000   1st Qu.: 0.00000  \r\n Median : 0.0000   Median :0.00000   Median : 0.00000  \r\n Mean   : 0.1142   Mean   :0.08797   Mean   : 0.06043  \r\n 3rd Qu.: 0.0000   3rd Qu.:0.00000   3rd Qu.: 0.00000  \r\n Max.   :14.0000   Max.   :8.00000   Max.   :16.00000  \r\n ```\r\n \r\n发现只有age列和gender列存在缺失值，对待缺失值我们要么插补要么直接删除记录，我们这里使用插补的办法。\r\n \r\n再观察上述基本统计量，我们发现年龄的最小值为3.086，最大值为106.927，这明显是错误的，我们假定青少年的年龄区间是`[13, 20)`，那么我们定义超出该区间的所有数据为异常值，对于异常值，我们可以将其视作缺失值处理，也可以不处理，这里明显需要处理。\r\n \r\n首先，将不符合年龄区间的值统一设置为缺失值，如下\r\n \r\n```\r\n\u003e tee$age \u003c- ifelse(tee$age \u003e= 13 \u0026 tee$age \u003c 20, tee$age, NA)\r\n\u003e summary(tee$age)\r\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \r\n  13.03   16.30   17.27   17.25   18.22   20.00    5523 \r\n```\r\n\r\n接下来需要将年龄的缺失值进行插补，这里使用均值插补法，考虑到毕业年份`gradyear`和年龄`age`之间的关系，我们要计算多次均值来插补，使用`ave()`函数来计算`age`列关于`gradyear`列中各水平的均值，如下\r\n\r\n```\r\n\u003e ave_age \u003c- ave(tee$age, tee$gradyear, FUN = function(x) mean(x, na.rm = TRUE))\r\n\u003e length(ave_age)\r\n[1] 30000\r\n```\r\n\r\n参数`ave_age`包含数据框中以`gradyear`列为基准的`age`列对应的值。然后进行插补\r\n\r\n```\r\n\u003e tee$age \u003c- ifelse(is.na(tee$age), ave_age, tee$age)\r\n```\r\n\r\n如果`tee$age`满足条件`is.na(tee$age)`那么使用该`age`对应的根据`gradyear`得到的均值来插补，否则就原封不动(因为真实的值比虚拟的均值更能说明问题)，再看一下插补结果\r\n\r\n```\r\n\u003e summary(tee$age)\r\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \r\n  13.03   16.28   17.24   17.24   18.21   20.00 \r\n```\r\n\r\n以上是对`age`的处理，而对`gender`的处理我们通过创建虚拟变量来拆分gender语义，因为性别我们无法计算均值，首先我们创建虚拟变量`female`将所有的女性设置为变量1，其余均为0，如下\r\n\r\n```\r\n\u003e tee$female \u003c- ifelse(tee$gender == \"F\" \u0026 !is.na(tee$gender), 1, 0)\r\n\u003e table(tee$female)\r\n    0     1 \r\n 7946 22054 \r\n```\r\n\r\n然后再创建虚拟变量`no_gender`将`gender`中所有的缺失值设置为1，其余为0，如下\r\n\r\n```\r\n\u003e tee$no_gender \u003c- ifelse(is.na(tee$gender), 1, 0)\r\n\u003e table(tee$no_gender)\r\n\r\n    0     1 \r\n27276  2724 \r\n```\r\n\r\n如下，我们通过比较虚拟变量`female`与`no_gender`和变量`gender`发现，虚拟变量值为1的数目与变量`gender`中值为`F`和`NA`的数目是一致的。\r\n\r\n```\r\n\u003e table(tee$gender, useNA = \"ifany\")\r\n\r\n    F     M  \u003cNA\u003e \r\n22054  5222  2724 \r\n\u003e table(tee$female, useNA = \"ifany\")\r\n\r\n    0     1 \r\n 7946 22054 \r\n\u003e table(tee$no_gender, useNA = \"ifany\")\r\n\r\n    0     1 \r\n27276  2724 \r\n```\r\n\r\n在创建虚拟变量之后，数据框变量数量也变成了42个\r\n\r\n```\r\n\u003e str(tee)\r\n'data.frame':\t30000 obs. of  42 variables:\r\n\r\n $ female      : num  0 1 0 1 0 1 1 0 1 1 ...\r\n $ no_gender   : num  0 0 0 0 1 0 0 0 0 0 ...\r\n```\r\n\r\n我们暂且选择36个特征，并将相关的值进行标准化操作，如下\r\n\r\n```\r\n\u003e ts \u003c- tee[5 : 40]\r\n\u003e ts_z \u003c- as.data.frame(lapply(ts, scale))\r\n```\r\n\r\n然后进行聚类并查看簇数目以及簇内样本数\r\n\r\n```\r\n\u003e ts_clusters \u003c- kmeans(ts, 5)\r\n\u003e ts_clusters$size\r\n[1]  4937 22254  1202  1208   399\r\n```\r\n\r\n也可以查看各簇最终的质心坐标，如下\r\n\r\n```\r\n\u003e ts_clusters$centers\r\n  basketball  football    soccer  softball volleyball  swimming cheerleading\r\n1  0.2868139 0.2928904 0.2602795 0.1802714  0.1474580 0.1861454   0.09459186\r\n2  0.2298014 0.2149726 0.1969534 0.1441539  0.1302238 0.1124292   0.09526377\r\n3  0.7762063 0.6630616 0.5382696 0.3552413  0.3202995 0.2995008   0.28785358\r\n4  0.3625828 0.3716887 0.2408940 0.1895695  0.1912252 0.1605960   0.18791391\r\n5  0.2982456 0.2330827 0.1929825 0.2055138  0.1303258 0.1428571   0.09774436\r\n    baseball     tennis    sports      cute        sex      sexy       hot\r\n1 0.11221390 0.11829046 0.1691311 0.3607454 0.17318209 0.1498886 0.1484707\r\n2 0.09086007 0.07499775 0.1137773 0.2574818 0.09778017 0.1164285 0.1044756\r\n3 0.35690516 0.17387687 0.5049917 1.0232945 2.47420965 0.4692180 0.3319468\r\n4 0.08526490 0.10264901 0.1225166 0.6688742 0.16639073 0.2293046 0.2235099\r\n5 0.10025063 0.08521303 0.1929825 0.3433584 0.19047619 0.1604010 0.1779449\r\n      kissed     dance      band   marching     music      rock       god    church\r\n1 0.11403686 0.3133482 1.0870974 0.15596516 2.3101074 0.4231315 0.4909864 0.3862670\r\n2 0.04844073 0.2005033 0.1007459 0.01451424 0.3038106 0.1485126 0.3040352 0.1767323\r\n3 1.07820300 0.8569052 0.6663894 0.05407654 2.0316140 1.1605657 0.8386023 0.4068220\r\n4 0.09519868 4.6117550 0.3443709 0.03725166 0.9271523 0.3336093 0.5248344 0.4917219\r\n5 0.11027569 0.3634085 0.4060150 0.03759398 1.0200501 0.2706767 7.8370927 1.3082707\r\n       jesus      bible      hair      dress     blonde      mall  shopping\r\n1 0.13510229 0.02734454 0.3583148 0.13733036 0.07251367 0.3090946 0.4563500\r\n2 0.07764896 0.01285162 0.2316887 0.08164824 0.05194572 0.2039184 0.2962164\r\n3 0.14226290 0.03660566 3.9991681 0.33194676 1.07321131 0.8252912 0.6863561\r\n4 0.11423841 0.02649007 0.6092715 0.30463576 0.09850993 0.4528146 0.6423841\r\n5 1.64912281 0.35839599 0.5238095 0.16791980 0.11278195 0.2957393 0.3609023\r\n    clothes  hollister abercrombie       die     death      drunk      drugs\r\n1 0.1818918 0.06765242  0.04354871 0.2185538 0.1468503 0.09155358 0.06785497\r\n2 0.1040262 0.05895569  0.04147569 0.1331446 0.0871304 0.06385369 0.03181451\r\n3 0.7146423 0.25623960  0.22628952 0.8286190 0.3785358 0.47171381 0.56073211\r\n4 0.2367550 0.10264901  0.09023179 0.2425497 0.1374172 0.11175497 0.05711921\r\n5 0.2431078 0.04511278  0.04010025 0.4812030 0.3558897 0.16040100 0.06766917\r\n```\r\n\r\n而`cluster`分量则保存了每个样本的类别，可以将其作为一列添加到数据框中并查看部分数据，如下\r\n\r\n```\r\n\u003e tee$cluster \u003c- ts_clusters$cluster\r\n\u003e tee[1 : 5, c(\"gender\", \"age\", \"friends\", \"cluster\")]\r\n  gender    age friends cluster\r\n1      M 18.982       7       2\r\n2      F 18.801       0       3\r\n3      M 18.335      69       1\r\n4      F 18.875       0       2\r\n5   \u003cNA\u003e 18.995      10       1\r\n```\r\n\r\n### 3.3 提升模型性能\r\n\r\n无监督学习算法的模型评估不像有监督学习算法一样，因为有监督学习算法的模型评估都有一组训练集的目标值与模型预测值进行对照，因此很容易评估模型性能，但是无监督学习算法则丧失了这个优势。\r\n\r\n无监督学习模型的评估需要根据实际情况来判断。以K均值聚类算法为例，一般情况下评估一个模型是否有用的基本方法之一是检查落在每一组中的案例数，如果簇间的案例分布极不均匀或者某簇的案例过多或过少，那么这个模型就不太有用。\r\n\r\n```\r\n\u003e ts_clusters$size\r\n[1]  4937 22254  1202  1208   399\r\n\u003e prop.table(ts_clusters$size)\r\n[1] 0.16456667 0.74180000 0.04006667 0.04026667 0.01330000\r\n```\r\n\r\n对模型性能的实验，可以通过调整参数k来实现，我们可以尝试几种不同的k值，如下\r\n\r\n```\r\n\u003e ts_clusters \u003c- kmeans(ts, 6)\r\n\u003e prop.table(ts_clusters$size)\r\n[1] 0.15206667 0.13893333 0.62666667 0.02500000 0.03850000 0.01883333\r\n\u003e ts_clusters \u003c- kmeans(ts, 7)\r\n\u003e prop.table(ts_clusters$size)\r\n[1] 0.63376667 0.03773333 0.01903333 0.02416667 0.03093333 0.22570000 0.02866667\r\n\u003e ts_clusters \u003c- kmeans(ts, 8)\r\n\u003e prop.table(ts_clusters$size)\r\n[1] 0.03720000 0.01833333 0.61993333 0.02693333 0.14273333 0.11223333 0.02396667\r\n[8] 0.01866667\r\n\u003e ts_clusters \u003c- kmeans(ts, 9)\r\n\u003e prop.table(ts_clusters$size)\r\n[1] 0.065033333 0.052166667 0.036766667 0.006733333 0.314800000 0.463300000\r\n[7] 0.018933333 0.023766667 0.018500000\r\n```\r\n\r\n### 3.4 统计特征探索\r\n\r\n使用`aggregate()`函数，可以查看某特征在其水平约束下样本的某特征的相关统计量，比如\r\n\r\n```\r\n\u003e aggregate(data = tee, age ~ cluster, mean)\r\n  cluster      age\r\n1       1 17.23996\r\n2       2 17.25926\r\n3       3 16.98906\r\n4       4 17.02734\r\n5       5 17.36524\r\n```\r\n\r\n以上显示了在特征`cluster`五个水平的约束下各自样本的`age`均值，可以得出结论：**年龄并不是引起兴趣不同的主要因素(因为兴趣cluster约束下年龄的均值差别不大)**。\r\n\r\n```\r\n\u003e aggregate(data = tee, friends ~ cluster, mean)\r\n  cluster  friends\r\n1       1 32.13915\r\n2       2 29.23128\r\n3       3 31.43594\r\n4       4 37.36093\r\n5       5 33.28822\r\n```\r\n\r\n以上显示了特征`cluster`五个水平约束下各自样本的朋友数量的均值，可见，有差异但是还是比较集中。\r\n\r\n### 3.5 尾声\r\n\r\n之前在建立模型的时候，我们提取了数据所有行的第5到40列，原因之一就是gender列中还存在缺失值，但是我们通过两个虚拟变量分离出了gender的部分语义，那么我们将该变量再调整一下，以完全表达剩余语义，然后使用全部属性拟合模型，如下\r\n\r\n```\r\n\u003e tee \u003c- read.csv(\"snsdata.csv\")\r\n\u003e tee$age \u003c- ifelse(tee$age \u003e= 13 \u0026 tee$age \u003c 20, tee$age, NA)\r\n\u003e ave_age \u003c- ave(tee$age, tee$gradyear, FUN = function(x) mean(x, na.rm = TRUE))\r\n\u003e tee$age \u003c- ifelse(is.na(tee$age), ave_age, tee$age)\r\n\u003e tee$female \u003c- ifelse(tee$gender == \"F\" \u0026 !is.na(tee$gender), 1, 0)\r\n\u003e tee$no_gender \u003c- ifelse(is.na(tee$gender), 1, 0)\r\n\u003e tee$gender \u003c- ifelse(tee$gender == \"F\" | is.na(tee$gender), 0, 1)\r\n\u003e table(is.na(tee$gender))\r\n\r\nFALSE \r\n30000 \r\n\u003e tee \u003c- as.data.frame(lapply(tee, scale))\r\n\u003e tee_clusters \u003c- kmeans(tee, 5)\r\n\u003e tee_clusters$size\r\n[1]  2659  1766  9993 10485  5097\r\n\u003e prop.table(tee_clusters$size)\r\n[1] 0.08863333 0.05886667 0.33310000 0.34950000 0.16990000\r\n\u003e tee$cluster \u003c- tee_clusters$cluster\r\n\u003e tee[1 : 5, c(\"gender\", \"female\", \"no_gender\", \"age\", \"friends\", \"cluster\")]\r\n      gender     female  no_gender       age    friends cluster\r\n1  2.1782486 -1.6659508 -0.3160137 1.5279745 -0.6345171       5\r\n2 -0.4590691  0.6002378 -0.3160137 1.3694558 -0.8261358       2\r\n3  2.1782486 -1.6659508 -0.3160137 0.9613359  1.0626773       5\r\n4 -0.4590691  0.6002378 -0.3160137 1.4342645 -0.8261358       3\r\n5 -0.4590691 -1.6659508  3.1643138 1.5393598 -0.5523948       2\r\n```\r\n\r\n由于数据标准化方法采用的是`z-score`标准化，所以负值表示低于某列(特征)的均值，正值表示高于某列(特征)的均值。\r\n\r\n全文完！","cover":"/images/k-means.png","link":"k-means-clustering.html","preview":"\u003cp\u003e聚类学习被认为是典型的无监督学习算法，训练集数据没有目标特征。聚类的目标就是探索数据集中蕴藏的内在结构，并将相似或同质的群组数据聚集在一起。\u003c/p\u003e\n","title":"物以类聚——K均值聚类学习算法"},{"content":"\r\n\r\n## 一、SVM简介\r\n\r\n与其他传统的机器学习方法相比较，支持向量机(Support Vector Machine)的特点如下\r\n\r\n1. 以严格的数学理论为基础，克服了传统神经网络学习中靠经验和启发的先验成分等缺点;\r\n2. 以寻找特征空间最优超平面为目标使得学习器具有良好的泛化能力;\r\n3. 用内积的回旋巧妙地构造核函数，克服了特征空间中的维数灾难问题，通过非线性映射，只需在原空间中计算样本数据与支持向量的内积，而不需要知道非线性映射的显性表达式;\r\n4. 成功地解决了小样本学习问题，克服了传统上需要以样本数目无穷多为假设条件来推导各种算法的缺点，得到了小样本条件下的全局最优解。\r\n\r\n支持向量机包含三个主要思想：\r\n\r\n1. 最优超平面技术(控制决策面的推广能力或泛化能力);\r\n2. 硬间隔支持向量分类(决策边界从正负样本中间穿过)与软间隔支持向量分类(允许间隔计算中存在少许的误差);\r\n3. 内积核函数思想(使解平面从线性扩展到非线性)。\r\n\r\n## 二、硬间隔支持向量\r\n\r\n在数据线性可分的前提下，以分类任务为例，支持向量机可以理解为训练集中由不包括预测类在内的n维向量组成的特征空间中的一个n - 1维的超平面，该平面定义了各个数据点之间的界限。该超平面可以称之为**决策边界**。\r\n\r\n### 2.1 从二维空间推广到高维特征空间\r\n\r\n高维特征空间比较烧脑，不妨以二维特征空间为例，那么划分该二为特征空间的超平面的维数就是1，即一条线。\r\n\r\n有如下两种图形，分别是红圈与蓝星，直观上，我们可以用直线B将二者一刀切，正确划分！而直线A与直线C则表现得不是很好，产生了一定的误差。\r\n\r\n![](/images/article/svm1.png)\r\n\r\n事实上，如果我们愿意，甚至可以画出无数条可以正确区分二者的直线。\r\n\r\n![](/images/article/svm2.png)\r\n\r\n但是，这是样本较少的情况，如果测试集数据很多，那么我们当前看似能够正确区分二者的直线就有可能无法正确分割。有效应对这种问题的办法就是**寻找两个类之间最大间隔的最大间隔超平面**。\r\n\r\n那么在条件**两个类之间最大间隔的最大间隔超平面**的约束下，我们应该选择哪一条作为**决策边界**(超平面)？有两个办法(以本例为例)：\r\n\r\n第一种办法是，**求两种类边界组成的凸包间最短距离的直线的垂直平分线**。\r\n\r\n![](/images/article/svm4.png)\r\n\r\n上图中分别勾勒出了红圈与蓝星边界构成的凸包，绿色方点虚线为两个凸包之间的最短直线，而直线C则是穿过该最短直线的垂直平分线。那么直线C就是该问题中的最大间隔超平面或者决策边界。为什么一定要是垂直平分线呢？垂直平分线将两个凸包边界的最短距离平分，这样保证决策边界对两个类别是不偏不倚的，如果决策边界位于直线C的左边，那么蓝星就有可能越过该决策边界，同理，如果决策边界位于当前决策边界C的右边，红圈就有可能越过该决策边界。所以，垂直平分最短距离直线的直线才是本例中最好的决策边界。\r\n\r\n另一种办法是**通过寻找两个将一组数据划分为同类组的两个平行平面，但这两个平面本身却要尽可能远离，通过这两个平行平面确定决策边界**。\r\n\r\n![](/images/article/svm3.png)\r\n\r\n如上图所示，我们寻找到了两个能将一组数据划分为同类组的两个平行平面，分别是直线A和B，并且直线A与B已经最大程度上相互远离了，这样的话，我们的决策边界就是从这两个平行平面中间穿过的直线C。\r\n\r\n之前说过，支持向量机以严格的数学理论为基础，我们现在的问题是如何给决策边界或者说硬间隔支持向量分类的决策边界下数学定义。\r\n\r\n对于直线C，我们设其斜率为k，截距为b，那么其直线方程为：\r\n\r\n![](/images/article/svm5.png)\r\n\r\n同上一篇文章我们推理人工神经网络带0/1输出的硬阈值激活函数的过程相似，斜率k可以看作是特征x的权重，相应的特征y的权重为-1，截距仍然为b。\r\n\r\n这里的y并不是单纯的数学上的y，而是特征空间中的另一个特征，真正的y是分类的结果。以上直线方程是建立在二维特征空间的基础之上的，如果将其推广到高维空间，那么就会有如下的表达式：\r\n\r\n![](/images/article/svm6.png)\r\n\r\n其中，`fw,r(x)`代表预测类，即真正的y值，而`W的转置`代表特征空间x向量中各分量的权重，`r`代表截距。这不就是一个多元线性回归方程嘛，可以这么理解，但是不要被回归方程的思维所桎梏。那么我们再重新定义一下，其实`w`和`r`分别对应于把正样本和负样本隔离开的决策边界的法向量和截距。\r\n\r\n同上面说的一样，上述方程式在训练集样本完全线性可分的情况下仍然会有无数条直线满足条件，也就意味着分类效果仍然会受训练集样本概括性的影响，其泛化能力取决于测试集的实际情况。因为上述方程并未添加任何约束条件。我们接下来将其约束进一步确保我们的决策边界是唯一的是仅仅在训练集的条件下就具备泛化能力的。\r\n\r\n之前说过，决策边界是由两个平行平面决定的，也就意味着方程式斜率(特征空间各特征分量的权重)是一致的，即`w`相同，由于是二分类问题，我们定义正样本的边界(非决策边界而是正样本的与决策边界相平行的平行平面)为：\r\n\r\n![](/images/article/svm7.png)\r\n\r\n那么同理，负样本的边界定义为：\r\n\r\n![](/images/article/svm8.png)\r\n\r\n也就是说，所有的正样本被定义为1，所有的负样本被定义为-1，可以将这里的1与-1理解为训练集样本的实际值，但是为什么一定要定义为-1和1呢？这是因为一正一负最容易处理，而+1和-1更容易处理。\r\n\r\n综上，就有如下表达式：\r\n\r\n![](/images/article/svm9.png)\r\n\r\n其中`fw,r(x)`表示根据特征空间得到的预测值，而`yi`表示训练集样本目标值，由于我们上述将正样本的目标值定义为了`+1`，那么如果正样本的特征向量带入`fw,r(x)`后，得到的值为正，那么`fw,r(x)yi`一定为正；同理，我们上述将负样本的目标值定义为了`-1`，那么如果负样本的特征向量带入`fw,r(x)`后，得到的值为负，那么`fw,r(x)yi`也一定为正；也就是说：\r\n\r\n**如果模型正确二分类，那么上述表达式的值一定是大于0的。**\r\n\r\n我们现在找到了正确二分类的条件，但这还是远远不够的，同样的理由：可以正确二分类的函数有若干个(对应于几何解释就是有若干条直线可以正确划分正负样本训练集)，但是能最佳二分类的函数只有一个(对应的几何解释就是两个类之间最大间隔的最大间隔超平面只有一个)，那么接下来的目标就是定义这个最佳的超平面。\r\n\r\n而且我们也看出了，只有将正负样本的`yi`设置为异号时，`fw,r(x)yi`才能保证大于0，当然，也可以将正样本定义为-1，负样本定义为1，这样上述表达式的不等式就应该是小于0，很明显，这样的定义有点反人类。\r\n\r\n继续回到上述表达式(不等式)。该表达式表示了这个模型可以对所有的训练样本(训练集样本定义如下图所示)进行正确的分类：\r\n\r\n![](/images/article/svm10.png)\r\n\r\n由于如下开集约束条件在数学上难以处理：\r\n\r\n![](/images/article/svm11.png)\r\n\r\n而利用参数w和r可以任意取值的性质，可以将其变换为闭集约束条件：\r\n\r\n![](/images/article/svm12.png)\r\n\r\n`fw,r(x)yi \u003e 0`与`fw,r(x)yi \u003e 1`的意义是一样的。即：**满足该条件的样本是可以被正确二分类的**。我们也可以换一种说法，即：**当存在满足这样的条件的(w, r)时，就可以称这样的训练样本为线性可分的样本**。\r\n\r\n对于线性可分的训练样本，可以将所有的**训练样本**都正确分类的解(超平面或决策边界)有无数个。我们的目标就是找到唯一的最佳超平面，这样才能让我们的模型在测试样本上同样具备良好的鲁棒性。\r\n\r\n事实上，我们要做的就是**使得训练集样本数据点最接近决策边界的数据点到决策边界的距离(或间隔)最大**，这是我们的终极目标。这句话有两层含义：\r\n\r\n+ 训练集样本数据点最接近决策边界的数据点；\r\n+ 该数据点(训练集样本数据点最接近决策边界的数据点)到决策边界的距离最大。\r\n\r\n首先看第一层含义，**训练集样本数据点最接近决策边界的数据点**，这不就是求训练集样本到超平面的距离的最小值吗？即，我们如下定义点到超平面的距离(就是点到直线的距离公式在高维空间的推广)：\r\n\r\n![](/images/article/svm13.png)\r\n\r\n那么训练集样本到超平面的距离的最小值就可以定义为：\r\n\r\n![](/images/article/svm14.png)\r\n\r\n由于上式分子大于等于1，那么就等同于\r\n\r\n![](/images/article/svm15.png)\r\n\r\n这样，我们就定义了训练集样本数据点最接近决策边界的数据点。\r\n\r\n接下来看第二层含义，**该数据点(训练集样本数据点最接近决策边界的数据点)到决策边界的距离最大**，也就意味着将上式最大化，即\r\n\r\n![](/images/article/svm16.png)\r\n\r\n由于距离必然是正数，那么也就是说上式的图像就是一个定义域为`(0, +∞)`的反比例函数，让反比例函数值最大，也就意味着距离最小，即\r\n\r\n![](/images/article/svm17.png)\r\n\r\n如果距离的平方最小，那么距离必然最小，即上式等价于\r\n\r\n![](/images/article/svm18.png)\r\n\r\n这样的话，通过上述条件，我们就找到了最佳超平面，但是别忘了，上述条件我们是在训练集样本是线性可分的条件下推导的(因为我们上面定义了在满足`fw,r(x)yi \u003e 1`的条件时，我们就说**当存在这样的条件的(w, y)时，这样的训练集样本为线性可分的样本**，然后我们才在此基础之上推导的)，也就是说上述条件的约束条件就是训练集样本线性可分，即\r\n\r\n![](/images/article/svm19.png)\r\n\r\n上述公式即为**使得训练集样本数据点最接近决策边界的数据点到决策边界的距离(或间隔)最大所对应的分类器**，称之为**硬间隔支持向量机**。公式的含义就是在条件`fw,r(x)yi \u003e 1`的约束下或存在这样的条件的(w, y)时训练集样本线性可分的约束下硬间隔支持向量机(或训练集样本数据点最接近决策边界的数据点到决策边界的距离(或间隔)最大所对应的分类器)的决策边界。\r\n\r\n### 2.2 硬间隔支持向量的纯数学定义\r\n\r\n假设给定一个特征空间上的训练数据集为\r\n\r\n![](/images/article/svm20.png)\r\n\r\n其中\r\n\r\n![](/images/article/svm21.png)\r\n\r\n`xi`为第i个特征向量，`yi`为当前特征向量所代表的数据点的类标记，当类标记为+1时，表示正样本，为-1时表示负样本。还要假设数据集是线性可分的。\r\n\r\n我们如下定义支持向量机的**函数间隔**：\r\n\r\n![](/images/article/svm22.png)\r\n\r\n其中`ri`为数据点到决策边界的距离，为什么这么定义呢？将数据点`n`维特征向量带入决策边界表达式`w * xi + b`中，由于该表达式定义了一个`n - 1`维超平面，如果超平面上的`n - 2`维数据点(就是`n`维特征空间生成的数据点，在高维空间中也是一个超平面)在该超平面上，那么决策边界表达式`w * xi + b`的值必然为0。相反的，如果`n`维特征空间生成的数据点不在该决策边界上，那么表达式`w * xi + b`的值必然不为0，这种情况下，表达式`w * xi + b`代表的是穿过该样本的n维特征空间生成的数据点(也算是一个超平面)在与n-1维决策边界(最佳超平面)间的间隔(函数间隔)。由于`|w * xi + b|`可以`相对`表示数据点与决策边界的远程度(因为`|w * xi + b|`的值越接近于0越说明该数据点越接近决策边界，反之就越远离决策边界)，所以可以通过上述公式度量数据点与决策边界的间隔(函数间隔)。而`yi`表示距离的正负，其实不应该这么说(距离不为负)，`yi`取值为`+1`或`-1`，表示的是正样本或负样本到决策边界的距离，即正负号只是指明了样本的正负，真正的距离通过表达式`w * xi + b`的值来度量。\r\n\r\n还无法理解？好吧，我们考虑由两个特征值构成的特征空间，那么决策边界就是一条一维的直线，同样的，两个特征值构成的数据点(类别)就是一个点，是0维，如果决策边界的表达式如下\r\n\r\n![](/images/article/svm23.png)\r\n\r\n那么，如果一个数据点在该直线上，那么必然满足\r\n\r\n![](/images/article/svm24.png)\r\n\r\n相反，如果一个数据点满足如下关系\r\n\r\n![](/images/article/svm25.png)\r\n\r\n那么就说明该数据点位于决策边界的右下方，即可以分类为正样本。而如果一个数据点满足如下关系式\r\n\r\n![](/images/article/svm26.png)\r\n\r\n那么说明该数据点一定位于决策边界的左上方，即被分类为负样本。\r\n\r\n我们不妨带入一个点(0, 0),得到的值为-4.9，那么说明由特征向量(0, 0)生成的数据点为负样本，那么相应的函数间隔就为`-1 * -4.9 = 4.9 \u003e 0`，这也就说明已经正确分类了。\r\n\r\n为了行文顺利，我们再提供一个数据点(2, 1)，得到的值为-2.5，那么说明由特征向量(2, 1)生成的数据点也是负样本，那么相应的函数间隔就为`-1 * -2.5 = 2.5 \u003e 0`，与数据点(0, 0)相比较，这个数据点与决策边界的间隔更近。这就方便我们度量最小间隔。\r\n\r\n函数间隔数学形式简洁，但是存在不可避免的问题，即：w和b被同时缩小或放大M倍后，超平面并没有变化，但是函数间隔却变化了。所以，需要将w的大小固定，从而使得函数间隔固定，那么此时的间隔也就是几何间隔。\r\n\r\n支持向量机的**几何间隔**定义如下：\r\n\r\n![](/images/article/svm27.png)\r\n\r\n事实上，几何间隔就是点到超平面的距离。那么超平面关于所有样本点的几何间隔的最小值就定义为\r\n\r\n![](/images/article/svm28.png)\r\n\r\n那么这个距离就是所谓的支持向量到决策边界的距离。\r\n\r\n那么根据以上定义，支持向量机的求解最大分割超平面问题可以表示为如下约束最优化问题\r\n\r\n![](/images/article/svm29.png)\r\n\r\n将约束条件两边同除以r，那么就得到\r\n\r\n![](/images/article/svm30.png)\r\n\r\n由于`||w||`与`r`都是标量，所以可以通过如下方式简化约束条件\r\n\r\n![](/images/article/svm31.png)\r\n\r\n那么简化后的约束条件为\r\n\r\n![](/images/article/svm32.png)\r\n\r\n又因为最大化`r`，就等于最大化最小间隔`1 / ||w||`，同理，由于`1 / ||w||`为自变量为`(0, +∞)`的反比例函数，让反比例函数值最大，也就意味着`||w||`最小，如果`(||w||)^2`的值最小，那么`||w||`的值自然最小。\r\n\r\n那么，支持向量机模型的求解最大分割超平面问题又可以表示为如下约束最优化问题：\r\n\r\n![](/images/article/svm33.png)\r\n\r\n## 三、软间隔支持向量\r\n\r\n硬间隔支持向量机要求训练样本是线性可分的，但是实际应用中并不是很常见。软间隔支持向量机的基本思路是：允许在间隔的计算中出现少许的误差，误差定义为\r\n\r\n![](/images/article/svm34.png)\r\n\r\n而在误差出现的情况下的**软间隔支持向量机**定义为：\r\n\r\n![](/images/article/svm35.png)\r\n\r\n上式中，C \u003e 0是用来控制间隔误差的调谐参数。间隔误差在优化中也称为松弛变量。C越大，间隔误差越接近于0，即\r\n\r\n![](/images/article/svm36.png)\r\n\r\n那么软间隔支持向量机越接近于硬间隔支持向量机，即\r\n\r\n![](/images/article/svm37.png)\r\n\r\n## 四、使用核技巧处理非线性问题\r\n\r\n硬间隔支持向量要所有的样本都是线性可分的，软间隔支持向量允许间隔计算中出现少许的误差，但二者的基础都是由n维特征空间定义的数据点都是线性可分的，只是程度不同。\r\n\r\n但是并非n维特征向量定义的数据点一定线性可分，比如\r\n\r\n![](/images/article/svm38.png)\r\n\r\n明显无法线性分离，支持向量机通过使用一种被称为“核技巧”的处理方式就可以将问题映射到一个更高维度的空间中，比如上图我们根据之前的特征定义第三个维度(特征)为`z = x ^ 2 + y ^ 2`，那么就会如下图所示\r\n\r\n![](/images/article/svm39.png)\r\n\r\n这样就又线性可分了。\r\n\r\n具有非线性核的支持向量机通过对数据添加额外的维度，就可以实现线性可分。**本质上讲，核技巧就是添加能够表述度量特征之间数学关系的新特征的过程**。常用的核函数如下:\r\n\r\n+ 线性核函数(linear kernel)：该核函数不需要转换数据，因此可以表示为特征的点积：\r\n\r\n![](/images/article/svm40.png)\r\n\r\n+ 次数为d的多项式核函数(polynomial kernel)：该核函数添加了一个简单的非线性数据变换：\r\n\r\n![](/images/article/svm41.png)\r\n\r\n+ S形核函数(sigmoid kernel)：该核函数产生的支持向量机模型，类似于神经网络使用S形激活函数，使用希腊字母kappa和delta作为核参数：\r\n\r\n![](/images/article/svm42.png)\r\n\r\n+ 高斯RBF核函数(Gaussian RBF kernel)：该核函数类似于RBF神经网络，且对于许多类型的数据都运行的很好，而且被认为是用于许多学习任务的一个合理的开始：\r\n\r\n![](/images/article/svm43.png)\r\n\r\n需要注意的是，对于特定的任务，没有可以依赖的规则用于匹配核函数。在很大程度上拟合取决于要学习的概念以及训练数据的量与特征之间的关系。在许多情况下，一个良好的支持向量机模型可能需要在评估多个核函数的情况下产生。\r\n\r\n## 五、R语言中支持向量机函数及应用\r\n\r\n### 5.1 R语言中支持向量机函数\r\n\r\n使用kernlab添加包的`ksvm()`函数来使用支持向量机，函数原型为\r\n\r\n先创建模型\r\n\r\n```\r\nm \u003c- ksvm(target ~ predictors, data = mydata, kernel = \"rbfdot\", c = 1)\r\n```\r\n\r\n参数解释如下\r\n\r\n+ target：数据框mydata需要建模的输出变量；\r\n+ predictors：要预测的输出变量关于mydata数据框中的特征集；\r\n+ data：训练集数据框；\r\n+ kernel：核函数，包括rbfdot(径向基函数)、polydot(多项式函数)、tanhdot(双曲正切函数)、vanilladot(线性函数)等；\r\n+ c：用于给出违反约束条件时的惩罚，即对于**软边界**的惩罚的大小。较大的c值将导致较窄的边界。\r\n\r\n该函数返回一个可用于预测的支持向量机对象。\r\n\r\n再进行预测\r\n\r\n```\r\np \u003c- predict(m, test, type = \"response\")\r\n```\r\n\r\n参数解释如下\r\n\r\n+ m：由`ksvm()`函数得到的SVM对象；\r\n+ test：测试集数据框；\r\n+ type：当值为response时表明输出为预测类别，当值为probabilities时，表明输出为对应的预测概率。\r\n\r\n该函数根据type参数返回预测类或者预测类概率。\r\n\r\n### 5.2 R语言中支持向量机函数应用\r\n\r\n以光学字符识别案例为例，说明该函数的使用。\r\n\r\n```\r\n\u003e getwd()\r\n[1] \"C:/Users/Administrator/Documents\"\r\n\u003e setwd(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\docs\\\\Machine-Learning-with-R-datasets-master\")\r\n\u003e letters \u003c- read.csv(\"letterdata.csv\")\r\n\u003e str(letters)\r\n'data.frame':\t20000 obs. of  17 variables:\r\n $ letter: Factor w/ 26 levels \"A\",\"B\",\"C\",\"D\",..: 20 9 4 14 7 19 2 1 10 13 ...\r\n $ xbox  : int  2 5 4 7 2 4 4 1 2 11 ...\r\n $ ybox  : int  8 12 11 11 1 11 2 1 2 15 ...\r\n $ width : int  3 3 6 6 3 5 5 3 4 13 ...\r\n $ height: int  5 7 8 6 1 8 4 2 4 9 ...\r\n $ onpix : int  1 2 6 3 1 3 4 1 2 7 ...\r\n $ xbar  : int  8 10 10 5 8 8 8 8 10 13 ...\r\n $ ybar  : int  13 5 6 9 6 8 7 2 6 2 ...\r\n $ x2bar : int  0 5 2 4 6 6 6 2 2 6 ...\r\n $ y2bar : int  6 4 6 6 6 9 6 2 6 2 ...\r\n $ xybar : int  6 13 10 4 6 5 7 8 12 12 ...\r\n $ x2ybar: int  10 3 3 4 5 6 6 2 4 1 ...\r\n $ xy2bar: int  8 9 7 10 9 6 6 8 8 9 ...\r\n $ xedge : int  0 2 3 6 1 0 2 1 1 8 ...\r\n $ xedgey: int  8 8 7 10 7 8 8 6 6 1 ...\r\n $ yedge : int  0 4 3 2 5 9 7 2 1 1 ...\r\n $ yedgex: int  8 10 9 8 10 7 10 7 7 8 ...\r\n\u003e letters_train \u003c- letters[1 : 16000, ]\r\n\u003e letters_test \u003c- letters[16001 : 20000, ]\r\n\u003e library(kernlab)\r\n\u003e letters_model \u003c- ksvm(letter ~ ., data = letters_train, kernel = \"vanilladot\")\r\n Setting default kernel parameters  \r\n```\r\n\r\n可以通过键入SVM模型名称查看关于训练参数和模型拟合度的一些基本信息，如下\r\n\r\n```\r\n\u003e letters_model\r\nSupport Vector Machine object of class \"ksvm\" \r\n\r\nSV type: C-svc  (classification) \r\n parameter : cost C = 1 \r\n\r\nLinear (vanilla) kernel function. \r\n\r\nNumber of Support Vectors : 7037 \r\n\r\nObjective Function Value : -14.1746 -20.0072 -23.5628 -6.2009 -7.5524 -32.7694 -49.9786 -18.1824 -62.1111 -32.7284 -16.2209 ...\r\nTraining error : 0.130062 \r\n```\r\n\r\n可以看出支持向量的类型为分类任务，且惩罚因子C为1，共有7037个支持向量。\r\n\r\n然后进行预测并评估模型性能\r\n\r\n```\r\n\u003e letters_pre \u003c- predict(letters_model, letters_test)\r\n\u003e prop.table(table(letters_pre == letters_test$letter))\r\n\r\n  FALSE    TRUE \r\n0.16075 0.83925 \r\n```\r\n\r\n正确率大概为84%，还是不错的。再试着提升一下模型性能。\r\n\r\n### 5.3 提升模型性能\r\n\r\n提升模型性能主要是通过更换核函数来实现，我们分别试一下常见的核函数，如下\r\n\r\n```\r\n\u003e letters_model \u003c- ksvm(letter ~ ., data = letters_train, kernel = \"rbfdot\")\r\n\u003e letters_pre \u003c- predict(letters_model, letters_test)\r\n\u003e prop.table(table(letters_pre == letters_test$letter))\r\n\r\n FALSE   TRUE \r\n0.0695 0.9305 \r\n\u003e letters_model \u003c- ksvm(letter ~ ., data = letters_train, kernel = \"polydot\")\r\n Setting default kernel parameters  \r\n\u003e letters_pre \u003c- predict(letters_model, letters_test)\r\n\u003e prop.table(table(letters_pre == letters_test$letter))\r\n\r\n  FALSE    TRUE \r\n0.16075 0.83925 \r\n\u003e letters_model \u003c- ksvm(letter ~ ., data = letters_train, kernel = \"tanhdot\")\r\n Setting default kernel parameters  \r\n\u003e letters_pre \u003c- predict(letters_model, letters_test)\r\n\u003e prop.table(table(letters_pre == letters_test$letter))\r\n\r\n FALSE   TRUE \r\n0.9155 0.0845 \r\n```\r\n\r\n可见，当核函数为径向基函数时性能最好，相反，当核函数为双曲正切函数时性能最差。\r\n\r\n全文完！\r\n\r\n###### 参考文献\r\n\r\n1. Introduction to statistical machine learning.\r\n2. Machine Learning With R.\r\n3. https://www.analyticsvidhya.com/blog/2017/09/understaing-support-vector-machine-example-code/","cover":"/images/svm.jpg","link":"support-vector-machine.html","preview":"\u003cp\u003e支持向量机基于间隔最大化原理，以严格的数学理论为基础，以寻找特征空间最优超平面为目标，以内积的回旋巧妙地构造核函数，适用于数值预测以及分类任务。\u003c/p\u003e\n","title":"转导推理——支持向量机"},{"content":"\r\n\r\n## 一、从生物神经网络到人工神经网络\r\n如同人脑使用一个被称为神经元的相互连接的细胞网络来创建一个巨大的并行处理器一样，人工神经网络使用人工神经元或节点的网络来解决学习问题。既然，人工神经网络基于生物神经网络，那么有必要了解一下生物神经细胞或神经元的组成。\r\n\r\n### 1.1 生物神经网络\r\n\r\n![神经元结构图](/images/article/shenjingyuan.jpg)\r\n\r\n如上图所示，每个神经元由包含一个细胞核的一个细胞体组成。从细胞体分支扩展出许多被称为**树突**的神经纤维和一根长的称为**轴突**的神经纤维。其中，树突接受神经冲动作为神经元的输入信号，但神经元并非对所有的神经冲动进行处理，而是在神经冲动信号达到一个阈值后才会处理并将输出信号通过轴突传递给下层神经元。**突触**则是神经元的连接，与轴突相区分，突触包含以下三种：\r\n\r\n+ 轴突-树突突触：一个神经元的轴突与下一个神经元的树突相连；\r\n+ 轴突-胞体突触：一个神经元的轴突与下一个神经元的胞体相连；\r\n+ 轴突-轴突突触：一个神经元的轴突与下一个神经元的轴突相连；\r\n\r\n![突触示意图](/images/article/tuchu.jpg)\r\n\r\n神经元对神经信号的处理是有条件的，即必须达到一个阈值。如何判断呢？答案是通过神经冲动相对重要性或频率的加权和。如果加权和达到该阈值，那么神经元将会处理(激活)该神经信号，否则不予理会。事实上，每个神经元都是这么干的。那么直观上，神经元的功能就是**求和**与**激活**。\r\n\r\n### 1.2 人工神经网络\r\n人工神经网络作为生物神经网络的仿真，那么将概念迁移过来，首先图示如下\r\n\r\n![神经元对比示意图](/images/article/artificial-neural.png)\r\n\r\n可以看出，一个有向网络图定义了神经元对输入信号(变量X)的接收，每个特征对应一个输入，每个输入连向神经元的有向线段上表明了该信号的权重，那么众多输入信号在每个神经元处首先被加权求和，然后将加权和结果作为神经元激活函数的自变量就可以得到该神经元的输出，该输出将会作为下一个神经元的输入，下一个神经元仍然会进行同样的加权求和和激活操作。\r\n\r\n一个典型的具有n个输入树突的神经元可以用如下公式来表示\r\n\r\n![具备n个输入的神经元](/images/article/sum-function.png)\r\n\r\n其中，权重w可以控制n个输入(x)中的每个输入对输入信号之和所做出贡献的大小。激活函数f(x)使用净总和，结果信号y(x)就是输出轴突。\r\n\r\n### 1.3 神经网络的三个特征\r\n定义一个人工神经网络，需要具备三个概念，如下\r\n\r\n+ **激活函数**：将神经元的净输入(加权和)信号转化为单一的输出信号，以便进一步在网络中传播；\r\n+ **网络拓扑**：描述神经网络中神经元的数目及层数以及它们之间的连接方式；\r\n+ **训练算法**：指定如何设置连接权重，以便抑制或者增加神经元在输入信号中的比重。\r\n\r\n它们之间的关系为，**网络拓扑**由一层层神经元组成，每层包含若干个神经元，这些(不同层)神经元组成了人工神经网络的基本骨架；其中每个神经元都会进行加权求和与激活操作，实质上就是每个神经元通过自己的**激活函数**将净输入转化为输出(如上面的公式所示)，以便进一步传播。而**训练算法**则是对神经网络的调整，即通过后向传播算法进行神经元权重的修正。\r\n\r\n## 二、激活函数\r\n激活函数是神经元处理信号的一个过程，涉及对总的输入信号进行求和，然后确定加权和是否满足阈值，如果满足，就产生输出，否则不进行任何操作。\r\n\r\n这里只介绍带0/1输出的硬阈值激活函数(图a)和logistic激活函数(图b)，图像如下\r\n\r\n![激活函数](/images/article/active-function.png)\r\n\r\n### 2.1 带0/1输出的硬阈值激活函数\r\n带0/1输出的硬阈值激活函数只适合问题线性可分的情况，即训练集属性组成的n维空间可以被n-1维超平面二分类。我们以训练集只有两个输入的样本为例，试说明带0/1输出的硬阈值激活函数的实际情况\r\n\r\n下图显示了两个输入x1(横轴)和x2(纵轴)，分别代表了地震的深层和表层的震级\r\n\r\n![地震与地下爆炸](/images/article/geogebra-export.png)\r\n\r\n其中，红点代表核爆，蓝点代表真正的地震，我们可以看出，如果我们对属性x1-x2进行线性回归，那么我们会得到一条直线，直线上下方分别是分类的结果，上方为地震，下方为核爆，我们先求直线的方程式，如下\r\n\r\n![直线方程](/images/article/fangchengshi.png)\r\n\r\n那么也就是说如果直线方程求解大于0那么就属于核爆，如果小于0就属于地震。我们观察一下直线方程，可以看出1.7是变量x1的系数，也可以说是x1的**权重**，同理，-1则是x2的**权重**，而截距-4.9我们称之为**偏置**。\r\n\r\n那么我们就可以这样定义上面的方程式\r\n\r\n![直线方程转带权求和形式](/images/article/sum.png)\r\n\r\n那么就成了，如果X大于0那么就是核爆，如果小于0就是地震，明显是个二分类问题，不妨用1代表核爆，用0代表地震，那么就有如下关系式\r\n\r\n![带0/1输出的硬阈值激活函数表达式](/images/article/0-1.png)\r\n\r\n上述关系式正是带0/1输出的硬阈值激活函数的表达式。\r\n\r\n到这里我们可以看出，激活函数实际上屏蔽了线性回归求权重与偏置的过程。由于神经网络伊始不包含先验知识，所以刚开始随机设置权重(而不是像我们一样通过拟合方程求权重)，然后将最终的输出信号与训练集的真实目标值进行比较，如果不同，则通过后向传播算法通过梯度下降修正权重，最终得到合理的输出结果(即与训练集目标值的误差最小)。\r\n\r\n但是实际应用当中，很少使用带0/1输出的硬阈值激活函数，因为该激活函数在X = 0处是不可微的，而且在X != 0处导数处处为0，这就导致无法在后向传播中通过梯度下降来修正权重。对于这样的分类器而言，模型的调整(权重的修正)总是会受该激活函数输出值的两个极端(0或者1)的影响,而且模型的调整(几何上就是那条一刀切的直线的调整，对应的就是权重的修正)显得困难重重而低效。而且对于线性不可分的问题无能为力，因为无法一刀切！\r\n\r\n那么我们就需要找一个可微的激活函数，这样，在后向传播中就可以充分利用梯度下降算法来修正神经元权重。\r\n\r\n### 2.2 logistic激活函数\r\n该激活函数的图像如上图所示，可以看出，该激活函数是可微的，这样对于创建高效的人工神经网络优化算法是至关重要的。与带0/1输出的硬阈值激活函数比较，区别主要在\r\n\r\n+ 带0/1输出的硬阈值激活函数的输出是二分类，不是0就是1；但是logistic激活函数输出的则是0或1的概率；\r\n+ 带0/1输出的硬阈值激活函数是不可微的，只适合处理线性可分问题；但是logistic激活函数是可微的，可以通过梯度下降来修正神经元权重，这样模型的调整非常高效。\r\n\r\nlogistic激活函数对于线性可分的情况，回归收敛速度较慢但表现得更加可预期；对于数据含噪音，且非线性可分的情况，logistic激活函数回归收敛速度明显更快且更稳定。\r\n\r\n## 三、网络拓扑\r\n### 3.1 层的数目\r\n单层网络只有一组连接权重，适用于基本的模式分类，特别适用于线性可分的问题；\r\n\r\n多层网络添加了一个或者多个隐藏层，它们(隐藏层)在信号到达输出节点之前处理来自节点的信号。\r\n\r\n### 3.2 信息传播方向\r\n\r\n![前馈网络](/images/article/qiankuiwangluo.jpg)\r\n\r\n前馈网络：神经网络中的信号在一个方向上从一个节点到另一个节点连续的传送，直至到达输出层；\r\n\r\n![递归网络](/images/article/diguiwangluo.gif)\r\n\r\n递归网络：允许信号使用循环在两个方向上传播；\r\n\r\n![多层前馈网络](/images/article/duocengwangluo.jpg)\r\n\r\n多层前馈网络：或称为多层感知器，有一个输入层，中间有一个或多个隐含层，有一个输出层，是人工神经网络拓扑结构中的事实标准。\r\n\r\n### 3.3 每一层节点数\r\n输入节点的个数由训练集数据的特征数量而定。而输出节点的个数由结果中分类水平数目而定，但是隐藏层节点的个数确定起来则没有这么容易，要根据输入节点的个数、训练数据的数量、噪声数据的数量，以及许多其他因素的影响而定。\r\n\r\n需要注意的是，过多的隐藏层神经元有理由训练出更严格的模型，但也可能会有过度拟合的风险。一般情况下，至少有一个多神经元隐藏层。\r\n\r\n## 四、训练算法(梯度下降与后向传播)\r\n\r\n### 4.1 后向传播算法\r\n该算法通过两个过程的多次循环进行迭代，每次迭代称为一个**新纪元**。由于初始的神经网络里面不包含先验知识，所以在开始之前先随机设定网络拓扑中每个输入的权重，然后算法通过过程循环，直到达到一个停止准则。该循环过程包括：\r\n\r\n+ 在前向阶段中，神经元在输入层到输出层的序列中被激活，沿途应用每一个神经元的权重和激活函数，一旦到达最后一层，就产生一个输出信号。\r\n+ 在后向阶段中，由前向阶段产生的网络输出信号与训练数据中的真实目标值进行比较，网络的输出信号与真实目标值之间的差异产生的误差在网络中向后传播，从而来修正神经元之间的连接权重，从而减少神经网络最终输出值与训练集数据目标值的误差。\r\n\r\n但是，每个神经元的输入与输出之间的关系很复杂，我们又如何确定神经元的权重该改变多少呢？\r\n\r\n答案是通过**梯度下降算法**来实现。\r\n\r\n### 4.2 梯度下降算法\r\n首先看一下什么是梯度下降算法。\r\n\r\n### 4.2.1 一个例子\r\n首先我们有一个可微的函数，假设这个函数代表一座山，一个人因为大雾被困在山顶，由于山上浓雾很大，他想下山应该怎么做？注意，由于大雾的影响他只能看见较近的地方，这样他每次只能走最陡峭的地方，因为下降的幅度更大，更容易接近山底(虽然现实当中很危险，但是这里是在解释算法，不必较真)，他每走一步都选择最陡峭的地方走，这样就会很快下山。\r\n\r\n![慢慢就会走到山底](/images/article/valley.png)\r\n\r\n这座山的前提是一个可微函数，那么最陡峭也就意味着斜率最大，由于是下山，那么斜率必然是负数，那么就可以用如下数学形式定义这个人的下次落脚点\r\n\r\n![下一步的位置](/images/article/luojiaodian.png)\r\n\r\n其中Θ1表示下一次的位置，Θ0表明本次的位置，α表示步长，最后一个参数表示我们山的陡峭程度，如果我们的山越陡峭，同时这个人的步长α越大，那么他走的肯定很快，但是同样的，他有可能会错过最佳的山底位置，因为他看不到。如果步长小，那么他会走的慢一点，这样他就不会错过最佳的山底位置。\r\n\r\n以上是梯度下降法在下山上的应用，你只需要记住一点，就是**步长(学习率)的大小决定了下山的快慢以及与目标的接近程度**。\r\n\r\n我们回过头来再看梯度下降法的数学定义。\r\n\r\n梯度实际上就是多变量微分的一般化，即对每个变量分别微分，然后组合在一起，形成一个向量，那么必然的有以下结论：\r\n\r\n+ **在单变量函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率，即变化率**；\r\n+ **在多变量函数中，梯度是一个向量，梯度的方向就指出了函数在给定点的上升(或下降，因符号而异)最快的方向**。\r\n\r\n### 4.2.2 单变量函数梯度\r\n那么在单变量情况下，我们求一下单变量函数的梯度下降，假定我们有如下单变量函数\r\n\r\n![单变量函数](/images/article/danbianliangtidu.png)\r\n\r\n初始化起点θ0 = 1，学习率α = 0.4，然后进行梯度下降计算\r\n\r\n![计算单变量梯度](/images/article/tidudanbianliang.png)\r\n\r\n如果这个人登山的函数就是这个单变量函数的话，那么也就意味着他只需要四次就可以下山(到达函数最低点)\r\n\r\n![单变量梯度下降](/images/article/jieguotidu.png)\r\n\r\n### 4.2.3 多变量函数梯度\r\n现假设有如下多变量函数\r\n\r\n![多变量函数](/images/article/duobianliangtidu.png)\r\n\r\n初始化起点与步长Θ0 = (1,3)，α = 0.1，该多变量函数梯度如下\r\n\r\n![多变量函数梯度](/images/article/tidu.png)\r\n\r\n然后进行梯度下降计算\r\n\r\n![计算多变量梯度](/images/article/duobianliangtidujisuan.png)\r\n\r\n然后，随着梯度下降，我们发现，实际上已经慢慢的到达了多变量函数的最小值点\r\n\r\n![多变量梯度下降](/images/article/resultduobianliang.png)\r\n\r\n### 4.2.4 回到后向传播算法\r\n上述通过对激活函数的阐述，我们可以知道，影响神经网络输出值与训练集目标值之间误差大小的参数就是各神经元的权重以及偏置，若各神经元权重与偏置构成的多变量成本函数**J(w, b)**越大，最终神经网络输出值与训练集目标值之间的误差越大，那么相应的，我们如果求多变量成本函数**J(w, b)**最小值，那么也就意味着神经网络输出值与训练集目标值之间的误差越小。\r\n\r\n![成本函数最小值](/images/article/chengbenhanshu.png)\r\n\r\n所以，在后向传播算法的后向阶段，我们修正神经元的核心技术就是通过梯度下降算法最小化我们的成本函数**J(w, b)**,对应的就是求由w、b以及目标成本函数J(w, b)间关系构成的二次曲面的最低点，也就是成本函数的最小值。\r\n\r\n那么运用梯度下降，以此来修正神经元权重与偏置\r\n\r\n![梯度下降](/images/article/luojiaodian.png)\r\n\r\n事实上，在后向传播中与学习率α(步长)相乘的成本函数的梯度就是总误差对相邻节点(神经元)权重的导数，这里需要通过链式求导来计算，因为神经网络输出的神经元还进行了一次求加权和的操作，然后将此加权和作为当前节点(或神经元)的激活函数的输入最终产生输出。\r\n\r\n### 4.3 通过梯度下降法更新神经元权重\r\n\r\n我们考虑一个全新的例子，这里基本上将会综合上述所有内容。假定有如下神经网络拓扑\r\n\r\n![神经网络拓扑](/images/article/example0.png)\r\n\r\n我们给输入赋初值，并加上权重以及偏置，并对输出再赋值以进行比较确定误差\r\n\r\n![带权重、偏置与初值的神经网络拓扑](/images/article/neural_network-9.png)\r\n\r\n接下来**前向传播**\r\n\r\n计算h1神经元的输入加权和以及以logistic作为激活函数的输出\r\n\r\n![h1神经元加权和](/images/article/example1.png)\r\n\r\n![h1神经元激活函数输出](/images/article/example2.png)\r\n\r\n同样的方法计算h2神经元的激活函数输出\r\n\r\n![h2神经元激活函数输出](/images/article/example3.png)\r\n\r\n同样的方法再计算o1和o2的激活函数输出\r\n\r\n![o1加权和与激活函数输出](/images/article/example4.png)\r\n\r\n![o2激活函数输出](/images/article/example5.png)\r\n\r\n前向传播中我们得到的目标输入为[0.75136079 , 0.772928465]，但是训练集目标值为[0.01 , 0.99]，可见误差还很大。接下来，我们通过后向传播来训练神经网络，修正神经元权重，降低误差\r\n\r\n\r\n接下来就是**后向传播**并通过梯度下降法修正权重，其中成本函数的梯度就是总误差对某神经元链式求导。首先计算它们的总误差，公式为\r\n\r\n![o2激活函数输出](/images/article/latex.png)\r\n\r\n先分别计算o1与o2对应训练集目标值的误差，然后加总\r\n\r\n![o1相对于训练集目标值误差](/images/article/latex (1).png)\r\n\r\n![o2相对于训练集目标值误差](/images/article/latex (2).png)\r\n\r\n![总误差](/images/article/latex (3).png)\r\n\r\n先求成本函数的梯度，即总误差关于神经元h1上权重w5的导数，这是一个链式求导的过程，如下图所示\r\n\r\n![链式求导](/images/article/output_1_backprop-4.png)\r\n\r\n开始求导，分别求各部分\r\n\r\n![第一部分](/images/article/example6.png)\r\n\r\n![第二部分](/images/article/examle7.png)\r\n\r\n![第三部分](/images/article/example8.png)\r\n\r\n然后各部分相乘\r\n\r\n![三部分相乘](/images/article/example9.png)\r\n\r\n然后我们就可以更新权重w5的值了，如下\r\n\r\n![更新w5权重](/images/article/latex (4).png)\r\n\r\n类似的方式我们可以更新其余权重，如下\r\n\r\n![更新其余权重](/images/article/example10.png)\r\n\r\n以上是与总误差最关联的输出层的权重更新，对于隐含层而言，更新权重示意图及公式如下\r\n\r\n![更新隐藏层神经元权重示意图](/images/article/nn-calculation.png)\r\n\r\n可见链式传导路径为`out(h1) ——\u003e net(h1) ——\u003e w1`, 在前向传播中out(h1)会影响out(o1)和out(o2), 那么对应的在后向传播中计算E(total)关于out(h1)的导数必然要考虑out(h1)它对两个输出神经元的影响，那么E(total)关于out(h1)的导数如下计算\r\n\r\n![E(total)关于out(h1)的导数计算方式](/images/article/latex (5).png)\r\n\r\n下面开始梯度下降更新w1的权重\r\n\r\n![](/images/article/latex (6).png)\r\n\r\n![](/images/article/latex (7).png)\r\n\r\n![](/images/article/latex (8).png)\r\n\r\n![](/images/article/latex (9).png)\r\n\r\n![](/images/article/latex (10).png)\r\n\r\n以上计算出了E(o1)关于out(h1)的导数，下面用同样的方式计算E(o2)关于out(h1)的导数，过程略\r\n\r\n![](/images/article/latex (11).png)\r\n\r\n根据公式，二者相加，得到E(total)关于out(h1)的导数\r\n\r\n![](/images/article/latex (12).png)\r\n\r\n下面就简单了，计算out(h1)关于net(h1)的导数\r\n\r\n![](/images/article/latex (13).png)\r\n\r\n![](/images/article/latex (14).png)\r\n\r\n然后再计算net(h1)关于w1的导数，如下\r\n\r\n![](/images/article/latex (15).png)\r\n\r\n![](/images/article/latex (16).png)\r\n\r\n最终三者相乘链式求导得到E(total)关于w1的导数\r\n\r\n![](/images/article/latex (17).png)\r\n\r\n![](/images/article/latex (18).png)\r\n\r\n然后就可以根据梯度下降公式更新w1的权重\r\n\r\n![](/images/article/latex (19).png)\r\n\r\n同样的方式更新w2、w3、w4的权重，如下，过程略\r\n\r\n![](/images/article/latex (20).png)\r\n\r\n![](/images/article/latex (21).png)\r\n\r\n![](/images/article/latex (22).png)\r\n\r\n这样，我们就梯度不断下降，最终已经找到了多变量成本函数**J(w, b)**的最小值，那么也就意味着神经网络输出节点与训练集目标值之间的误差已经最小了。\r\n\r\n我们再次通过训练后的神经网络重新计算，输出节点得到的值为[0.015912196,0.984065734]，而训练集目标值为[0.01 , 0.99], 可见，误差已经相当低了。\r\n\r\n## 五、R语言中神经网络实现与应用\r\n### 5.1 R语言中神经网络函数用法\r\n我们使用neuralnet添加包中的`neuralnet()`函数来实现神经网络，函数原型为\r\n\r\n首先建立模型\r\n```\r\nm \u003c- neuralnet(target ~ predictors, data = mydata, hidden = 1)\r\n```\r\n参数解释如下\r\n\r\n+ target：数据框mydata中需要建模的输出变量；\r\n+ predictors：是数据框mydata中用于预测的特征集(是一个公式)；\r\n+ data：训练集数据框；\r\n+ hidden：神经网络隐藏层神经元数目，默认为1。\r\n\r\n该函数返回一个神经网络模型对象\r\n\r\n然后进行预测\r\n```\r\np \u003c- compute(m, test)\r\n```\r\n\r\n参数解释如下\r\n\r\n+ m：`neuralnet()`函数创建的模型对象；\r\n+ test：测试集数据框。\r\n\r\n该函数返回一个二元素列表，名称分别是`$neurons`和`$net.result`，前者用于保存神经网络中每一层的神经元，后者用于保存模型的预测值。\r\n\r\n### 5.2 R语言中neuralnet()函数应用示例\r\n以《Machine Learning With R》一书中的根据混合物水分特征预测混凝土强度的数据集为例\r\n\r\n先读取数据，然后进行数据标准化操作，因为神经网络运行时最好的情况就是将输入数据缩放到0附近的狭窄范围内，我们使用离差标准化，将数据映射到[0, 1]区间，由于数据集已经是随机排列，那么直接提取训练集与测试集\r\n```\r\n\u003e getwd()\r\n[1] \"C:/Users/Administrator/Documents\"\r\n\u003e setwd(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\docs\\\\Machine-Learning-with-R-datasets-master\")\r\n\u003e concrete \u003c- read.csv(\"concrete.csv\")\r\n\u003e str(concrete)\r\n'data.frame':\t1030 obs. of  9 variables:\r\n $ cement      : num  540 540 332 332 199 ...\r\n $ slag        : num  0 0 142 142 132 ...\r\n $ ash         : num  0 0 0 0 0 0 0 0 0 0 ...\r\n $ water       : num  162 162 228 228 192 228 228 228 228 228 ...\r\n $ superplastic: num  2.5 2.5 0 0 0 0 0 0 0 0 ...\r\n $ coarseagg   : num  1040 1055 932 932 978 ...\r\n $ fineagg     : num  676 676 594 594 826 ...\r\n $ age         : int  28 28 270 365 360 90 365 28 28 28 ...\r\n $ strength    : num  80 61.9 40.3 41 44.3 ...\r\n\u003e normalize \u003c- function(x) {\r\n+     return ((x - min(x)) / (max(x) - min(x)))\r\n+ }\r\n\u003e concrete_norm \u003c- as.data.frame(lapply(concrete, normalize)) \r\n\u003e concrete_train \u003c- concrete_norm[1 : 700, ]\r\n\u003e concrete_test \u003c- concrete_norm[701 : 1030, ]\r\n```\r\n\r\n可以通过`summary()`函数查看标准前后的描述性统计量，可以发现已经成功标准化了\r\n```\r\n\u003e summary(concrete)\r\n     cement           slag            ash             water        superplastic   \r\n Min.   :102.0   Min.   :  0.0   Min.   :  0.00   Min.   :121.8   Min.   : 0.000  \r\n 1st Qu.:192.4   1st Qu.:  0.0   1st Qu.:  0.00   1st Qu.:164.9   1st Qu.: 0.000  \r\n Median :272.9   Median : 22.0   Median :  0.00   Median :185.0   Median : 6.400  \r\n Mean   :281.2   Mean   : 73.9   Mean   : 54.19   Mean   :181.6   Mean   : 6.205  \r\n 3rd Qu.:350.0   3rd Qu.:142.9   3rd Qu.:118.30   3rd Qu.:192.0   3rd Qu.:10.200  \r\n Max.   :540.0   Max.   :359.4   Max.   :200.10   Max.   :247.0   Max.   :32.200  \r\n   coarseagg         fineagg           age            strength    \r\n Min.   : 801.0   Min.   :594.0   Min.   :  1.00   Min.   : 2.33  \r\n 1st Qu.: 932.0   1st Qu.:731.0   1st Qu.:  7.00   1st Qu.:23.71  \r\n Median : 968.0   Median :779.5   Median : 28.00   Median :34.45  \r\n Mean   : 972.9   Mean   :773.6   Mean   : 45.66   Mean   :35.82  \r\n 3rd Qu.:1029.4   3rd Qu.:824.0   3rd Qu.: 56.00   3rd Qu.:46.13  \r\n Max.   :1145.0   Max.   :992.6   Max.   :365.00   Max.   :82.60  \r\n\r\n\u003e summary(concrete_norm)\r\n     cement            slag              ash             water       \r\n Min.   :0.0000   Min.   :0.00000   Min.   :0.0000   Min.   :0.0000  \r\n 1st Qu.:0.2063   1st Qu.:0.00000   1st Qu.:0.0000   1st Qu.:0.3442  \r\n Median :0.3902   Median :0.06121   Median :0.0000   Median :0.5048  \r\n Mean   :0.4091   Mean   :0.20561   Mean   :0.2708   Mean   :0.4774  \r\n 3rd Qu.:0.5662   3rd Qu.:0.39775   3rd Qu.:0.5912   3rd Qu.:0.5607  \r\n Max.   :1.0000   Max.   :1.00000   Max.   :1.0000   Max.   :1.0000  \r\n  superplastic      coarseagg         fineagg            age         \r\n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.00000  \r\n 1st Qu.:0.0000   1st Qu.:0.3808   1st Qu.:0.3436   1st Qu.:0.01648  \r\n Median :0.1988   Median :0.4855   Median :0.4654   Median :0.07418  \r\n Mean   :0.1927   Mean   :0.4998   Mean   :0.4505   Mean   :0.12270  \r\n 3rd Qu.:0.3168   3rd Qu.:0.6640   3rd Qu.:0.5770   3rd Qu.:0.15110  \r\n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.00000  \r\n    strength     \r\n Min.   :0.0000  \r\n 1st Qu.:0.2664  \r\n Median :0.4001  \r\n Mean   :0.4172  \r\n 3rd Qu.:0.5457  \r\n Max.   :1.0000 \r\n```\r\n\r\n然后建立神经网络模型，如下\r\n```\r\n\u003e library(neuralnet)\r\n\u003e concrete_model \u003c- neuralnet(strength ~ ., data = concrete_train)\r\n```\r\n可以通过`plot()`函数查看神经网络拓扑结构，如下\r\n```\r\n\u003e plot(concrete_model)\r\n```\r\n结构为\r\n\r\n![神经网络拓扑结构](/images/article/neuralnet-img.png)\r\n\r\n图中给出了训练的步数Steps为1230步，还给出了误差平方和Error为5.23158，这两个参数对于度量模型性能很重要。图中仍然给出了每个神经元连接处的权重还有偏差项。\r\n\r\n接下来进行预测\r\n```\r\n\u003e model_result \u003c- compute(concrete_model, concrete_test[1 : 8])\r\n\u003e predicted_strength \u003c- model_result$net.result\r\n\u003e cor(predicted_strength, concrete_test$strength)\r\n          [,1]\r\n[1,] 0.7811192\r\n```\r\n\r\n通过`cor()`函数获取神经网络预测值与测试集实际值的相关性，结果为0.7811192，可见具有很强的相关性，这意味着我们神经网络模型还是不错的。我们继续提升神经网络性能。\r\n\r\n### 5.3提升模型性能\r\n`neuralnet()`函数中还有一个参数没有使用，即`hidden`参数，该参数控制神经网络中隐藏层的神经元数目，刚开始默认为1，我们可以试着调整该参数。\r\n```\r\n\u003e concrete_model \u003c- neuralnet(strength ~ ., data = concrete_train, hidden = 5)\r\n\u003e plot(concrete_model)\r\n```\r\n我们设置隐藏层神经元数目为5，那么最终的网络拓扑如下\r\n\r\n![隐藏层多神经元神经网络拓扑结构](/images/article/neuralnet-img-hidden.png)\r\n\r\n明显复杂了很多。但是可以看出，我们的步数Steps变成了13950，而误差平方和Error变成了1.394552，也就是说神经网络复杂了，步数自然会上升，而误差则会下降，再预测一次，如下\r\n```\r\n\u003e model_result \u003c- compute(concrete_model, concrete_test[1 : 8])\r\n\u003e predicted_strength \u003c- model_result$net.result\r\n\u003e cor(predicted_strength, concrete_test$strength)\r\n          [,1]\r\n[1,] 0.7889097\r\n```\r\n从相关性来看，我们之前隐藏层为1个神经元的模型还是相当不错的，而隐藏层神经元调整为5之后降低了模型偏差，但是对预测结果的提升并没有改变多少。\r\n\r\n需要注意的是，过多的隐藏层是会提升模型的精度，但是也会有过度拟合的风险。\r\n\r\n全文完！\r\n\r\n###### 推荐阅读\r\n1. http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html\r\n\r\n###### 参考文献\r\n1. 《Artificial Intelligence: A Modern Approach》\r\n2. 《Machine Learning With R》\r\n3. https://towardsdatascience.com/gradient-descent-in-a-nutshell-eaf8c18212f0\r\n4. https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/","cover":"/images/article/shenjingyuan.jpg","link":"artificial-neural-network.html","preview":"\u003cp\u003e人工神经网络有监督学习算法，适用于数值预测以及分类任务。适合解决输入数据和输出数据都很好理解或简单，但是涉及输入与输出的过程却极其复杂。因此，适合黑箱操作。\u003c/p\u003e\n","title":"黑箱方法——人工神经网络"},{"content":"\r\n\r\n## 一、简介\r\n决策树学习算法以树形结构建立模型，类似于流程图，该模型本身包含一系列逻辑决策。几个概念如下\r\n\r\n+ 决策节点：根据某一特征(属性)作出决定；\r\n+ 决策分支：从决策节点引出的分支表示做出的选择；\r\n+ 终端节点(叶节点)：决策树由叶节点终止，叶节点表示遵循决策组合的结果。\r\n\r\n其运行过程为：数据的分类从根节点开始(根节点是第一个决策节点)，根据特征值遍历树上的各个决策节点。数据采用的是一个漏斗形的路径，它将每一条记录汇集到一个节点，在叶节点为该记录分配一个预测类。\r\n\r\n## 二、理论原理\r\n决策树是决策函数的可视化描述，决策函数是由训练集的特征空间训练出来的，不同属性的不同程度上的不同组合会形成不同的候选函数(或决策树)，拟合优度因函数(或者不同特征的不同程度上的不同组合)而异，有的明显性能出色，有的明显性能低劣，我们不可能将所有的候选函数全部生成然后一一测试，因为多数情况下随着特征的增加，候选函数呈指数级增长。我们的目的就是找到最优的候选函数，何为最优？浅显易懂的来说就是\r\n\r\n\u003e 通过较少的测试达到正确分类，即树中所有路径都较短，整棵树较浅。\r\n\r\n要做到路径较短，那么也就意味着每一次的分裂都要是高效的，即每次分裂都可以提高子集的同质性或者纯度，这样减少了不必要的分割，整棵树必然会变浅。那么专业的来说就是\r\n\r\n\u003e 每一次决策节点的分裂，得到的子集中的预测类的水平的比例与父集合中的预测类的水平的比例**最大程度上**更低。\r\n\r\n## 三、数学定义\r\n决策树算法对以上**最大程度上**的定义是通过**信息增益**实现的。要解释信息增益，先要解释**熵**与**条件熵**。\r\n\r\n熵：熵是随机变量的不确定性度量，信息的获取对应于熵的减少。熵越大说明信息量越大该事件内部越不同质，不确定性越大。熵越小说明信息量越小该事件内部越同质，不确定性越小。举个例子\r\n\r\n+ 明天早上太阳必然升起。这个事件，即随机变量或该事件没有不确定性，是完全同质的(因为只有这一种可能，还是必然的)；\r\n+ 抛一枚硬币，出现正反面朝上的概率皆为0.5。这个事件的熵为1，即随机变量或该事件具有不确定性，是不同质的(因为样本空间存在两种可能，而不是一种)。\r\n\r\n所以，我们可以通过事件的熵来定义该事件内部(样本空间)的同质性或混乱性。熵越大，说明该事件样本空间越不同质越杂乱，实验结果的不确定性更大；熵越小，说明事件样本空间越同质越不杂乱，实验的不确定性更小。其计算公式为\r\n![熵计算公式](/images/article/shang.png)\r\n\r\n条件熵：条件熵表示在已知随机变量X的条件下，随机变量Y的不确定性。将其定义为给定X的条件下Y的条件概率分布的熵对X的数学期望。其本质仍然是熵。其计算公式为\r\n![条件熵计算公式](/images/article/tiaojianshang.png)\r\n\r\n在决策树算法当中，使用熵值来计算由每一个可能特征的分割所引起的同质性(均匀性)变化，该计算称为信息增益。对于特征F，信息增益的计算方法是分割前的数据分区(S_1)的熵值减去由分割产生的数据分区(S_2)的熵值。其中S_1就是分裂前集合预测类水平的熵值，但是集合被通过该特征划分为了若干个子集，怎样计算它们的熵值呢？\r\n\r\n由于一次分割后，数据被划分到了多个分区中，因此计算S_2需要考虑所有分区的熵值总和，这并不意味着简单加总，而是求他们的期望，也就是在分割集合的条件下子集的熵对该次分割的数学期望，即S_2是分割后产生的若干个子集的预测类水平的熵值的期望(即从一个分割得到的总熵就是根据案例落入分区的比例加权的n个分区的熵值的总和)，这样就可以通过条件熵的方式来度量由分割产生的效果，即总熵减少到了多少(因为分割为了多个子集，所以总熵只能通过期望来计算)。这是一种度量方式，但是不够直观，最直观的度量方式就是计算信息增益，如下\r\n![信息增益计算公式](/images/article/information-gain.png)\r\n\r\n由于子集有且只有一个父集(可能会共享同一个父集，但是绝不会同时拥有两个或两个以上的直接父集)，那么也就意味着分割前的熵是相同的，那么分割后的子集的条件熵越小就越说明当前训练集在该选择该特征进行划分后效果最好，因为分割后的总熵(期望熵)越小，即内部越同质越均匀纯度越高。为了便于与其余的特征进行比较，通过计算信息增益，那么也就意味着对同一训练集根据不同特征进行分裂，哪个特征的信息增益越大那么划分的结果越好越同质越均匀越纯。\r\n\r\n到此为止，可以看到，决策树算法是通过**信息增益**来确定合理的或最好的分割点的，信息增益在此程度上意味着一次分割获得的信息多少，信息增益越大，那么得到的信息量越多，那么分割的越成功，分割的次数越少，最终树中的所有路径越短，整棵树越浅。\r\n\r\n简言之：\r\n\r\n**熵越小越说明当前训练集(或子集)内部纯度越高越同质，这是我们的最终目标。刚开始，熵肯定是很大的，我们的目的就是通过根据合适的特征的分裂降低子集的熵值以实现分类预测，而合适的特征的选择是通过信息增益来衡量的。**\r\n\r\n## 四、过度拟合与剪枝\r\n过度拟合的专业定义显得过于繁琐和难懂，不妨使用《Artificial Intelligence: A Modern Approach》一书中关于过度拟合的形象化描述，如下\r\n\r\n\u003e Consider the problem of trying to predict whether the roll of a die will come up as 6 or not Suppose that experiments are carried out with various dice and that the attributes describing each training example include the color of the die, its weight, the time when the roll was done, and whether the experimenters had their fingers crossed. If the dice are fair, the right thing to learn is a tree with a single node that says \"no,\" But the DECISION-TREE-LEARNING algorithm will seize on any pattern it can find in the input. If it turns out that there are 2 rolls of a 7-gram blue die with fingers crossed and they both come out 6, then the algorithm may construct a path that predicts 6 in that case. This problem is called overfitting. \r\n\r\n 对决策树而言，一种被称为**决策树剪枝**的技术可以减轻过度拟合。包括两种，分别是**预剪枝**和**后剪枝**。\r\n \r\n所谓**预剪枝**就是一旦决策树达到了一定数量的决策，或者说决策节点仅含有少量的案例，那么就停止树的生长，因为这样的继续生长是毫无意义的，决策节点只含有少量的案例是不具备一般性意义的。或者说当不存在可用于分裂的好属性时，就停止生长，这种情况就是允许该子集存在一定的不同质以防止过度拟合，因为再此基础上继续生长仍然不具备一般性意义，还是因为案例太少，不具备观测与分析价值。\r\n\r\n预剪枝的好处就是及时停止树的生长，而不是等树生长之后再修剪；简单而直接，适用于解决大规模问题，因为数据量很大的情况下生成被后剪的不必要决策节点是毫无意义的。但是要精确的实现决策树的修剪并不容易，如果修剪的过早那么预测分类不同质的可能性更大，影响决策树的优度；而如果修剪的过晚，又会造成一定程度的过度拟合。\r\n\r\n预剪枝的几种方法如下\r\n\r\n1. 定义一个高度，当决策树达到该高度时就停止决策树的生长，这是最简单的一种办法；\r\n2. 达到某叶节点的案例(或记录)具有相同的特征向量，即使这些案例不属于同一类，那么也可以停止决策树的生长，因为既然当前节点的案例集具备相同的特征向量，那么就有很大的可能性认为其与当前预测类同质，这个度还是要把握好，如果停止的过早仍然会使得叶节点预测类不同质可能性变大；\r\n3. 定义一个阈值，当达到某个节点的案例个数小于该阈值时就可以停止该决策树的生长，原因仍然是少量样本不具备观测与分析价值，对其分析(选择合适的分割点生成决策节点)容易造成过度拟合；\r\n4. 定义一个阈值，通过计算每次扩张对系统性能的增益，并比较增益值与该阈值的大小来决定是否停止决策树的生长。\r\n\r\n所谓**后剪枝**就是先构造完整的决策树，允许树过度拟合训练数据，然后对那些置信度不够的节点子树用叶节点来代替，该叶节点的预测类型为该节点子树中最频繁的类型。几种后剪枝方法如下\r\n\r\n1. Reduced-Error Pruning(REP, 错误率降低剪枝)\r\n2. Pessimistic Error Pruning(PEP, 悲观错误剪枝)\r\n3. Cost-Complexity Pruning(CCP, 代价复杂度剪枝)\r\n\r\n其中REP剪枝的原理与操作如下\r\n\r\n该方法将可用数据集合分为两个样例集合，一个训练集用于训练决策树，一个验证集用来评估修剪这个决策树后得到的预测分类的结果的精度以决定是否修剪相应子树。其操作方法如下\r\n\r\n1. 删除以此节点为根的子树；\r\n2. 使其成为叶子节点；\r\n3. 赋予该叶子节点关联的训练数据的最常见分类，即将原子树最最频繁的类型赋给该叶子节点；\r\n4. 当修建后的树对于验证集合的性能不会比原来的树差时，才真正删除该子树或者用叶节点替换该子树。\r\n\r\n由于使用独立的验证集，与原始决策树相比，修建后的决策树可能偏向于过度修剪。这是因为一些不会在验证集中出现的稀少的但是在训练集中出现的案例会被修剪，但是这并不意味着该案例在其后的测试集中不会在出现。如果训练集较小，不建议使用REP剪枝算法。\r\n\r\n## 五、R语言中C5.0决策树算法\r\nC5.0算法是C4.5的改进版，适用于大多数类型的问题。与其它机器学习模型相比，该算法建立的决策树一般都表现的与它们的模型几乎一模一样，且更容易理解与部署。该算法的优点之一就是它可以自动修剪，其总体策略就是后剪枝，它先生成一个过度拟合的决策树，然后删除对分类误差影响不大的节点和分枝。在某些情况下，整个分枝会被进一步向上移动或者被一些简单的决策所取代，这两个移植分枝的过程被称为子树提升和子树替换。C5.0算法的优点之一就是它很容易调整训练方案以提升决策树性能。\r\n\r\n该算法在C50添加包当中，其函数原型为\r\n\r\n先创建分类器\r\n```\r\nm \u003c- C5.0(train, class, trials = 1, costs = NULL)\r\n```\r\n+ train : 一个包含训练数据的数据框;\r\n+ class : 包含训练数据每一行的分类的一个因子向量;\r\n+ trials: 可选数值，用于控制自助法循环次数(默认为1)，可用于提升模型性能;\r\n+ costs : 可选矩阵，用于给出与各种类型错误相对应的成本，可用于提升模型性能。\r\n\r\n该函数返回一个C5.0模型对象，该对象能够用于预测。\r\n\r\n进行预测\r\n```\r\np \u003c- predict(m, test, type = \"class\")\r\n```\r\n+ m : 由C5.0函数得到的训练模型;\r\n+ test : 一个包含测试数据的数据框，该数据框和用来创建分类器的训练数据有同样的特征;\r\n+ type : 取值为class或者prob, 标识预测是最有可能的类别值或者原始的预测概率;\r\n\r\n该函数返回一个向量，对应test测试集的每一个案例的预测分类结果或概率值(由type决定)。\r\n\r\n## 六、R语言C5.0算法应用示例\r\n以《Machine Learning With R》一书中的根据银行贷款数据来建立模型来预测贷款是否违约为例来说明C5.0算法\r\n```\r\n\u003e getwd()\r\n[1] \"C:/Users/Administrator/Documents\"\r\n\u003e setwd(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\docs\\\\Machine-Learning-with-R-datasets-master\")\r\n\u003e credit \u003c- read.csv(\"credit.csv\")\r\n\u003e str(credit$default)\r\n int [1:1000] 1 2 1 1 2 1 1 1 1 2 ...\r\n\u003e table(credit$default)\r\n\r\n  1   2 \r\n700 300 \r\n\u003e credit$default \u003c- factor(credit$default, levels = c(1, 2), labels = c(\"no\", \"yes\"))\r\n\u003e table(credit$default)\r\n\r\n no yes \r\n700 300 \r\n\u003e set.seed(12345)\r\n\u003e credit_rand \u003c- credit[order(runif(1000)), ]\r\n\u003e credit_train \u003c- credit_rand[1 : 900, ]\r\n\u003e credit_test \u003c- credit_rand[901 : 1000, ]\r\n\u003e prop.table(table(credit_train$default))\r\n\r\n       no       yes \r\n0.7022222 0.2977778 \r\n\u003e prop.table(table(credit_test$default))\r\n\r\n  no  yes \r\n0.68 0.32 \r\n```\r\n上述将数据框credit按照均匀分布的1000个随机数重组，最终为credit_rand，然后分别分割为训练集credit_train和测试集credit_test，通过校验其分布发现基本上与原数据框分布无异。\r\n然后应用C5.0算法创建分类器\r\n```\r\n\u003e library(C50)\r\nWarning message:\r\n程辑包‘C50’是用R版本3.5.3 来建造的 \r\n\u003e credit_model \u003c- C5.0(credit_train[-17], credit_train$default)\r\n```\r\n我们可以通过输出分类器名称来查看关于决策树的一些基本数据\r\n```\r\n\u003e credit_model\r\n\r\nCall:\r\nC5.0.default(x = credit_train[-17], y = credit_train$default)\r\n\r\nClassification Tree\r\nNumber of samples: 900 \r\nNumber of predictors: 20 \r\n\r\nTree size: 57 \r\n\r\nNon-standard options: attempt to group attributes\r\n```\r\n前面的文字反映了关于该决策树的一些基本情况，包括生成决策树的函数调用、特征数(predictors)、用于决策树增长的案例(Samples)。同时列出了树的大小是57，表明该决策树包含57个决策。\r\n如果要查看决策树，可以通过`summary()`函数来实现，部分输出为\r\n```\r\n\u003e summary(credit_model)\r\n\r\nCall:\r\nC5.0.default(x = credit_train[-17], y = credit_train$default)\r\n\r\n\r\nC5.0 [Release 2.07 GPL Edition]  \tSat Mar 23 20:33:44 2019\r\n-------------------------------\r\n\r\nClass specified by attribute `outcome'\r\n\r\nRead 900 cases (21 attributes) from undefined.data\r\n\r\nDecision tree:\r\n\r\nchecking_balance = unknown: no (358/44)\r\nchecking_balance in {\u003c 0 DM,\u003e 200 DM,1 - 200 DM}:\r\n:...foreign_worker = no:\r\n    :...installment_plan in {none,stores}: no (17/1)\r\n    :   installment_plan = bank:\r\n    :   :...residence_history \u003c= 3: yes (2)\r\n    :       residence_history \u003e 3: no (2)\r\n    foreign_worker = yes:\r\n\r\n\r\nEvaluation on training data (900 cases):\r\n\r\n\t    Decision Tree   \r\n\t  ----------------  \r\n\t  Size      Errors  \r\n\r\n\t    57  127(14.1%)   \u003c\u003c\r\n\r\n\r\n\t   (a)   (b)    \u003c-classified as\r\n\t  ----  ----\r\n\t   590    42    (a): class no\r\n\t    85   183    (b): class yes\r\n\r\n\r\n\tAttribute usage:\r\n\r\n\t100.00%\tchecking_balance\r\n\t 60.22%\tforeign_worker\r\n\t 57.89%\tcredit_history\r\n\t 51.11%\tmonths_loan_duration\r\n\t 42.67%\tsavings_balance\r\n\t 30.44%\tother_debtors\r\n\t 17.78%\tjob\r\n\t 15.56%\tinstallment_plan\r\n\t 14.89%\tpurpose\r\n\t 12.89%\temployment_length\r\n\t 10.22%\tamount\r\n\t  6.78%\tresidence_history\r\n\t  5.78%\thousing\r\n\t  3.89%\tdependents\r\n\t  3.56%\tinstallment_rate\r\n\t  3.44%\tpersonal_status\r\n\t  2.78%\tage\r\n\t  1.56%\tproperty\r\n\t  1.33%\texisting_credits\r\n\r\n\r\nTime: 0.0 secs\r\n```\r\n该输出包含一个混淆矩阵，是一个交叉列表，表示模型对训练数据错误分类的记录数。可以看出共有42个原本是no的案例被预测为yes，共有85个原本是yes的案例被预测为no。即该决策树对训练集中127个案例错误的分类了，占比为14.1%\r\n\r\n现在有了分类器，我们可以用于预测，如下\r\n```\r\n\u003e credit_prediction \u003c- predict(credit_model, credit_test)\r\n```\r\n预测的结果向量为\r\n```\r\n\u003e credit_prediction\r\n  [1] no  yes no  no  no  yes no  no  yes yes no  no  no  yes yes yes no  no  yes\r\n [20] no  yes no  yes no  yes no  yes no  no  no  yes yes no  yes no  no  no  no \r\n [39] yes yes no  no  no  yes yes yes yes no  yes no  no  no  yes no  no  no  no \r\n [58] yes no  no  no  yes no  yes no  no  yes no  no  no  no  no  no  yes yes no \r\n [77] no  yes no  no  no  no  no  no  no  no  no  no  yes yes yes no  no  no  no \r\n [96] yes no  yes no  no \r\nLevels: no yes\r\n```\r\n可以通过如下方法查看测试集的预测成功程度，以评估模型性能\r\n```\r\n\u003e table(credit_prediction == credit_test$default)\r\n\r\nFALSE  TRUE \r\n   25    75 \r\n\r\n\u003e prop.table(table(credit_prediction == credit_test$default))\r\n\r\nFALSE  TRUE \r\n 0.25  0.75 \r\n```\r\n可见，正确率为75%。\r\n\r\n如何提高模型性能呢？\r\n\r\n## 七、提高C5.0算法的分类器性能\r\n之前在创建分类器的时候有两个参数没有使用，分别是trials和costs参数。\r\n\r\n对C5.0算法性能的提升可以通过**自适应增强(adaptive boosting)算法**，具体做法是在决策树的构建过程中，这些决策树通过投票表决的方法为每个案例选择最佳的分类。C5.0算法通过trials参数来引入该算法(boosting算法), 该参数的值表示在模型增强团队中使用到的独立决策树的数量，参数trials设置了一个上限，如果该算法识别出额外的实验似乎并没有提高模型的准确性，那么它将停止添加决策树。一般设置为10\r\n```\r\n\u003e credit_model \u003c- C5.0(credit_train[-17], credit_train$default, trials = 10)\r\n\u003e credit_prediction \u003c- predict(credit_model, credit_test)\r\n\u003e prop.table(table(credit_prediction == credit_test$default))\r\n\r\nFALSE  TRUE \r\n 0.21  0.79 \r\n```\r\n可以看到明显提升了模型精度。\r\n\r\n还有一个办法是通过costs参数，该参数是一个代价矩阵，用于指定每种错误相对于其它任何错误有多少倍的严重性。假如评估模型精度的双向交叉表为\r\n```\r\n\u003e library(gmodels)\r\nWarning message:\r\n程辑包‘gmodels’是用R版本3.5.3 来建造的 \r\n\u003e CrossTable(credit_test$default, credit_prediction, prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE, dnn = c(\"actual default\", \"predicted default\"))\r\n\r\n \r\n   Cell Contents\r\n|-------------------------|\r\n|                       N |\r\n|         N / Table Total |\r\n|-------------------------|\r\n\r\n \r\nTotal Observations in Table:  100 \r\n\r\n \r\n               | predicted default \r\nactual default |        no |       yes | Row Total | \r\n---------------|-----------|-----------|-----------|\r\n            no |        63 |         5 |        68 | \r\n               |     0.630 |     0.050 |           | \r\n---------------|-----------|-----------|-----------|\r\n           yes |        16 |        16 |        32 | \r\n               |     0.160 |     0.160 |           | \r\n---------------|-----------|-----------|-----------|\r\n  Column Total |        79 |        21 |       100 | \r\n---------------|-----------|-----------|-----------|\r\n\r\n```\r\n那么我们定义如下代价矩阵\r\n```\r\n\u003e error_cost \u003c- matrix(c(0, 4, 1, 0), nrow = 2)\r\n\u003e error_cost\r\n     [,1] [,2]\r\n[1,]    0    1\r\n[2,]    4    0\r\n```\r\n该代价矩阵用来说明双向交叉表中落入对应[2, 1]的元素的错误更加严重，那么分类器就会极力避免这种情况发生，再创建一个分类器试试\r\n```\r\n\u003e credit_model \u003c- C5.0(credit_train[-17], credit_train$default, costs = error_cost)\r\nWarning message:\r\nno dimnames were given for the cost matrix; the factor levels will be used \r\n\u003e credit_prediction \u003c- predict(credit_model, credit_test)\r\n\u003e prop.table(table(credit_prediction == credit_test$default))\r\n\r\nFALSE  TRUE \r\n 0.32  0.68 \r\n\u003e CrossTable(credit_test$default, credit_prediction, prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE, dnn = c(\"actual default\", \"predicted default\"))\r\n\r\n \r\n   Cell Contents\r\n|-------------------------|\r\n|                       N |\r\n|         N / Table Total |\r\n|-------------------------|\r\n\r\n \r\nTotal Observations in Table:  100 \r\n\r\n \r\n                    | credit_prediction \r\ncredit_test$default |        no | Row Total | \r\n--------------------|-----------|-----------|\r\n                 no |        68 |        68 | \r\n                    |     0.680 |           | \r\n--------------------|-----------|-----------|\r\n                yes |        32 |        32 | \r\n                    |     0.320 |           | \r\n--------------------|-----------|-----------|\r\n       Column Total |       100 |       100 | \r\n--------------------|-----------|-----------|\r\n```\r\n可见，与之前的模型相比，该模型的精度更低。但是这不失为一种调整模型性能的方法，需要根据实际情况来调整。","cover":"/images/decision-tree.jpg","link":"decision-tree-learning.html","preview":"\u003cp\u003e决策树学习算法以树形结构建立模型，类似于流程图，该模型本身包含一系列逻辑决策。\u003c/p\u003e\n","title":"分而治之——决策树学习算法"},{"content":"\r\n\r\n数组的Arrays类有很多有用的功能，看一下\r\n\r\n## toString方法\r\n\r\n如果我们想直接输出整个数组，如果我们像下面这样的话得到的只是数组的内存地址，而Arrays.toString()方法得到的就是预期结果\r\n\r\n```\r\nimport java.util.Arrays;\r\n\r\npublic class ArraysTest {\r\n\r\n    public static void main(String[] args) {\r\n        int[] array = {2， 3， 1};\r\n        System.out.println(array);  //[I@15db9742\r\n        System.out.println(Arrays.toString(array)); //[1, 2, 3]\r\n    }\r\n\r\n}\r\n```\r\n\r\n## sort方法\r\n\r\n对于除boolean类型外的数组，Arrays均提供了排序方法\r\n\r\nint型数组从小到大排序为\r\n\r\n```\r\nimport java.util.Arrays;\r\n\r\npublic class ArraysTest {\r\n\r\n    public static void main(String[] args) {\r\n        int[] array = {1, 2, 3};\r\n        Arrays.sort(array);\r\n        System.out.println(Arrays.toString(array)); //[1, 2, 3]\r\n    }\r\n\r\n}\r\n```\r\n\r\nString型数组的排序为\r\n\r\n```\r\nimport java.util.Arrays;\r\n\r\npublic class ArraysTest {\r\n\r\n    public static void main(String[] args) {\r\n        String[] str = {\"Feily\", \"Zhang\", \"Haoyue\", \"Li\", \"hello\", \"world\"};\r\n        Arrays.sort(str);\r\n        System.out.println(Arrays.toString(str)); //[Feily, Haoyue, Li, Zhang, hello, world]\r\n    }\r\n\r\n}\r\n```\r\n\r\n是按照首字母的ASCII码int值排序的，由于大些字母的ASCII码小于小写，所以在前面，如果排序像忽略大小写，那么如下\r\n\r\n```\r\nimport java.util.Arrays;\r\n\r\npublic class ArraysTest {\r\n\r\n    public static void main(String[] args) {\r\n        String[] str = {\"Feily\", \"Zhang\", \"Haoyue\", \"Li\", \"hello\", \"world\"};\r\n        Arrays.sort(str, String.CASE_INSENSITIVE_ORDER);\r\n        System.out.println(Arrays.toString(str)); //[Feily, Haoyue, hello, Li, world, Zhang]\r\n    }\r\n\r\n}\r\n```\r\n\r\n## binarySearch()方法\r\n\r\n```\r\nimport java.util.Arrays;\r\n\r\npublic class ArraysTest {\r\n\r\n    public static void main(String[] args) {\r\n        int[] arr = {5, 3, 1, 4, 2};\r\n        String[] str = {\"Feily\", \"Zhang\", \"Haoyue\", \"Li\", \"hello\", \"world\"};\r\n        System.out.println(Arrays.binarySearch(str, \"Li\")); //3\r\n        Arrays.sort(arr);\r\n        System.out.println(Arrays.binarySearch(str, \"hello\")); //4\r\n        System.out.println(Arrays.binarySearch(arr, 5));    //-6\r\n        Arrays.sort(arr);\r\n        System.out.println(Arrays.binarySearch(arr, 5));    //4\r\n    }\r\n\r\n}\r\n```\r\n在二分查找整形数组时一定要保证元素有序，否则不会达到预期效果，字符串数组的话应该都可以。如果找不到指定的元素，那么就会返回负数，负数等于插入点+1，插入点指的是在这个位置插入没找到的元素仍然可以保证数组有序。","cover":"/images/java.jpg","link":"analysis-of-arrays-classes.html","preview":"\u003cp\u003etoString方法, sort方法, binarySearch()方法。\u003c/p\u003e\n","title":"Arrays类的相关用法"},{"content":"\r\n\r\nString类适合少量字符串的不太频繁的操作，因为String的每次的字符串操作基本上都是重新创建一个字符数组，这样性能太低，很多时候我们需要兼顾性能，能不能直接在字符串上 操作而不是拷贝到另一个字符数组再操作？\r\n\r\n答案就是用StringBuilder或者StringBuffer，这两个类的方法基本上都是一样的实现的代码也几乎一样，唯一不同的地方在于StringBuffer是线程安全的，而StringBuilder是线程不安全的。线程安全的成本就是性能耗损，所以在不存在线程安全的情况下StringBuilder处理大量字符串无疑是首选\r\n\r\n## 基本用法\r\n\r\n创建StringBuilder对象\r\n\r\n```\r\nStringBuilder ab = new StringBuilder();\r\nsb.append(String str);\r\n```\r\n\r\n然后通过toString获取字符串\r\n\r\n```\r\nSystem.out.println(sb.toString());\r\n```\r\n\r\n## 基本实现原理\r\n\r\nStringBuilder内部仍然是基于字符数组，但是该字符数组不是final的，是可以修改的，与String不同的是，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数,该实例变量如下定义\r\n\r\n```\r\nint count;\r\n```\r\n\r\nStringBuilder继承自AbstractStringBuilder，它的默认构造方法是\r\n\r\n```\r\npublic StringBuilder() {\r\n    super(16);\r\n}\r\n```\r\n\r\n即调用父类的构造方法，其父类的构造方法为\r\n\r\n```\r\nAbstractStringBuilder(int capacity) {\r\n    value = new cahr[capacity];\r\n}\r\n```\r\n\r\n即创建一个容量为16的字符数组。\r\n\r\nappend方法的实现为\r\n\r\n```\r\npublic AbstractStringBuilder append(String str) {\r\n    if (str == null) str = \"null\";\r\n    int len = str.length;\r\n    ensureCapacityInternal(count + len);\r\n    str.getChars(0, len, value, count);\r\n    count += len;\r\n    return this;\r\n}\r\n```\r\n\r\n可见，append会直接复制字符到内部的字符数组中，如果字符数组的长度不够，那么会进行拓展，并增加实际使用的长度。\r\n\r\ntoString方法的实现为\r\n\r\n```\r\npublic String toString() {\r\n    return new String(value, o, count);\r\n}\r\n```\r\n\r\n即直接将字符数组转化为字符串。\r\n\r\n## String的+和+=运算符\r\n\r\nString的+和+=运算符，是Java编译器提供的支持，但是背后会转化为StringBuilder的append方法，所以在大量且频繁的字符串操作时应该尽量避免使用String的+和+=运算符，性能比较低。","cover":"/images/java.jpg","link":"analysis-of-stringbuilder-classes.html","preview":"\u003cp\u003eString类适合少量字符串的不太频繁的操作，因为String的每次的字符串操作基本上都是重新创建一个字符数组，这样性能太低，可以考虑使用StringBuilder或者StringBuffer。\u003c/p\u003e\n","title":"剖析StringBuilder类"},{"content":"\r\n\r\nString类的常用方法：\r\n\r\n```\r\npublic boolean isEmpty()\r\npublic int length\r\npublic String subString(int beginIndex)\r\npublic String subString(int beginIndex, int endIndex)\r\npublic int indexOf(char c)\r\npublic int indexOf(String str)\r\npublic int lastIndexOf(char c)\r\npublic int lattIndexOf(String str)\r\npublic boolean contains(CharSequence s)\r\npublic boolean startsWith(String str)\r\npublic boolean endsWith(String str)\r\npublic boolean equals(Object obj)\r\npublic boolean equalsIgnoreCase(String str)\r\npublic int compareTo(String anotherString)\r\npublic int compareToIgnoreCase(String str)\r\npublic String toUpperCase()\r\npublic String toLowerCase()\r\npublic String concat(String str)\r\npublic String replace(char oldChar, char newChar)\r\npublic String replace(CharSequence target, CharSequence replacement)\r\npublic String trim()\r\n```\r\n\r\n## String类的内部\r\n\r\nString类基于char数组，有两个构造方法可以根据char数组创建String变量\r\n\r\n```\r\npublic String(char[] value)\r\npublic String(char[] value, int offset, int count)\r\n```\r\n\r\nString对字符串的操作并不是在字符串或者字符数组本身进行操作，而是创建一个新的char数组然后把内容复制进去再操作\r\n\r\nJava使用Charset类表示各种编码，它有两个常用静态方法\r\n\r\n```\r\npublic static Charset defaultCharset() //获取系统默认编码\r\npublic static Charset forName(String charsetName) //设置编码\r\n```\r\n\r\n## String类的不可变性\r\n\r\n与包装类相似，String类也是不可变类，即对象一旦创建，就无法修改。String类也被声明为final，无法继承，内部的char数组也是final的，一旦初始化就不能再变。这也就是说String内部对字符串进行操作的方法是通过拷贝原有字符串再操作实现的。\r\n\r\n## String常量字符串\r\n\r\nString常量字符串被存放在JVM常量池当中，也就是说就算创建多份相同的常量，实际上这些常量都是引用的同一份JVM常量池的常量，测试一下\r\n\r\n```\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str1 = \"hello,world\";\r\n        String str2 = \"hello,world\";\r\n        System.out.println(str1 == str2); //true\r\n    }\r\n\r\n}\r\n```\r\n\r\n以上定义的是两个常量，由于常量存放在常量池，所以二者的引用是一致的，所以打印true，上面的代码类似于\r\n\r\n```\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str = new String(new char[] {'h','e','l','l','o',',','w','o','r','l','d'});\r\n        String str1 = str;\r\n        String str2 = str;\r\n        System.out.println(str1 == str2);\r\n    }\r\n\r\n}\r\n```\r\n\r\n即实际上只有一个对象，那么当然等于自身\r\n\r\n如果用new创建，那么就不会存放在常量池，而是Java堆，如下\r\n\r\n```\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str1 = new String(\"hello,world\");\r\n        String str2 = new String(\"hello,world\");\r\n        System.out.println(str1 == str2); //false\r\n    }\r\n\r\n}\r\n```\r\n\r\n所以输出为false，因为有两个对象。上面的代码类似于\r\n\r\n```\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str = new String(new char[] {'h','e','l','l','o',',','w','o','r','l','d'});\r\n        String str1 = new String(str);\r\n        String str2 = new String(str);\r\n        System.out.println(str1 == str2);\r\n    }\r\n\r\n}\r\n```\r\n\r\n而String类中以String为参数的构造方法的代码如下\r\n\r\n```\r\npublic String(String str) {\r\n    this.value = str.value;\r\n    this.hash = str.hash;\r\n}\r\n```\r\n\r\nstr1与str2的value值共同指向常量池的同一个常量，但是hash不同，所以二者不同。\r\n\r\n如果用equals方法比较，那么输出为真\r\n\r\n```\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str1 = new String(\"hello,world\");\r\n        String str2 = new String(\"hello,world\");\r\n        System.out.println(str1.equals(str2)); //true\r\n    }\r\n\r\n}\r\n```\r\n\r\n这是由于equals方法比较对象内容是否相等，而==只是比较常量的引用，后者速度更快。","cover":"/images/java.jpg","link":"analysis-of-string-classes.html","preview":"\u003cp\u003eString类基于char数组，String对字符串的操作并不是在字符串或者字符数组本身进行操作，而是创建一个新的char数组然后把内容复制进去再操作。\u003c/p\u003e\n","title":"剖析String类"},{"content":"\r\n\r\n字符流以字符为单位操作文件，以下是Java中字符流的主要类\r\n\r\n+ Reader/Writer：字符流的基类，是抽象类；\r\n+ FileRead/FileWrite：输入源与输出源均为文件的字符流；\r\n+ InputStreamReader/OutputStreamWriter：适配器类，将字节流转换为字符流；\r\n+ CharArrayReader/CharArrayWriter：属于源与输出源是char数组的字符流；\r\n+ StringReader/StringWriter：输入源与输出源为String的字符流；\r\n+ BufferedReader/BufferedWriter：装饰类，对输入/输出提供缓冲，以及按行读写功能；\r\n+ PrintWriter：装饰类，可将基本类型与对象类型转换为其字符串形式输出的类。\r\n\r\n## Reader类的主要方法如下\r\n\r\n```\r\npublic int read() throws IOException\r\npublic int read(char cbuf[]) throws IOException\r\nabstract public void close() throws IOException\r\n```\r\n\r\n## Writer类的主要方法如下\r\n\r\n```\r\npublic void writer(int c)\r\npublic void writer(char cbuf)\r\npublic void writer(String str) throws IOException\r\nabstract public void flush() throws IOException\r\n```\r\n\r\n## InputStreamReader/OutputStreamWriter\r\n\r\nInputStreamReader/OutputStreamWriter是适配器类，能够将InputStream/OutputStream转换为Reader/Writer，使用方法如下\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Writer;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            File file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            Writer writer = new OutputStreamWriter(new FileOutputStream(file));\r\n            writer.write(\"Feily Zhang\");\r\n            writer.close();\r\n            Reader reader = new InputStreamReader(new FileInputStream(file));\r\n            char[] data = new char[1024];\r\n            int size = reader.read(data);\r\n            System.out.println(new String(data, 0, size));\r\n\t\t\treader.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## FileRead/FileWrite\r\n\r\nFileRead/FileWrite的用法类似于FileInputStream/FileOutputStream，直接传入文件名就可以按字符流读取，如下\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.io.Reader;\r\nimport java.io.Writer;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            File file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            Writer writer = new FileWriter(file);\r\n            writer.write(\"Hello, world\");\r\n            writer.close();\r\n            Reader reader = new FileReader(file);\r\n            char[] data = new char[1024];\r\n            int size = reader.read(data);\r\n            System.out.println(new String(data, 0, size));\r\n            reader.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## BufferedReader/BufferedWriter\r\n\r\nBufferedReader/BufferedWriter为Reader/Writer提供缓冲区功能，属于装饰类，能按行读写，示例如下\r\n\r\n```\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            File file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            BufferedWriter writer = new BufferedWriter(new FileWriter(file));\r\n            writer.write(\"Hello, Feily Zhang\\nHello, World\");\r\n            writer.close();\r\n            BufferedReader read = new BufferedReader(new FileReader(file));\r\n            char[] data = new char[1024];\r\n            int size = read.read(data);\r\n            System.out.println(new String(data, 0, size));\r\n            read.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```","cover":"/images/java.jpg","link":"review-at-the-character-stream-of-java-file-operations.html","preview":"\u003cp\u003e字符流以字符为单位操作文件。\u003c/p\u003e\n","title":"再看Java文件操作之字符流"},{"content":"\r\n\r\n这里Java以二进制字节的方式处理文件，以二进制方式读写的主要流如下\r\n\r\n+ InputStream/OutputStream：这是基类，都是抽象类；\r\n+ FileInputStream/FileOutputStream：输出源和输出目标是文件的流；\r\n+ ByteArrayInputStream/ByteArrayOutputStream：输入源和输出目标是字节数组的流\r\n+ DataInputStream/DataOutputStream：装饰类，按基本类型和字符串而非只是字节读写流；\r\n+ BufferedInputStream/BufferedOutputStream：装饰类，对输入输出提供缓冲功能。\r\n\r\n## InputStream/OutputStream\r\n\r\nInputStream的三个基本方法分别是\r\n\r\n```\r\npublic abstract int read() throws IOException; //从流中读取下一个字节，返回类型为int，但取值为0-255，当读到流末尾时，返回-1，如果流中没有数据则会阻塞直到数据到来、流关闭或者异常出现\r\npublic int read(byte b[]) throws IOException; //批量读取，一次性读取数组b的长度个字节，返回值为实际读取的字节个数，若刚开始读取时已经到达流结尾，那么返回-1，该方法有默认实现\r\npublic int read(byte b[], int off, int len) throws IOException; //批量读取的一个重载方法\r\n```\r\n\r\nOutputStream的三个基本方法分别是\r\n\r\n```\r\npublic abstract void write(int b) throws IOException; //向流中写一个字节，参数类型必须是int(其实只会用到低八位)\r\npublic void write(byte[] b) throws IOException; //批量写入，一次性写入数组b的长度个字节\r\npublic int read(byte[] b, int off, int len); //批量读取的一个重载方法\r\n```\r\n\r\n## FileInputStream/FileOutputStream\r\n\r\nFileInputStream的两个较为常用的构造方法\r\n\r\n```\r\npublic FileInputStream(File file, boolean append) throws FileNotFoundException //其中append为true表明追加，为false表明覆盖\r\npublic FileInputStream(String filePath) throws FileNotFoundException\r\n```\r\n\r\n用法如下\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStream;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        int data = 0;\r\n        int index = 0;\r\n        byte[] buffer = new byte[1024];\r\n        File file = null;\r\n        InputStream in = null;\r\n        try {\r\n            file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            in = new FileInputStream(file);\r\n            while ((data = in.read()) != -1) {\r\n                buffer[index++] = (byte)data;\r\n            }\r\n            System.out.println(new String(buffer, 0, index, \"utf-8\"));\r\n            in.close();\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n写入文件的代码为\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStream;\r\nimport java.nio.charset.Charset;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        File file = null;\r\n        OutputStream out = null;\r\n        try {\r\n            file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            out = new FileOutputStream(file, true); //追加\r\n            byte[] data = \"Hello, world\".getBytes(Charset.forName(\"utf-8\"));\r\n            out.write(data);\r\n            out.close();\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n## DataInputStream/DataOutputStream\r\n\r\n这两个是装饰类，他们接受一个已有的InputStream/OutputStream为构造方法的参数，通过他们写入或读取数据时，可以读取或写入指定类型的数据，类型如下\r\n\r\n```\r\nread/writeInt：读取或写入四个字节，先是高字节再是低字节；\r\nread/writeBoolean：写入一个字节，若值为true则写入1否则写入0\r\nread/writeUTF：将字符串按utf-8编码写入。\r\n...\r\n```\r\n\r\n需要注意的是这两个类写入的文件都是对应的二进制字节，也就是说打开文件是乱码的，但是读写均正常\r\n\r\n```\r\nimport java.io.DataInputStream;\r\nimport java.io.DataOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            File file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            DataOutputStream out = new DataOutputStream(new FileOutputStream(file));\r\n            List\u003cStudent\u003e list = Arrays.asList(new Student[] {\r\n                    new Student(18, \"张三\", 80.9d), new Student(17, \"李四\", 67.5d)\r\n            });\r\n            out.writeInt(list.size());\r\n            for (Student s : list) {\r\n                out.writeInt(s.getAge());\r\n                out.writeUTF(s.getName());\r\n                out.writeDouble(s.getScore());\r\n            }\r\n            out.close();\r\n            \r\n            List\u003cStudent\u003e students = new ArrayList\u003cStudent\u003e();\r\n            DataInputStream in = new DataInputStream(new FileInputStream(file));\r\n            int size = in.readInt();\r\n            for (int i = 0; i \u003c size; i++) {\r\n                Student s = new Student();\r\n                s.setAge(in.readInt());\r\n                s.setName(in.readUTF());\r\n                s.setScore(in.readDouble());\r\n                students.add(s);\r\n            }\r\n            for(Student s : students) {\r\n                System.out.println(s.getAge());\r\n                System.out.println(s.getName());\r\n                System.out.println(s.getScore());\r\n            }\r\n            in.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    \r\n    public static class Student {\r\n        int age;\r\n        String name;\r\n        double score;\r\n        public Student() {\r\n            \r\n        }\r\n        public Student(int age, String name, double score) {\r\n            this.age = age;\r\n            this.name = name;\r\n            this.score = score;\r\n        }\r\n        public void setAge(int age) {\r\n            this.age = age;\r\n        }\r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n        public void setScore(double score) {\r\n            this.score = score;\r\n        }\r\n        public int getAge() {\r\n            return age;\r\n        }\r\n        public String getName() {\r\n            return name;\r\n        }\r\n        public double getScore() {\r\n            return score;\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n写入的文件内容为\r\n\r\n```\r\n   \u0002   \u0012 \u0006寮犱笁@T9櫃櫃?   \u0011 \u0006鏉庡洓@P?  \r\n```\r\n\r\n读出的文件内容为\r\n\r\n```\r\n18\r\n张三\r\n80.9\r\n17\r\n李四\r\n67.5 \r\n```\r\n\r\n## BufferedInputStream/BufferedOutputStream\r\n\r\nFileInputStream/FileOutputStream没有缓冲，是按字节读取的，性能低，虽然可以按字节数组读取以提高性能，但是有时必须按字节读写，如果使用缓冲区的话就能很好的解决这个问题。\r\n\r\n使用BufferedInputStream/BufferedOutputStream时，只需要将FileInputStream/FileOutputStream对象作为参数传入构造方法即可。如下\r\n\r\n```\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.charset.Charset;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            File file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            BufferedOutputStream bufferedOut = new BufferedOutputStream(new FileOutputStream(file));\r\n            bufferedOut.write(\"Feily Zhang\\nHello , world\".getBytes(Charset.forName(\"utf8\")));\r\n            bufferedOut.close();\r\n            int size = 0;\r\n            byte[] buffer = new byte[1024];\r\n            BufferedInputStream bufferedIn = new BufferedInputStream(new FileInputStream(file));\r\n            size = bufferedIn.read(buffer);\r\n            System.out.println(new String(buffer, 0, size, \"utf-8\"));\r\n            bufferedIn.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nFeily Zhang\r\nHello , world\r\n```","cover":"/images/java.jpg","link":"review-at-the-byte-stream-of-java-file-operations.html","preview":"\u003cp\u003e这里Java以二进制字节的方式处理文件。\u003c/p\u003e\n","title":"再看Java文件操作之字节流"},{"content":"\r\n\r\n接口屏蔽了类型的差异性，只关注能力或者动作。比如说计算机USB接口，它只是定义了一个规则，并没有具体的实现(U盘)，但是却可以使得U盘与计算机交互，接口就是具备这样一种能力。\r\n\r\n简单来说接口的使用包括三方，一方是使用者、一方是接口，另一方是接口的实现。接口实现者实现了接口定义的规则，而使用者通过接口使用实现者提供的服务，这就是他们之间的关系。这样就会降低耦合性，把各部分独立出来。\r\n\r\n比如，我们以前的随机数服务为例，如下\r\n\r\n```\r\npublic interface HelloInterface {\r\n    public abstract Random createRandom();\r\n}\r\n```\r\n\r\n然后我们定义接口的实现者\r\n\r\n```\r\npublic class RealizeInterface implements HelloInterface {\r\n\r\n    @Override\r\n    public Random createRandom() {\r\n        return new Random();\r\n    }\r\n\r\n}\r\n```\r\n\r\n该实现者返回一个随机数类，该类的定义如下\r\n\r\n```\r\npublic class Random {\r\n    private int randomNum = (int) (50 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(randomNum);\r\n    }\r\n}\r\n```\r\n\r\n接口的使用者为\r\n\r\n```\r\npublic class Using {\r\n\r\n    public static void main(String[] args) {\r\n        HelloInterface hello = new RealizeInterface();\r\n        Random random = hello.createRandom();\r\n        random.printRandom();\r\n    }\r\n}\r\n```\r\n\r\n这就是接口的使用，也是面向接口编程，即我们所需要的服务全部是向接口索取，而非Random实体类，由于接口屏蔽了随机数的实现细节，那么我们获取到的随机数服务就是稳定的。\r\n\r\n这里的例子是IoC与DI的面向接口编程的例子，只是没有使用依赖注入与控制反转。\r\n\r\n下面说接口的一些细节\r\n\r\n第一、接口中可以定义变量\r\n\r\n变量的默认修饰符是public static final，引用方式为接口名.变量名。\r\n\r\n第二、接口可以继承其他接口\r\n\r\n接口可以继承其他接口，且可以是多继承，同样适用extends关键字\r\n\r\n第三、instanceof\r\n\r\n也可以使用instanceof判断某对象是否实现了某接口，使用方式为\r\n\r\n对象 instanceof 接口\r\n返回值是boolean型变量\r\n\r\n第四、Java8对接口的增强\r\n\r\nJava8中对接口进行了功能增强，使得接口可以定义静态方法和默认方法且都有实现体，金泰方法通过接口名调用，默认方法通过接口型的对象调用，且静态方法和默认方法都必须是public的\r\n\r\n以随机数这个例子说明之，改动接口的代码，添加默认方法和静态方法，如下\r\n\r\n```\r\npublic interface HelloInterface {\r\n    public abstract Random createRandom();\r\n    \r\n    public static void printmMathRandom() {\r\n        System.out.println(Math.random());\r\n    }\r\n    \r\n    public default void printRandomClassRandom() {\r\n        System.out.println(new java.util.Random().nextInt(10));\r\n    }\r\n}\r\n```\r\n\r\n主函数改一下\r\n\r\n```\r\npublic class Using {\r\n\r\n    public static void main(String[] args) {\r\n        HelloInterface hello = new RealizeInterface();\r\n        Random random = hello.createRandom();\r\n        random.printRandom();\r\n        hello.printRandomClassRandom();\r\n        HelloInterface.printmMathRandom();\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n16\r\n6\r\n0.31667981164852066\r\n```\r\n\r\n第五、Java9对接口的增强\r\n\r\nJava9去掉了接口的静态方法和默认方法是public的限制，可以是private，这样就便于同一个接口内的其余方法引用private修饰的方法代码。由于我是Java8,因此，这里无法演示。\r\n\r\n总结一下，面向接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，所以适合对大问题分而治之，与面向切面编程各有侧重。\r\n\r\n抽象类\r\n\r\n抽象类与具体类相对立又同一，抽象类只是无法创建对象，表达的是抽象的概念，除此之外与具体类并无差别，是用来继承的，也可以不继承直接通过main方法运行(一定是自身的main方法，因为因为无法创建对象，就无法在别的类的main方法中运行)。类因为抽象方法而抽象，没有抽象方法的抽象类是没意义的但是并不是错误的，也就是说抽象类中要有抽象方法(也可以没有)，但是抽象方法所在的类必须是抽象的，抽象类可以有非抽象方法的实现，抽象方法不能有方法体，可以有main方法，如下，我们定义一个计算图形面积和周长的抽象类\r\n\r\n我们先演示一下抽象类可以有main方法，但不能实例化，如果我们要运行抽象类的非抽象方法，那么就只能写为静态方法，如下\r\n\r\n```\r\npublic abstract class Shape {\r\n\r\n    public static float length = 10f;\r\n    public static float width = 20f;\r\n    \r\n    public static void area() {\r\n        System.out.println(length * width);\r\n    }\r\n    \r\n    public static void main(String[] args) {\r\n        area();    //200.0\r\n    }\r\n}\r\n```\r\n\r\n当然，这不是我们的重点，我们直接定义一个抽象类\r\n\r\n```\r\npublic abstract class Shape {\r\n    public abstract void calArea();\r\n    public abstract void calGirth();\r\n}\r\n```\r\n\r\n看起开好像与接口无异，你是正确的，现在确实是这样，我们还得继续，再声明类继承抽象类并直接main运行\r\n\r\n```\r\npublic class Square extends Shape {\r\n\r\n    float length, width;\r\n    \r\n    public Square(float length, float width) {\r\n        this.length = length;\r\n        this.width = width;\r\n    }\r\n    public void calArea() {\r\n        System.out.println(length * width);\r\n    }\r\n\r\n    public void calGirth() {\r\n        System.out.println((length + width) * 2);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Square s = new Square(10.0f, 20.0f);\r\n        s.calArea();\t//200.0\r\n        s.calGirth();\t//60.0\r\n    }\r\n}\r\n```\r\n\r\n看来确实与接口无异啊，只不过就是比接口高级一点，可以有默认方法实现(Java8中接口也有了)，可以有main方法(这个接口没有)。\r\n\r\n其实，接口与抽象类还是有去别的，抽象类抽象实体，而接口只抽象动作。\r\n\r\n还有二者其实是配合使用的，接口声明能力，抽象类提供默认实现(实现部分或者全部方法)，所以一个接口常常有一个抽象类相对应。那么逻辑现在就变成了，抽象类实现接口，原先的接口实现者现在继承抽象类，然后重写必要的方法供使用者使用，这是因为抽象类无法new对象，因此只能通过继承了抽象类的类来new对象，供接口使用者使用。\r\n\r\n内部类与包含它的外部类有着密切的关系，而与其他类关系不大，定义在类内部，可以实现对外的完全隐藏，代码上更为紧凑和简洁。不过，内部类，只是Java编译器的概念，在运行时每个类都会被编译为一个独立的类，拥有独立的字节码文件。\r\n\r\n内部类共有四种类型，分别是\r\n\r\n+ 静态内部类 \r\n+ 成员内部类 \r\n+ 方法内部类 \r\n+ 匿名内部类\r\n\r\n静态内部类带有static关键字，如下\r\n\r\n```\r\npublic class Outer {\r\n    private static int shared = 100;\r\n    public static class StaticInner {\r\n        public void innerMethod() {\r\n            System.out.println(\"inner \" + shared);\r\n        }\r\n    }\r\n    public void test() {\r\n        new StaticInner().innerMethod();\r\n    }\r\n}\r\n```\r\n\r\n静态内部类可以访问对应外部类的静态变量和方法，但不能访问实例变量和方法。静态内部类可以被其余外部类访问，访问方式是外部类.静态内部类的方式。\r\n\r\n成员内部类\r\n\r\n```\r\npublic class Outer {\r\n    private int a = 100;\r\n    public class Inner {\r\n        public void innerMethod() {\r\n            System.out.println(\"outer a \" + a);\r\n            Outer.this.action();\r\n        }\r\n    }\r\n    private void action() {\r\n        System.out.println(\"action\");\r\n    }\r\n    public void test() {\r\n        new Inner().innerMethod();\r\n    }\r\n}\r\n```\r\n\r\n与静态内部类的区别是少了static关键字，可以访问外部类的变量和方法，如果内部类方法与外部类方法重名那么可以通过外部类.this.外部类方法的形式访问外部类方法。\r\n\r\n方法内部类\r\n\r\n顾名思义，就是内部类定义在方法中，如下\r\n\r\n```\r\npublic class Outer {\r\n    private int a = 100;\r\n    public void test(final int param) {\r\n        final String str = \"hello\";\r\n        class Inner {\r\n            public void innerMethod() {\r\n                System.out.println(\"outer a \" + a);\r\n                System.out.println(\"param \" + param);\r\n                System.out.println(\"local var \" + str);\r\n            }\r\n        }\r\n        new Inner().innerMethod();\r\n    }\r\n}\r\n```\r\n\r\n如果包含内部类的方法是非静态方法，那么方法内部类可以访问方法之外外部类之内的非静态变量和方法；\r\n\r\n如果包含内部类的方法是静态方法，那么内部类只能访问外部类的静态变量和静态方法。\r\n\r\n方法内部类还可以访问方法的参数和方法中的局部变量，在Java8之前，这两种变量必须被声明为final，Java8之后不再要求，但变量不能重新赋值否则会编译错误。\r\n\r\n匿名内部类\r\n\r\n其语法为\r\n\r\n```\r\nnew 父类(参数列表) {\r\n\t//匿名内部类的实现部分\r\n}\r\n或者\r\nnew 父接口() {\r\n\t//匿名内部类的实现部分\r\n}\r\n```\r\n\r\n例如\r\n\r\n```\r\npublic class Outer {\r\n    public static void main(String[] args) {\r\n        Shape shape = new Shape() {\r\n            float length = 10f;\r\n            float width = 20f;\r\n            @Override\r\n            public void calArea() {\r\n                System.out.println(length * width);\r\n            }\r\n\r\n            @Override\r\n            public void calGirth() {\r\n                System.out.println((length + width) * 2);\r\n            }\r\n            \r\n        };\r\n        shape.calArea();\t//200.0\r\n        shape.calGirth();\t//60.0\r\n    }\r\n}\r\n```\r\n\r\n通过匿名类重写了抽象父类Shape的方法，那么由于重写方法使得Shape变成了形式上的抽象类实际上的抽象类，所以可以new对象，然后调用方法。","cover":"/images/java.jpg","link":"review-at-interfaces-abstract-classes-and-internal-classes.html","preview":"\u003cp\u003e接口屏蔽了类型的差异性，只关注能力或者动作; 而抽象类与接口的区别在于抽象类抽象实体，而接口只抽象动作。内部类与包含它的外部类有着密切的关系，而与其他类关系不大，定义在类内部，可以实现对外的完全隐藏，代码上更为紧凑和简洁。\u003c/p\u003e\n","title":"再看接口、抽象类与内部类"},{"content":"\r\n\r\n封装是对成员变量的包装和隐藏。实现封装首先要将被封装的属性设置为私有private，然后对其提供相应的set/get方法进行特定的访问，set方法之外的方法只能通过get方法读取到被private修饰的变量的值而无法修改，且只能通过get方法获取，这就是封装。通过一个例子说明一下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class People {\r\n\r\n    private String name;\r\n    private int age;\r\n    private String sex;\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n    \r\n    public void setSex(String sex) {\r\n        this.sex = sex;\r\n    }\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public int getAge() {\r\n        return age;\r\n    }\r\n    \r\n    public String getSex() {\r\n        return sex;\r\n    }\r\n    \r\n}\r\npackage springTest;\r\n\r\npublic class PeopleMain {\r\n\r\n    public static void main(String[] args) {\r\n        People people = new People();\r\n        // 只能通过set方法设置私有属性\r\n        people.setName(\"Feily Zhang\");\r\n        people.setAge(21);\r\n        people.setSex(\"man\");\r\n        // System.out.println(people.name + \" \" + people.age + \" \" + people.sex);  错误，私有属性只能通过get方法获取\r\n        System.out.println(people.getName() + \" \" + people.getAge() + \" \" + people.getSex());\r\n    }\r\n}\r\n```\r\n\r\n继承指的是子类可以继承父类的非私有属性和方法，在此之外，子类可以定义自己的和父类无关的属性和方法，换句话说就是既然已经有类有这个方法，而我正好要用这个方法，那么我就不用再写，直接extends，我自己就可以获得这个方法。\r\n\r\n需要特别注意的是，父类一定会有默认构造方法(即使没写那么编译期间也会填充一个)，子类可以在自己的构造方法(任意构造方法不一定是默认构造器)通过super()初始化父类构造器也可以不初始化交给编译器自动完成；但是如果父类有带参数的非默认构造器，那么子类必须在自己的构造器内通过super(参数)初始化父类，否则会报错。\r\n\r\n```\r\npublic class Animal {\r\n\r\n    private String animalName;\r\n    \r\n    public void setAnimalName(String animalName) {\r\n        this.animalName = animalName;\r\n    }\r\n    \r\n    public String getAnimalName() {\r\n        return animalName;\r\n    }\r\n    \r\n    public void say() {\r\n        System.out.println(animalName + \" , I am saying!\");\r\n    }\r\n    \r\n}\r\n```\r\n\r\n以上定义了一个Animal类，并封装了私有属性animalName，使得只能通过set和get方法来访问，我们接下来定义一个Dog类，该类extends了Animal类，那么只要其继承了Animal，就获得了Animal私有属性之外的所有属性和方法，如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Dog extends Animal{\r\n\r\n}\r\n```\r\n\r\n我们什么也不用写，因为通过extends已经获得了Animal的私有animalName之外所有属性和方法\r\n\r\n然后验证一下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class AnimalMain {\r\n\r\n    public static void main(String[] args) {\r\n        Dog dog = new Dog();\r\n        dog.setAnimalName(\"Dog\");\r\n        dog.say();\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nDog , I am saying!\r\n```\r\n\r\n如果我们不用继承的方式，那么等同于如下代码\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Dog{\r\n\r\n    private String dogName;\r\n    \r\n    public void setDogName(String dogName) {\r\n        this.dogName = dogName;\r\n    }\r\n    \r\n    public String getDogName() {\r\n        return dogName;\r\n    }\r\n    \r\n    public void say() {\r\n        System.out.println(dogName + \" , I am saying!\");\r\n    }\r\n}\r\n\r\npackage springTest;\r\n\r\npublic class AnimalMain {\r\n\r\n    public static void main(String[] args) {\r\n        Dog dog = new Dog();\r\n        dog.setDogName(\"Dog\");\r\n        dog.say();\r\n    }\r\n\r\n}\r\n```\r\n\r\n在我们已经有Animal的情况下，是不是就没有必要写Dog的重复代码？所以通过继承可以简化冗余代码。\r\n\r\n总体来说，继承还是比较常规的，就是子类没有必要写父类拥有的代码，直接拿来用就行了。但是，关于继承，还有如下注意点\r\n\r\n第一、关于构造方法\r\n\r\n父类一定会有默认构造方法(即使没写那么编译期间也会填充一个)，子类可以在自己的构造方法(任意构造方法不一定是默认构造器)通过super()初始化父类构造器也可以不初始化交给编译器自动完成；但是如果父类有带参数的非默认构造器，那么子类必须在自己的构造器内通过super(参数)初始化父类，否则会报错。\r\n\r\n在上面的例子中，父类没有写默认构造器，但是编译期间填充了一个，子类也没有构造器，但是运行成功了。这是因为父类的默认构造器子类不需要显式super，所以有没有构造器都无所谓。那我们改动一下。让父类拥有非默认构造器\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Animal {\r\n\r\n    private String animalName;\r\n    \r\n    public Animal(String animalName) {\r\n        this.animalName = animalName;\r\n    }\r\n    /*\r\n    public void setAnimalName(String animalName) {\r\n        this.animalName = animalName;\r\n    }\r\n    \r\n    public String getAnimalName() {\r\n        return animalName;\r\n    }\r\n    */\r\n    public void say() {\r\n        System.out.println(animalName + \" , I am saying!\");\r\n    }\r\n    \r\n}\r\n\r\npackage springTest;\r\n\r\npublic class Dog extends Animal{\r\n    /*\r\n    private String dogName;\r\n    \r\n    public void setDogName(String dogName) {\r\n        this.dogName = dogName;\r\n    }\r\n    \r\n    public String getDogName() {\r\n        return dogName;\r\n    }\r\n    \r\n    public void say() {\r\n        System.out.println(dogName + \" , I am saying!\");\r\n    }\r\n    */\r\n}\r\n```\r\n\r\n那么Dog类一定会提示你\r\n\r\n```\r\nImplicit super constructor Animal() is undefined for default constructor. Must define an explicit constructor\r\n```\r\n\r\n所以加上构造方法，如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Dog extends Animal{\r\n\r\n    public Dog(String animalName) {\r\n        super(animalName);\r\n    }\r\n    /*\r\n    private String dogName;\r\n    \r\n    public void setDogName(String dogName) {\r\n        this.dogName = dogName;\r\n    }\r\n    \r\n    public String getDogName() {\r\n        return dogName;\r\n    }\r\n    \r\n    public void say() {\r\n        System.out.println(dogName + \" , I am saying!\");\r\n    }\r\n    */\r\n}\r\n```\r\n\r\n再测试一下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class AnimalMain {\r\n\r\n    public static void main(String[] args) {\r\n        Dog dog = new Dog(\"Dog\");;\r\n        dog.say();\t//Dog , I am saying!\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n运行是没有问题的。所以，一定要注意。\r\n\r\n第二、关于构造方法调用方法\r\n\r\n构造方法调用方法应该尽可能避免，因为子类一旦重写这个方法，那么一旦子类重写的方法有变量参与，就会造成非预期结果，这是因为，在new子类的过程中是先初始化父类的，由于父类构造方法调用了方法，再由于子类重写了这个方法且有变量参与，那么由于该方法被重写，父类初始化的时候就调用重写后的方法，因为父类在子类之前被初始化，所以父类读取到的方法的变量就会是默认值(int为0).一个例子说明\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Base {\r\n\r\n    public Base() {\r\n        test();\r\n    }\r\n    \r\n    public void test() {\r\n        \r\n    }\r\n}\r\n```\r\n\r\n父类Base的构造方法调用了test方法\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Child extends Base {\r\n\r\n    private int a = 111;\r\n    public Child() {\r\n        \r\n    }\r\n    public void test() {\r\n        System.out.println(a);\r\n    }\r\n}\r\n```\r\n\r\n子类重写了test方法，导致new子类时先初始化父类，父类直接调用子类重写的test方法，由于子类还未new，那么a为0；等父类初始化之后，子类被new，那么调用test方法才会输出111\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        Child c = new Child();\t//0\r\n        c.test();\t//111\r\n    }\r\n\r\n}\r\n```\r\n\r\n但是为什么父类初始化的时候执行的是子类的test方法呢？怎么不执行父类自己的test？\r\n\r\n这牵扯到动态绑定和静态绑定的概念，Java中实例变量、静态变量、静态方法、private方法都是静态绑定的，其余均是动态绑定。静态绑定的话如果子类对象向上转型为父类对象那么子类重写的父类方法无效即向上转型的子类对象执行的是父类的方法，如果不转型那么执行的仍然是子类的方法。动态绑定中无论子类对象是否转型，(不管是父类还是子类)执行的都是重写后的子类的方法。\r\n\r\n第三、关于重名(重写)与静态绑定\r\n\r\n上面其实已经说了，静态绑定的概念，我们先看一下动态绑定，仍然看上面的例子，只不过我们增加一个转型\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        Child c = new Child();\r\n        Base b = c;\r\n        c.test();\r\n        b.test();\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n0\r\n111\r\n111\r\n```\r\n\r\n可以看出，执行的还是子类的方法\r\n\r\n说个题外话，为什么只有一个0，不是应该有两个吗？这是因为Child c = new Child()的时候父类已经被初始化，子类也被初始化，那么自然a的值为111而非0.\r\n\r\n再看一下静态绑定，如果我们子类重写父类的实例变量、静态变量、静态方法、private方法，那么如果转型就会调用父类的方法，不转型则是子类的方法，如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Base {\r\n\r\n    public String a = \"base\";\r\n    public static String b = \"static_base\";\r\n    \r\n    public static void staticTest() {\r\n        System.out.println(\"static_staticTest \" + b);\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class Child extends Base {\r\n\r\n    public String a = \"child\";\r\n    public static String b = \"static_child\";\r\n    \r\n    public static void staticTest() {\r\n        System.out.println(\"static_staticTest_child \" + b);\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        // 不转型，输出的就是子类的重写\r\n        Child c = new Child();\r\n        System.out.println(c.a);\r\n        c.staticTest();\r\n        //转型，输出的是父类的属性和方法\r\n        Base b = c;\r\n        System.out.println(b.a);\r\n        b.staticTest();\r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nchild\r\nstatic_staticTest_child static_child\r\nbase\r\nstatic_staticTest static_base\r\n```\r\n\r\n显而易见\r\n\r\n第四、重载时调用父类还是子类方法\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Base {\r\n    public int sum(int a, int b) {\r\n        System.out.println(\"base_int_int\");\r\n        return a + b;\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class Child extends Base {\r\n\r\n    public long sum(long a, long b) {\r\n        System.out.println(\"child_long_long\");\r\n        return a + b;\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        Child c = new Child();\r\n        int a = 1, b = 2;\r\n        System.out.println(c.sum(a, b));\r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nbase_int_int\r\n3\r\n```\r\n\r\n这是因为重载时是根据数据类型匹配方法的。由于Main方法中a和b后市int型参数，父类的参数都是int型，所以使用父类的方法，如果我们把main方法中的a和b改为long型参数，那么就会调用子类的方法，如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        Child c = new Child();\r\n        long a = 1L, b = 2L;\r\n        System.out.println(c.sum(a, b));\r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nchild_long_long\r\n3\r\n```\r\n\r\n第五、父子类型的转换\r\n\r\n子类型转为父类型称为向上转型，我们上面有涉及，向下转型(父类转型为子类)呢？\r\n\r\n语法上可以通过强制类型转换进行，但是不一定成功。\r\n\r\n一个父类的变量能不能转型为一个子类的变量，取决于这个父类变量的动态类型是不是这个子类或者这个子类的子类。\r\n\r\n比如\r\n\r\n```\r\nBase b = new Child();\r\nChild c = (Child) b;\r\n```\r\n\r\n这是可以成功的，因为父类Base的动态类型就是子类Child，所以可以成功\r\n\r\n但是\r\n\r\n```\r\nBase b = new Base();\r\nChild c = (Base) b;\r\n```\r\n\r\n这是会失败的，因为Base的动态类型不确定是不是Child\r\n\r\n另外，可以通过instanceof关键字查看父类能否转型为子类，如下\r\n\r\n```\r\npublic boolean canCast(Base b) {\r\n    return b instanceof Child;\r\n}\r\n```\r\n\r\n第六、可见性重写\r\n\r\n重写方法一般情况下不会修改父类方法的可见性，但是需要注意的是子类不能降低父类方法的可见性。\r\n\r\n可见性由高到低为：public、protected、private。\r\n\r\n第七、父类的final方法不能被继承\r\n\r\nfinal关键字可以修饰类、变量、方法，不能修饰接口，因为接口必须被实现才有意义，一旦声明为final就无法被其他类实现。\r\n\r\nfinal修饰的类不能被继承、修饰的方法和变量不能被重写。\r\n\r\n最后，通过一个例子来说明，继承的真谛：利用继承的特性，只写有必要的代码，没有必要且已经存在的代码直接继承调用即可。\r\n\r\n假定现在我们已经有了这个类\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Base {\r\n    protected int currentStep;\r\n    protected void step1() {\r\n        \r\n    }\r\n    protected void step2() {\r\n        \r\n    }\r\n    protected void action() {\r\n        this.currentStep = 1;\r\n        step1();\r\n        this.currentStep = 2;\r\n        step2();\r\n    }\r\n}\r\n```\r\n\r\n我们需要的是action里面的功能，发现完全满足，但是step1和step2并没有被实现，那么简单我们实现了这两个方法然后调用action即可。子类如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Child extends Base {\r\n\r\n    public void step1() {\r\n        System.out.println(\"Child step \" + this.currentStep);\r\n    }\r\n    \r\n    public void step2() {\r\n        System.out.println(\"Child step \" + this.currentStep);\r\n    }\r\n}\r\n```\r\n\r\n我们升级了父类方法的可见性，然后调用了父类的实例变量，请注意，我们并没有重写父类的实例变量，调用完全是可以的，那么我们不管是否向上转型，那么我们都会得到相同的结果\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        Child c = new Child();\r\n        c.action();\r\n        Base b = c;\r\n        b.action();\r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nChild step 1\r\nChild step 2\r\nChild step 1\r\nChild step 2\r\n```\r\n\r\n多态\r\n\r\n多态是基于继承的，多态存在的3个条件是\r\n\r\n+ 子类继承父类； \r\n+ 子类重写父类的方法； \r\n+ 父类引用指向子类对象\r\n\r\n就用之前的Animal举个例子\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Animal {\r\n    public void say() {\r\n    }\r\n}\r\n```\r\n\r\nAnimal我们定义一个空方法，类似于接口和抽象类，多态我们一般都是这么做\r\n\r\n再定义Cat和Dog，分别继承Animal，这是多态的第一个条件，然后重写say方法，这是第二个条件\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Dog extends Animal{\r\n\r\n    String dogName;\r\n    \r\n    public Dog(String dogName) {\r\n        this.dogName = dogName;\r\n    }\r\n    public void say() {\r\n        System.out.println(\"I am a \" + dogName);\r\n    }\r\n\r\n}\r\npackage springTest;\r\n\r\npublic class Cat extends Animal{\r\n\r\n    String catName;\r\n    \r\n    public Cat(String catName) {\r\n        this.catName = catName;\r\n    }\r\n    \r\n    public void say() {\r\n        System.out.println(\"I am a \" + catName);\r\n    }\r\n}\r\n```\r\n\r\n主文件中，向上转型为Animal，这是多态的第三个条件，即父类引用指向子类对象，如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class AnimalMain {\r\n\r\n    public static void main(String[] args) {\r\n        Animal dog = new Dog(\"dog\");\r\n        dog.say();\r\n        Animal cat = new Cat(\"cat\");\r\n        cat.say();\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nI am a dog\r\nI am a cat\r\n```\r\n\r\n好吧，你可能说也没见多态有什么威力呀，不用转型照样可以实现需求啊。主要是这样更加规范和便于理解\r\n\r\n改造一下，我们再抽象一个动物管理员出来\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class AnimalManager {\r\n\r\n    private static final int MAX_NUM = 100;\r\n    private Animal[] animals = new Animal[MAX_NUM];\r\n    private int animalNum = 0;\r\n    \r\n    public void addAnimal(Animal animal) {\r\n        if (animalNum \u003c MAX_NUM) { \r\n            animals[animalNum++] = animal; \r\n        } \r\n    } \r\n\t\r\n    public void say() { \r\n        for(Animal animal : animals) { \r\n            animal.say(); \r\n        }\r\n    }\r\n}\r\n```\r\n\r\n相应的主文件为\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class AnimalMain {\r\n\r\n    public static void main(String[] args) {\r\n        AnimalManager am = new AnimalManager();\r\n        am.addAnimal(new Dog(\"dog\"));\r\n        am.addAnimal(new Cat(\"cat\"));\r\n        am.say();\r\n    }\r\n\r\n}\r\n```\r\n\r\n便于管理，可拓展性极强。\r\n\r\n变量Animal可以引用任何Animal子类类型的对象，这叫多态，即一种类型的变量，可以引用多种实际类型对象。这样，对于类型Animal，我们称之位animal的静态类型，而Dog、Cat等，我们称之为animal的动态类型，AnimalManager的say方法调用的是其对应的动态类型(如Dog、Cat)的say方法，这称之为动态绑定。\r\n\r\n多态和动态绑定是计算机程序的一种重要的思维方式，使得操作对象的程序不需要关注对象的实际类型，因为被父类统一起来了，这样就可以同意处理不同的对象，而且能够实现每个对象的特有行为。\r\n\r\n总而言之，多态就是同一个类型在不同的指向下有不同的状态，所谓状态就是特定的属性和行为。","cover":"/images/java.jpg","link":"review-encapsulation-inheritance-and-polymorphism.html","preview":"\u003cp\u003e封装是对成员变量的包装和隐藏；继承指的是子类可以继承父类的非私有属性和方法，在此之外，子类可以定义自己的和父类无关的属性和方法；多态是基于继承的。\u003c/p\u003e\n","title":"再看封装、继承和多态"},{"content":"\r\n\r\n面向接口编程通过结合IoC和DI，使得耦合性相当低，可拓展性极强，实现了低耦合高内聚，但是这种编程方式是对功能性主业务需求的分而治之，对于一些非功能性的需求则显得力不从心，比如日志、安全、事务、性能统计等次要但很必要的功能就显得不够省力。\r\n\r\n我们在软件系统设计的时候，一项很重要的工作就是把一个大系统按业务功能分解成一个个低耦合、高内聚的模块，分而治之，但是分解之后就会发现，有些非功能性需求的东西是通用的或者说是跨越多个模块的，即多个模块都需要，比如\r\n\r\n1. 日志：对特定的操作输出日志来记录； \r\n2. 安全：在执行操作之前进行权限的检查； \r\n3. 事务：在方法开始之前要开始事务，在方法结束之后要提交或者回滚事务；\r\n4. 性能统计：统计每个方法的执行时间\r\n5. ......\r\n\r\n这些多个模块都需要的非功能性需求用面向接口编程的方式实现是很不优雅的，但是用面向切面的编程方式来实现则方便很多。\r\n\r\n主业务功能性需求我们可以看作是一个个面，每层叠加在一起构成了一个面包，这个面包就是整个需求，由于每个面都需要一些非功能性需求(诸如日志、安全等等)，那么这些需求就像一个切面一样贯穿到了主业务需求的每层面包当中，即非功能性代码与业务代码的关注点不同，业务代码的关注点是必要性功能的实现(面向接口更简单，强调的是可拓展性)，非功能性代码的关注点是通用性非必要功能的实现，采用面向切面的方式更简单，即非功能性代码与业务代码之间应该是正交的(垂直的)。\r\n\r\n把通用性非功能性代码的实现方式就叫做面向切面编程，切面是贯穿于业务代码的。这就是AOP\r\n\r\n先说明几个简单的概念\r\n\r\n1. 切入点或连接点：如果切面要切入业务代码的某个方法，那么这个方法就是切面的切入点； \r\n2. 通知：由于切面是对业务代码通用性非必要功能的抽象，那么以日志为例，比如日志切面要切入业务需求User类的print()方法，那么就要在该方法执行之前和之后记录日志，这就要用到通知，通知就是对切入方法的前置、后置和环绕等操作；\r\n3. 目标：即切面切入的方法所在的类就是目标，例如User类就是目标。\r\n\r\n通过一个简单的例子来说明之\r\n\r\nUser类如下，该类通过Setter方式接受参数创建bean\r\n```\r\npackage springTest;\r\n\r\npublic class User {\r\n    \r\n    String userName;\r\n    \r\n    public void setUserName(String userName) {\r\n        this.userName = userName;\r\n    }\r\n    \r\n    public String getUserName() {\r\n        return userName;\r\n    }\r\n    \r\n    public void print() {\r\n        System.out.println(\"I am \" + userName);\r\n    }\r\n    \r\n}\r\n```\r\n配置文件如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\" \r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"             \r\n    xsi:schemaLocation=\"                                               \r\n            http://www.springframework.org/schema/beans \r\n            http://www.springframework.org/schema/beans/spring-beans.xsd    \r\n            http://www.springframework.org/schema/context     \r\n            http://www.springframework.org/schema/context/spring-context.xsd    \r\n            http://www.springframework.org/schema/mvc    \r\n            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \r\n            http://www.springframework.org/schema/tx   \r\n            http://www.springframework.org/schema/tx/spring-tx.xsd  \r\n            http://www.springframework.org/schema/aop  \r\n            http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e\r\n\u003cbean id=\"u\" class=\"springTest.User\"\u003e\r\n    \u003cproperty name=\"userName\" value=\"Java\"/\u003e\t\u003c!-- 传递参数创建bean --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n主文件如下\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class UserMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/userBean.xml\");\r\n        User user = (User) factory.getBean(\"u\");\r\n        user.print();\r\n    }\r\n\r\n}\r\n```\r\n运行结果为\r\n```\r\nI am Java\r\n```\r\n假如我们现在要给目标User类的print方法记录操作日志，那么就需要一个切面，定义如下\r\n```\r\npackage springTest;\r\n\r\nimport java.util.Date;\r\n\r\npublic class Log {\r\n\r\n    public void beforeExecute() {\r\n        System.out.println(\"Log : \" + new Date() + \"User类的print方法即将执行\");\r\n    }\r\n    \r\n    public void afterExecute() {\r\n        System.out.println(\"Log : \" + new Date() + \"User类的print方法已经执行\");\r\n    }\r\n}\r\n```\r\n可以看出，其实就是一个简单的Java类，定义了两个方法，在目标方法执行之前执行beforeExecute()方法记录日志，在目标方法执行之后执行afterExecute()方法记录日志，但是并没有看到切面Log作用在目标User类之上啊？？？稍安勿躁，这些都是配置文件完成的，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\" \r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"             \r\n    xsi:schemaLocation=\"                                               \r\n            http://www.springframework.org/schema/beans \r\n            http://www.springframework.org/schema/beans/spring-beans.xsd    \r\n            http://www.springframework.org/schema/context     \r\n            http://www.springframework.org/schema/context/spring-context.xsd    \r\n            http://www.springframework.org/schema/mvc    \r\n            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \r\n            http://www.springframework.org/schema/tx   \r\n            http://www.springframework.org/schema/tx/spring-tx.xsd  \r\n            http://www.springframework.org/schema/aop  \r\n            http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e\r\n\u003cbean id=\"u\" class=\"springTest.User\"\u003e\r\n    \u003cproperty name=\"userName\" value=\"Java\"/\u003e\r\n\u003c/bean\u003e\r\n\u003cbean id=\"log\" class=\"springTest.Log\"/\u003e\r\n\u003caop:config proxy-target-class=\"true\" \u003e\r\n\u003caop:aspect ref=\"log\"\u003e\r\n    \u003caop:pointcut id=\"place-order\" expression=\"execution( * springTest.User.print(..))\"/\u003e\r\n    \u003caop:before pointcut-ref=\"place-order\" method=\"beforeExecute\"/\u003e\r\n    \u003caop:after pointcut-ref=\"place-order\" method=\"afterExecute\"/\u003e\r\n\u003c/aop:aspect\u003e\r\n\u003c/aop:config\u003e\r\n\u003c/beans\u003e\r\n```\r\n我们通过`\u003cbean id=\"log\" class=\"springTest.Log\"/\u003e`创建了切面Log的bean实例，然后通过`\u003caop:aspect ref=\"log\"\u003e`将切面Log的实例log作为切面，然后定义切入点pointcut为sprintTest包内User类的print方法(代号为place-order)，即切面作用于该方法，只通知该方法，然后对该切入点place-order绑定前置和后置操作，即beforeExecute方法和afterExecute方法记录User类print方法的日志\r\n\r\n其余代码不变，然后运行，结果为\r\n```\r\nLog : Thu Dec 13 19:57:21 CST 2018User类的print方法即将执行\r\nI am Java\r\nLog : Thu Dec 13 19:57:21 CST 2018User类的print方法已经执行\r\n```\r\n很明显，日志记录成功。\r\n\r\n如果我们要监控User类中的其他方法那怎么办？\r\n\r\n我们不妨再给User类中再增加两个方法，如下\r\n```\r\npackage springTest;\r\n\r\npublic class User {\r\n    \r\n    String userName;\r\n    \r\n    public void setUserName(String userName) {\r\n        this.userName = userName;\r\n    }\r\n    \r\n    public String getUserName() {\r\n        return userName;\r\n    }\r\n    \r\n    public void print() {\r\n        System.out.println(\"I am \" + userName);\r\n    }\r\n    \r\n    public void print1() {\r\n        System.out.println(\"I am \" + userName + \" 1\");\r\n    }\r\n\r\n    public void print2() {\r\n        System.out.println(\"I am \" + userName + \" 2\");\r\n    } \r\n}\r\n```\r\n其实我们只需要修改配置文件切面的作用域即可，如下\r\n```\r\n\u003caop:pointcut id=\"place-order\" expression=\"execution( * springTest.User.*(..))\"/\u003e\r\n```\r\n然后再在主文件中调用一下其余两个方法就可以看到效果了\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class UserMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/userBean.xml\");\r\n        User user = (User) factory.getBean(\"u\");\r\n        user.print();\r\n        user.print1();\r\n        user.print2();\r\n    }\r\n\r\n}\r\n```\r\n结果为\r\n```\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法即将执行\r\nI am Java\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法已经执行\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法即将执行\r\nI am Java 1\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法已经执行\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法即将执行\r\nI am Java 2\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法已经执行\r\n```\r\n怎么样，简单吧？如果要给其它类也要记录日志怎么办？同样修改作用域，将类名部分用通配符*代替即可。\r\n\r\n这是一个较为简单优雅的AOP实例，还有一个更为复杂的，不妨也看一下(这个是真的复杂)\r\n\r\n假定我们现在有一个银行账户Account类，里面有add和minus方法，要给这两个方法加日志功能，包括前置、后置和环绕操作，那么首先要先定义一个Account接口\r\n```\r\npackage springTest;\r\n\r\npublic interface Account {\r\n    void add(int money);\r\n    void minus(int money);\r\n}\r\n```\r\n再实现这个接口\r\n```\r\npackage springTest;\r\n\r\npublic class AccountImpl implements Account {\r\n\r\n    private String name;\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    @Override\r\n    public void add(int money) {\r\n        System.out.println(\"给\" + name + \"账户加钱\" + money + \"元\");\r\n    }\r\n\r\n    @Override\r\n    public void minus(int money) {\r\n        System.out.println(\"给\" + name + \"账户扣钱\" + money + \"元\");\r\n    }\r\n\r\n}\r\n```\r\n那么，我们切面的目标就是这个Account接口的实现类AccountImpl。接下来定义前置、后置和环绕类及方法，如下\r\n```\r\npackage springTest;\r\n\r\nimport java.lang.reflect.Method;\r\nimport org.springframework.aop.MethodBeforeAdvice;\r\n\r\n\r\npublic class BeforeAdvice implements MethodBeforeAdvice {\r\n\r\n    public void before(Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用前\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n    }\r\n}\r\n\r\npackage springTest;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\npublic class AfterAdvice implements org.springframework.aop.AfterAdvice {\r\n\r\n    public void afterReturning(Object returnValue, Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用后\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n        \r\n    }\r\n}\r\n\r\npackage springTest;\r\n\r\nimport org.aopalliance.intercept.MethodInterceptor;\r\nimport org.aopalliance.intercept.MethodInvocation;\r\n\r\npublic class AroundInterceptor implements MethodInterceptor {\r\n\r\n    @Override\r\n    public Object invoke(MethodInvocation arg0) throws Throwable {\r\n        System.out.println(\"调用方法之前：invocation对象：[\"+ arg0 + \"]\");\r\n        Object rval = arg0.proceed();\r\n        System.out.println(\"调用结束...\");\r\n        return rval;\r\n    }\r\n\r\n}\r\n```\r\n主文件为\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class AOPMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/AOPBean.xml\");\r\n        Account account = (Account) factory.getBean(\"account\");\r\n        System.out.println(\"第一个add方法\");\r\n        account.add(100);\r\n        System.out.println(\"第二个minus方法\");\r\n        account.minus(200);\r\n    }\r\n\r\n}\r\n```\r\n同样的，通过配置文件绑定切面和目标，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\r\n\u003c!-- 先给目标对象注入参数以创建bean --\u003e\r\n\u003cbean id=\"accountTarget\" class=\"springTest.AccountImpl\"\u003e\r\n    \u003cproperty name=\"name\" value=\"Java\" /\u003e\r\n\u003c/bean\u003e\r\n\r\n\u003c!-- 再配置前置、环绕bean --\u003e\r\n\u003cbean id=\"myBeforeAdvice\" class=\"springTest.BeforeAdvice\"/\u003e\r\n\u003cbean id=\"myAroundInterceptor\" class=\"springTest.AroundInterceptor\"/\u003e\r\n\r\n\u003c!-- 后置bean比较特殊，将20行的后置bean包装在id为addAdvisor的bean当中，并指定patterns使该后置bean只作用在add方法上，对其他方法没有作用 --\u003e\r\n\u003cbean id=\"addAdvisor\" class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\"\u003e\r\n    \u003cproperty name=\"advice\"\u003e\r\n        \u003cbean class=\"springTest.AfterAdvice\"/\u003e\r\n    \u003c/property\u003e\r\n    \u003cproperty name=\"patterns\"\u003e\r\n        \u003clist\u003e\r\n            \u003cvalue\u003e.*add*.\u003c/value\u003e\t\u003c!-- 只对add方法管用 --\u003e\r\n        \u003c/list\u003e\r\n    \u003c/property\u003e\r\n\u003c/bean\u003e\r\n\r\n\u003c!-- 以上是配置前后置及环绕bean --\u003e\r\n\u003c!-- 以下是绑定切面(通知)和目标 --\u003e\r\n\r\n\u003cbean id=\"account\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"\u003e\r\n    \u003cproperty name=\"proxyInterfaces\" value=\"springTest.Account\"/\u003e\r\n    \u003cproperty name=\"target\"\u003e\t\u003c!-- 切面的目标是id为accountTarget的bean类，即上面定义的 --\u003e\r\n        \u003cref bean=\"accountTarget\"/\u003e\r\n    \u003c/property\u003e\r\n    \u003cproperty name=\"interceptorNames\"\u003e\t\u003c!-- 拦截器列表，对目标方法拦截以记录日志 --\u003e\r\n        \u003clist\u003e\r\n            \u003cvalue\u003emyBeforeAdvice\u003c/value\u003e\r\n            \u003cvalue\u003emyAroundInterceptor\u003c/value\u003e\r\n        \u003c/list\u003e\r\n    \u003c/property\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n执行结果为\r\n```\r\n第一个add方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.add(int)\r\n方法的参数是100\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.add(int); target is of class [springTest.AccountImpl]]\r\n给Java账户加钱100元\r\n调用结束...\r\n第二个minus方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.minus(int)\r\n方法的参数是200\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.minus(int); target is of class [springTest.AccountImpl]]\r\n给Java账户扣钱200元\r\n调用结束...\r\n```\r\n很明显，这种方法很繁琐，我们完全可以将其改造一下，如下\r\n\r\n目标类Account，为了与上文区分(下同)，我们定义为Accounts，如下\r\n```\r\npackage springTest;\r\n\r\npublic class Accounts {\r\n\r\n    private String name;\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    public void add(int money) {\r\n        System.out.println(\"给\" + name + \"账户加钱\" + money + \"元\");\r\n    }\r\n\r\n    public void minus(int money) {\r\n        System.out.println(\"给\" + name + \"账户扣钱\" + money + \"元\");\r\n    }\r\n\r\n}\r\n```\r\n切面类，我们定义为AccountsLog，如下\r\n```\r\npackage springTest;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\nimport org.aopalliance.intercept.MethodInterceptor;\r\nimport org.aopalliance.intercept.MethodInvocation;\r\nimport org.springframework.aop.MethodBeforeAdvice;\r\n\r\npublic class AccountsLog implements \r\n    MethodBeforeAdvice, org.springframework.aop.AfterAdvice, MethodInterceptor {\r\n\r\n    @Override\r\n    public Object invoke(MethodInvocation arg0) throws Throwable {\r\n        System.out.println(\"调用方法之前：invocation对象：[\"+ arg0 + \"]\");\r\n        Object rval = arg0.proceed();\r\n        System.out.println(\"调用结束...\");\r\n        return rval;\r\n    }\r\n\r\n    @Override\r\n    public void before(Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用前\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n    }\r\n\r\n\r\n    public void afterReturning(Object returnValue, Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用后\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n        \r\n    }\r\n}\r\n```\r\n该类实现了三个接口，分别是前置，后置和环绕接口，因为我们要拿到相应的参数，所以必须实现接口并重写方法，如果不拿参数，自己写即可不需要实现接口\r\n\r\n配置文件为\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\" \r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"             \r\n    xsi:schemaLocation=\"                                               \r\n            http://www.springframework.org/schema/beans \r\n            http://www.springframework.org/schema/beans/spring-beans.xsd    \r\n            http://www.springframework.org/schema/context     \r\n            http://www.springframework.org/schema/context/spring-context.xsd    \r\n            http://www.springframework.org/schema/mvc    \r\n            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \r\n            http://www.springframework.org/schema/tx   \r\n            http://www.springframework.org/schema/tx/spring-tx.xsd  \r\n            http://www.springframework.org/schema/aop  \r\n            http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e\r\n\u003cbean id=\"acc\" class=\"springTest.Accounts\"\u003e\r\n    \u003cproperty name=\"userName\" value=\"Java\"/\u003e\r\n\u003c/bean\u003e\r\n\u003cbean id=\"log\" class=\"springTest.AccountsLog\"/\u003e\r\n\u003caop:config proxy-target-class=\"true\" \u003e\r\n\u003caop:aspect ref=\"log\"\u003e\r\n    \u003caop:around pointcut=\"execution(* springTest.Accounts.*(..))\" method=\"invokev\" /\u003e\r\n    \u003caop:before pointcut=\"execution(* springTest.Accounts.*(..))\" method=\"before\"/\u003e\r\n    \u003caop:after pointcut=\"execution(* springTest.Accounts.*(..))\" method=\"afterReturning\"/\u003e\r\n\u003c/aop:aspect\u003e\r\n\u003c/aop:config\u003e\r\n\u003c/beans\u003e\r\n```\r\n这次我们并没有像第一个例子一样单独定义切入点，而是对不同的通知类型单独定义，其实完全可以提出来，这样做是为了演示这种方式，主文件为\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class AccountsMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/accountsBean.xml\");\r\n        Account account = (Account) factory.getBean(\"account\");\r\n        System.out.println(\"第一个add方法\");\r\n        account.add(100);\r\n        System.out.println(\"第二个minus方法\");\r\n        account.minus(200);\r\n    }\r\n\r\n}\r\n```\r\n运行结果为\r\n```\r\n第一个add方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.add(int)\r\n方法的参数是100\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.add(int); target is of class [springTest.AccountImpl]]\r\n给Java账户加钱100元\r\n调用结束...\r\n第二个minus方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.minus(int)\r\n方法的参数是200\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.minus(int); target is of class [springTest.AccountImpl]]\r\n给Java账户扣钱200元\r\n调用结束...\r\n```\r\n怎么样？完美无缺！！！\r\n\r\n需要特别注意的是AOP的使用，不仅仅要用Spring官方给出的jar，还需要两个jar，分别从这里下载\r\n\r\n+ [https://www.findjar.com/jar/aopalliance/jars/aopalliance-1.0.jar.html](https://www.findjar.com/jar/aopalliance/jars/aopalliance-1.0.jar.html)\r\n+ [http://maven.outofmemory.cn/org.aspectj/aspectjweaver/1.7.4/](http://maven.outofmemory.cn/org.aspectj/aspectjweaver/1.7.4/)\r\n","cover":"/images/Spring-Framework.jpg","link":"analysis-of-aspect-oriented-programming.html","preview":"\u003cp\u003e把通用性非功能性代码的实现方式就叫做面向切面编程，切面是贯穿于业务代码的，这就是AOP。\u003c/p\u003e\n","title":"面向切面编程(Aspect Oriented Programming)浅析"},{"content":"\r\n\r\n第一种方式，(无参创建)通过无参构造器创建一个bean实例\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n\t/*\r\n    public Product() {\r\n        \r\n    }*/\r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am product1!\");\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am product2!\");\r\n    }\r\n}\r\n```\r\n其中默认构造器可以省略，即使没有那么Java类在编译期间也会自动填充一个默认构造器\r\n\r\n然后是配置文件\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"/\u003e\r\n\u003c/beans\u003e\r\n```\r\n再是主方法类\r\n```\r\nackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class ProductMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/productBean.xml\");\r\n        Product product = (Product) factory.getBean(\"pro\", Product.class);\r\n        product.printProduct1();\r\n        product.printProduct2();\r\n    }\r\n}\r\n```\r\n运行结果为\r\n```\r\nHello, I am product1!\r\nHello, I am product2!\r\n```\r\n这里并不会牵扯到依赖注入，因为只是一个类，并没有类之间的依赖关系，所以和正常的Java类一样，不需要编写依赖注入时被注入类的set/get方法。\r\n\r\n但是如果类有构造器而且不是默认构造器，该怎么办？用第一种方法是会报错的，如下\r\n```\r\nException in thread \"main\" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'pro' defined in class path resource [springTest/productBean.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [springTest.Product]: No default constructor found; nested exception is java.lang.NoSuchMethodException: springTest.Product.()\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1076)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1021)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:504)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:302)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:298)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:703)\r\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)\r\n\tat org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:139)\r\n\tat org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:83)\r\n\tat springTest.ProductMain.main(ProductMain.java:9)\r\nCaused by: org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [springTest.Product]: No default constructor found; nested exception is java.lang.NoSuchMethodException: springTest.Product.()\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:85)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1069)\r\n\t... 13 more\r\nCaused by: java.lang.NoSuchMethodException: springTest.Product.()\r\n\tat java.lang.Class.getConstructor0(Unknown Source)\r\n\tat java.lang.Class.getDeclaredConstructor(Unknown Source)\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:80)\r\n\t... 14 more\r\n```\r\n这种情况下第二种方法就显得很有必要了\r\n\r\n第二种方法，(有参通过构造器创建)通过配置文件向构造器传递参数实例化bean\r\n\r\n我们先将Product类改为有构造器参与的形式\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n    \r\n    String product1;\r\n    String product2;\r\n    \r\n    public Product(String product1, String product2) {\r\n        this.product1 = product1;\r\n        this.product2 = product2;\r\n    }\r\n    \r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am \" + product1);\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am \" + product2);\r\n    } \r\n}\r\n```\r\n再通过配置文件传递参数实例化bean(其实就是实例化类)\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cconstructor-arg index=\"0\" value=\"product1\"/\u003e\r\n    \u003cconstructor-arg index=\"1\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n以上配置文件的bean标签的constructor-arg标签的index属性等同于name属性，如下\r\n```\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cconstructor-arg name=\"product1\" value=\"product1\"/\u003e\r\n    \u003cconstructor-arg name=\"product2\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\n```\r\n是同样的功能\r\n\r\n再运行之\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class ProductMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/productBean.xml\");\r\n        Product product = (Product) factory.getBean(\"pro\", Product.class);\r\n        product.printProduct1();\r\n        product.printProduct2();\r\n    }\r\n}\r\n```\r\n结果为\r\n```\r\nHello, I am product1\r\nHello, I am product2\r\n```\r\n当然这只是向一个bean传递参数的一种方式，还有一种方式是通过Setter方式\r\n\r\n第三种，(有参通过Setter方式创建)通过Setter方式传递参数给bean创建其实例\r\n\r\n这种方法自然要对相应的字段编写对应的get/set方法，如下\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n    \r\n    String product1;\r\n    String product2;\r\n    /*\r\n    public Product(String product1, String product2) {\r\n        this.product1 = product1;\r\n        this.product2 = product2;\r\n    }\r\n    */\r\n    public String getProduct1() {\r\n        return product1;\r\n    }\r\n    \r\n    public String getProduct2() {\r\n        return product2;\r\n    }\r\n    \r\n    public void setProduct1(String product1) {\r\n        this.product1 = product1;\r\n    }\r\n    \r\n    public void setProduct2(String product2) {\r\n        this.product2 = product2;\r\n    }\r\n    \r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am \" + product1);\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am \" + product2);\r\n    } \r\n}\r\n```\r\n配置文件只需要把constructor-arg标签改为property即可，如下\r\n```\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cproperty name=\"product1\" value=\"product1\"/\u003e\r\n    \u003cproperty name=\"product2\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\n```\r\n主文件不做改动，仍然是同样的运行结果\r\n\r\n这种情况下你可以注释掉构造器，前提是你没有使用constructor-arg标签传递参数。当然，你也可以二者都使用，如下\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n    \r\n    String product1;\r\n    String product2;\r\n    \r\n    public Product(String product1) {\r\n        this.product1 = product1;\r\n    }\r\n    \r\n    public String getProduct2() {\r\n        return product2;\r\n    }\r\n    public void setProduct2(String product2) {\r\n        this.product2 = product2;\r\n    }\r\n    \r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am \" + product1);\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am \" + product2);\r\n    } \r\n}\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cconstructor-arg name=\"product1\" value=\"product1\"/\u003e\r\n    \u003cproperty name=\"product2\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class ProductMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/productBean.xml\");\r\n        Product product = (Product) factory.getBean(\"pro\", Product.class);\r\n        product.printProduct1();\r\n        product.printProduct2();\r\n    }\r\n}\r\n```\r\n此外，这里配置文件的属性用的是name而不是id，这两者都可以用而且主文件中`factory.getBean(\"pro\", Product.class)`与`factory.getBean(\"pro\")`是同样的功能，可以自由组合。","cover":"/images/Spring-Framework.jpg","link":"several-ways-to-create-bean-instances-in-spring.html","preview":"\u003cp\u003e无参默认构造器、有参自定义构造器、有参通过Setter方式创建。\u003c/p\u003e\n","title":"Spring中创建Bean实例的几种方式"},{"content":"\r\n\r\n就是变动一下配置文件，改为\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e    \u003c!-- 注意注入类的id可以随意定义，无需与被注入类字段保持一致 -\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" /\u003e\r\n\u003ccontext:annotation-config /\u003e    \u003c!-- 注意这里的代码 --\u003e\r\n\u003c/beans\u003e\r\n```\r\n再在被注入类字段上进行注解\r\n```\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\npublic class SayHello {\r\n    \r\n    @Autowired\r\n    private HelloWorldSpring helloWorldSpring;\r\n    public HelloWorldSpring getHelloWorldSpring() {\r\n        return helloWorldSpring;\r\n    }\r\n    public void setHelloWorldSpring(HelloWorldSpring helloWorldSpring) {\r\n        this.helloWorldSpring = helloWorldSpring;\r\n    }\r\n    public void sayHello() {\r\n        System.out.println(\"Say Hello:\" + helloWorldSpring.sayHello());\r\n    }\r\n}\r\n```\r\n这种注入方式等同于autowire=\"byType\"。只不过尽可能少用这种方式，缺点如下\r\n\r\n+ 代码可读性差，不容易维护，因为类之间的依赖关系我们只能在代码中找\r\n+ 通用性不好，如果我们哪天不用Spring了，那么我们就得一个个删除注解。","cover":"/images/Spring-Framework.jpg","link":"spring-assembly-via-autowire-annotation.html","preview":"\u003cp\u003eAutowired按byType自动注入，而Resource默认按 byName自动注入。\u003c/p\u003e\n","title":"通过@Autowired注解进行Spring装配"},{"content":"\r\n\r\n先说明，以下是公用代码，只是配置文件不同\r\n```\r\npublic class HelloWorldSpring {\r\n    private String sayContent;\r\n    public String sayHello() {\r\n        System.out.println(\"HelloWorld Spring!\");\r\n        return \"HelloWorld Spring\";\r\n    }\r\n}\r\n\r\npublic class SayHello {\r\n    private HelloWorldSpring helloWorldSpring;\r\n    public HelloWorldSpring getHelloWorldSpring() {\r\n        return helloWorldSpring;\r\n    }\r\n    public void setHelloWorldSpring(HelloWorldSpring helloWorldSpring) {\r\n        this.helloWorldSpring = helloWorldSpring;\r\n    }\r\n    public void sayHello() {\r\n        System.out.println(\"Say Hello:\" + helloWorldSpring.sayHello());\r\n    }\r\n}\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"bean.xml\");\r\n        SayHello sayHello = (SayHello) factory.getBean(\"sayHello\");\r\n        sayHello.sayHello();\r\n    }\r\n\r\n}\r\n```\r\nSpring的注入方式有六种，比较常用的有三种自动装配\r\n\r\n第一种自动装配，当被注入类配置文件bean标签中属性autowire的取值为no时，表明不使用自动装配，即必须显式的使用\u003cref\u003e标签明确的指定注入的bean\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" autowire=\"no\"\u003e    \u003c!-- 请注意这里的autowire属性及其值 --\u003e\r\n    \u003cproperty name=\"helloWorldSpring\" ref=\"helloWorldSpring\"/\u003e    \u003c!-- 还有这里的property标签 --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n可见，这种方式无异于脱了裤子放屁，直接去掉autowire属性即可，就和前几篇文章用的注入方式一致\r\n\r\n第二种自动装配，当被注入类配置文件bean标签中属性autowire的取值为byName时，表明根据属性名自动装配，那么将会检查Spring容器，根据名字查找属性完全一致的Bean然后进行注入。简言之就是与被注入类中字段名称相同的配置文件中的bean标签的id值代表的class类对象将会被装配(注入)，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" autowire=\"byName\"\u003e    \u003c!-- 请注意这里的autowire属性及其值 --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n第三种自动装配，当被注入类配置文件bean标签中属性autowire的取值为byType时，表明按类型自动装配，即被注入类字段的数据类型(为类)与配置文件中bean标签的注入类class属性的类型名一致时，才会装配，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" autowire=\"byType\"\u003e    \u003c!-- 请注意这里的autowire属性及其值 --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n需要特别注意的是，被注入类中的相关字段一定要有对应的set方法(和get方法)，不然byName和byType会报错NPE,no和以前的那种装配方式则会报错如下\r\n```\r\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property 'helloWorldSpring' of bean class [SayHello]: Bean property 'helloWorldSpring' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\r\n```","cover":"/images/Spring-Framework.jpg","link":"three-other-common-ways-of-spring-injection-and-autowire.html","preview":"\u003cp\u003eSpring的注入方式有六种，比较常用的有三种自动装配。\u003c/p\u003e\n","title":"Spring注入的另外三种常用方式与AutoWire"},{"content":"\r\n\r\nSpring中读取配置文件的三种方式\r\n```\r\nResource res = new ClassPathResource(\"packageName/bean.xml\");\r\nBeanFactory factory = new XmlBeanFactory(res);    //通过XmlBeanFactory类读取\r\n\r\nApplicationContext factory = new ClassPathXmlApplicationContext(\"packageName/bean.xml\");    //通过ClassPathXmlApplicationContext类读取\r\n\r\nApplicationContext factory = new FileSystemXmlApplicationContext(new String[] {\"bean.xml的绝对路径\"})\r\n或者\r\nApplicationContext factory = new FileSystemXmlApplicationContext(\"bean.xml的绝对路径\")    //通过FileSystemXmlApplicationContext类读取\r\n```\r\n单例Bean就是Main文件在运行中只会得到一个Bean实例，即每次得到的Bean实例是相同的，也称无状态Bean，一般把公用的资源可以保存为单例Bean；\r\n\r\n多例Bean就是Main文件在运行中每getBean()都会得到一个截然不同的Bean实例，也称有状态Bean，那么就可以用有状态Bean来保存比较私有的资源。\r\n\r\n单例和多例Bean可以在配置文件中的bean标签中设置，需要特别注意的是，旧版Spring中是通过singleton属性来设置的，当值为true时为单例无状态Bean，当值为false时为多例有状态Bean；在新版Spring中，是通过scope属性来设置的，当值为prototype时为有状态多例Bean，当值为singleton时为单例无状态Bean。\r\n\r\n一个简单的例子来说明单例和多例Bean\r\n\r\n这是一个提供随机数的类\r\n```\r\npackage springTest;\r\n\r\npublic class Randoms {\r\n    private int i  = (int) (100 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(i);\r\n    }\r\n}\r\n```\r\n配置文件设置其为多例Bean，由于和其它类没有依赖关系，所以只需要定义bean即可，无需定义其他的属性\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"ran\" class=\"springTest.Randoms\" scope=\"prototype\"/\u003e\r\n\u003c/beans\u003e\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringRandoms {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/RandomsBean.xml\");\r\n        Randoms r1 = (Randoms)factory.getBean(\"ran\");\r\n        Randoms r2 = (Randoms)factory.getBean(\"ran\");\r\n        System.out.println(r1 == r2);\r\n        r1.printRandom();\r\n        r2.printRandom();\r\n    }\r\n\r\n}\r\n```\r\n运行结果为\r\n```\r\nfalse\r\n28\r\n15\r\n```\r\n通过配置文件将其设置为单例Bean，如下\r\n```\r\n\u003cbean id=\"ran\" class=\"springTest.Randoms\" scope=\"singleton\"/\u003e\r\n```\r\n那么运行结果为\r\n```\r\ntrue\r\n93\r\n93\r\n```","cover":"/images/Spring-Framework.jpg","link":"spring-reads-configuration-files-in-three-ways-single-and-multiple-beans.html","preview":"\u003cp\u003eSpring中读取配置文件的三种方式。\u003c/p\u003e\n","title":"Spring中读取配置文件的三种方式及单例多例Bean"},{"content":"\r\n\r\n所谓Spring依赖注入，指的是类之间对象实例的传递方式。传统的类间对象(或参数)传递是通过实例化一个类，然后将该对象传递给另一个类的方法,而依赖注入则是通过配置文件将一个类的实例直接传递给另一个类的变量或者方法，根本不用显式的new对象然后再作为参数传递。如下\r\n```\r\npublic class SayHello {\r\n    private HelloWorldSpring helloWorldSpring;\r\n    public HelloWorldSpring getHelloWorldSpring() {\r\n        return helloWorldSpring;\r\n    }\r\n    public void setHelloWorldSpring(HelloWorldSpring helloWorldSpring) {\r\n        this.helloWorldSpring = helloWorldSpring;\r\n    }\r\n    public void sayHello() {\r\n        System.out.println(\"Say Hello:\" + helloWorldSpring.sayHello());\r\n    }\r\n}\r\npublic class HelloWorldSpring {\r\n    private String sayContent;\r\n    public String sayHello() {\r\n        System.out.println(\"HelloWorld Spring!\");\r\n        return \"HelloWorld Spring\";\r\n    }\r\n}\r\npublic class HelloMain {\r\n\r\n    public static void main(String[] args) {\r\n        SayHello sayHello = new SayHello();\r\n        // new实例然后传递给调用者，耦合度高\r\n        sayHello.setHelloWorldSpring(new HelloWorldSpring());\r\n        sayHello.sayHello();\r\n    }\r\n\r\n}\r\n```\r\n以上HelloMain是传统的注入方式，明显耦合度高，但是依赖注入可不这么干，是通过配置文件来实现注入，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\"\u003e\r\n    \u003cproperty name=\"helloWorldSpring\" ref=\"helloWorldSpring\"/\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringMain {\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"bean.xml\");\r\n        SayHello sayHello = (SayHello) factory.getBean(\"sayHello\");\r\n        sayHello.sayHello();\r\n    }\r\n}\r\n```\r\n`ApplicationContext factory = new ClassPathXmlApplicationContext(\"bean.xml\")`读取配置文件，然后通过getBean()方法获取一个目标为sayHello的对象，其实就是通过配置文件实例化了SayHello类，sayHello对应bean.xml文件里的SayHello类的id。\r\n\r\n特别注意的是此处代码并没有在包中(一个空包，即文件头没有package声明)，所以bean文件中bean标签的class属性并没有加包名前缀，同理SpringMain读取配置文件也没有加包名路径。\r\n\r\n以上就是Spring依赖注入。\r\n\r\n至于Spring控制反转，则说的是类的实例化不用通过new显式的实现，而是将创建对象的控制权由自写代码交给Spring容器(或Spring jar包)，即控制反转。上述SpringMain可以明显的看出，sayHello对象的创建是通过`factory.getBean()`方法实现的，而不是new操作符。\r\n\r\n简言之，控制反转说的是类的初始化(创建)不用new而交给Spring容器，依赖注入说的是通过配置文件实现类间的对象传递。其目的就是解耦.\r\n\r\n再通过面向接口编程深入理解IoC与DI\r\n\r\n面向接口编程的本质是缩小修改的影响范围,先看一个实际的例子，有一个提供随机数生成的类，有一个专门使用随机数的类，如果用常规思维来实现的话，无非就是如下的代码\r\n```\r\npackage springTest;\r\n\r\npublic class Random {\r\n    private int randomNum = (int) (50 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(randomNum);\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class TestMain {\r\n    public static void main(String[] args) {\r\n        new Random().printRandom();\r\n    }\r\n}\r\n```\r\n而面向接口编程则是如下的代码\r\n\r\n先是接口，向外部调用者提供用于返回Random对象的createRandom方法\r\n```\r\npackage springTest;\r\n\r\npublic interface HelloInterface {\r\n    public abstract Random createRandom();\r\n}\r\n```\r\n再是接口的实现，外部调用者通过createRandom得到Random对象时，是直接和接口打交道，根本不知道有该实现类的存在\r\n```\r\npackage springTest;\r\n\r\npublic abstract class HelloAbstract implements HelloInterface {\r\n    @SuppressWarnings(\"unused\")\r\n    private Random random;\r\n    public void setRandom(Random random) {\r\n        this.random = random;\r\n    }\r\n    public abstract Random createRandom();\r\n}\r\n```\r\n实际上，该实现类就是在配置文件中直接将Random类注入到其中，由于实现类实现了接口，而实现类被注入了Random类，那么实现类就可以当作接口与Random类之间的桥梁，这个桥梁是通过配置文件依赖注入建造的。\r\n\r\nRandom类如下\r\n```\r\npackage springTest;\r\n\r\npublic class Random {\r\n    private int randomNum = (int) (50 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(randomNum);\r\n    }\r\n}\r\n```\r\nSpringMain如下\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringMain {\r\n    @SuppressWarnings(\"resource\")\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/bean.xml\");\r\n        HelloInterface hi = (HelloInterface) factory.getBean(\"hello\");\r\n        Random random = hi.createRandom();\r\n        random.printRandom();\r\n    }\r\n\r\n}\r\n```\r\n配置文件为\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"ran\" class=\"springTest.Random\"/\u003e\r\n\u003cbean id=\"hello\" class=\"springTest.HelloAbstract\"\u003e\r\n    \u003clookup-method name=\"createRandom\" bean=\"ran\"/\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n可见，是通过lookup-method标签将id为ran的bean注入到id为hello的bean的createRandom方法中，即createRandom方法的返回值就是这个id为ran的bean(对象)。","cover":"/images/Spring-Framework.jpg","link":"spring-dependency-injection-and-control-inversion-and-its-application-in-interface-oriented-programming.html","preview":"\u003cp\u003eSpring依赖注入，指的是类之间对象实例的传递方式；将创建对象的控制权由自写代码交给Spring容器(或Spring jar包)，即控制反转。\u003c/p\u003e\n","title":"Spring依赖注入(DI)与控制反转(IoC)及在面向接口编程上的应用"},{"content":"\r\n\r\n我们的太阳处于核力和引力的微妙平衡状态，核力倾向于以亿万个氢弹的力量将星球炸开，而引力则倾向于将星球压缩至淹没，在这两种力的作用下，一颗恒星就变得成熟起来。\r\n\r\n当一团许多倍于我们太阳系的氢云被自身的引力收缩时，一颗恒星就会诞生，引力收缩气体并对其加热，引力能逐渐转换为氢原子的动能。通常情况下，气态氢内的质子的排斥电荷足以将被收缩的质子分开，但是在温度升高到绝对温度10^8-10^9开时，质子(氢原子核)的动能就会克服静电的排斥力，质子从而融合在一起并发生热核反应，从而核力取代电磁力占据主导地位，两个氢核“聚合”为氦，同时释放出巨大的能量。\r\n\r\n氢“聚合”为氦，之所以会释放出巨大的能量，是因为氢原子中的质子比氦原子中的质子重，那么就会产生质量盈余，这样盈余的质量就会根据爱因斯坦质能方程转化为能量。换句话说，释放出来的能量，是氢原子相对于氦原子的额外质量，这些质量等于释放出的能量与光速平方的比值。这样恒星就会因聚变燃烧，从而发光。\r\n\r\n但是氢原子总有聚变完的一天，那么氢原子消耗殆尽之时，恒星就会被氦原子充斥，氦原子可以看做是氢原子燃烧的废料。那么此时，核力将会变小，引力重新占上风，以至于继续压缩恒星，那么在这种收缩下恒星的温度继续升高，以至于氦原子可以燃烧并释放能量，那么燃烧后的氦原子的废料将会是锂和碳(遵循结合能曲线)。虽然废氦还可以燃烧，但是恒星的尺寸是越来越小了(因为燃料都被烧了)，但是他的温度非常高(不然废氦也无法燃烧)，从而恒星的大气层会极速膨胀。此时，恒星就不再是恒星，而是红巨星。也就意味着原先距离恒星近的星球会被如今的红巨星蒸发掉，当然这也是50亿年后的地球的命运。\r\n\r\n当废氦也消耗殆尽时，那么核燃炉将会熄灭。引力又再一次战胜核力占据压倒性优势，红巨星会在引力作用下继续坍缩，变成白矮星，也就是全部质量被压缩为地球那么大的一个小小的恒星。\r\n\r\n白矮星并不明亮，因为是燃烧废氦的结果，但是还尚未到达结合能曲线底部，也就是说白矮星还可以通过质能方程燃烧结合能曲线底部以上，氦原子以下的原子燃料继续在引力压缩恒星而产生的高温作用下燃烧。等到达结合能曲线的底部之后，恒星的内部将会被重元素(比如铁)充斥，也就无法再燃烧，恒星彻底死亡，由白矮星变为暗淡的矮星。引力再次占据主导地位，继续压缩恒星，星体的温度爆炸性上升几千倍，达到上万亿度，此时，矮星的铁核坍缩，其外层被炸毁，同时释放出星系中已知的最巨大的爆发能量，成为一个被称为超新星的爆炸恒星。一个超新星爆发时的亮度足以超过银河系上千亿颗恒星的整体亮度。\r\n\r\n超新星爆发之后，会留下一个完全死亡的星球，即中子星，只有曼哈顿大小，其密度非常大，大到所有的中子互相紧挨在一起。尽管中子星几乎看不见(恒星燃烧后的最终废料，即被重元素充斥，密度非常大，在强大的质量的作用下中子星有着强大的引力场，连光也无法逃逸，所以我们看不到，事实上，如果一个恒星是我们太阳的10-50倍，那么即使该恒星变成了中子星，那么引力还是会继续压缩它，此时没有核力抵抗引力的压缩，那么就无法阻止该恒星的最终坍缩，此时，就会变成广为人知的黑洞，黑洞仍然继承了中子星的特性，高密度、强引力场，所以光无法逃逸但是可以围绕其旋转，而进入黑洞视界内的任何物质都无法逃逸，都会被强大的引力压缩到粉碎)，但是我们仍然可以用仪器探测到。旋转的中子星会发出某些放射线，他们的作用就像外空间的宇宙灯塔，而在我们看来就会是闪烁着的星星，被称为脉冲星。\r\n\r\n当然，这并不意味着恒星的彻底死亡，这只是另一颗恒星诞生的开始，超新星爆炸后喷射出的星际物质与混合气体集聚到一个富含氢的新星中产生二代恒星，又继续上演恒星的兴衰史。\r\n\r\n事实上，把恒星的兴衰过程反方向重演，就是原子弹和氢弹，即通过结合能曲线的另一端，裂变铀元素，一次性跳到曲线的底部(铁元素)，爆发的能量相当大是因为铀在核裂变过程中的产物(铯和钾)中的质子的平均重量小于铀中的质子的平均重量，那么盈余的质量会通过质能方程被一次性转化为能量，这就是原子弹的能量来源。\r\n\r\n最后，再次感谢天才而又伟大的爱因斯坦！","cover":"/images/FixedStar.jpg","link":"the-rise-and-fall-of-stars-once-born-it's-designed-to-be-eternal.html","preview":"\u003cp\u003e我们的太阳处于核力和引力的微妙平衡状态，核力倾向于以亿万个氢弹的力量将星球炸开，而引力则倾向于将星球压缩至淹没，在这两种力的作用下，一颗恒星就变得成熟起来。\u003c/p\u003e\n","title":"恒星兴衰史:一诞生就注定永恒"},{"content":"\r\n\r\n超弦理论中，弦的大小不到质子的10^19倍(因而尚且观测不到)且是振动的，每种振动模式代表一种独特的共振或粒子(即粒子不是一个点，而是以某种模式振动的弦)。电子并不比中微子更基本，这是由于我们的显微镜还不够强大，无法观测到更深层的结构，根据弦理论，如果我们能把点粒子放大，那么我们就会看到一个小的振动弦，也就是说物质本质上是由这个振动弦产生的(由于振动而产生的一种“和声”，就像小提琴可以组合出无限多的和声，振动弦也可以构造出无限数量的物质形式，其实这样就明确解释了自然界中粒子的丰富性)，同样，物理定律可以被比作弦上所允许的和声定律，那么由无数的振动弦组成的宇宙就可以被当做一首交响曲了。","cover":"/images/Strings.jpg","link":"strings-particles-matter-and-the-universe-in-string-theory.html","preview":"\u003cp\u003e超弦理论中，弦的大小不到质子的10^19倍(因而尚且观测不到)且是振动的，每种振动模式代表一种独特的共振或粒子(即粒子不是一个点，而是以某种模式振动的弦)。\u003c/p\u003e\n","title":"弦理论中的弦、粒子、物质以及宇宙"},{"content":"\r\n\r\n在图书馆拿这本书，起初是因为它的名字吸引了我;后来在阅读了一章之后，才发现吸引我的是宿命;读完了整本书，直到现在，其实真正让我感同身受的是\"自由\"。\r\n\r\n+ 有时候我宁愿相信，人生的诸多不顺，只是因为最适合你的那条路尚未出现。\r\n+ 人最终要走上一条由自我意志推动的路。那种自我意志你可能一时看不清，却能感受到它和周围磕磕绊绊的摩擦。摩擦越剧烈，人就越痛苦。而你越痛苦，就越说明周遭处境和你的意志之间不匹配。于是你不得不改变你的处境。很多时候，是痛苦而不是欲望，推动着你在一个个处境之间跳来跳去，直到最终安定下来。在那之前，你不知道要往哪走，不知道什么时候被捉住，不知道在哪儿撞墙死掉，但你知道，不动是无论如何不成的。\r\n+ 当你停下来，你就成为了你。那时你才知道，一切纠结，一切转折，都只是自我意志在拣选它的归宿。\r\n\r\n我记得轻云爸爸那被宿命或生活给予的愧疚，于父亲，于妻子于孩子。\r\n\r\n+ 最终，爸爸在同学和红卫兵的带头人的带领下，走上了高台，当着众人的面喊了口号，念了批判书，与爷爷划清界限，并在爷爷头顶上啐了一口唾沫。\r\n+ 就是这一口唾沫，成为了爸爸心里的梗。等到他下乡时，他已经十七岁，这口唾沫开始在深夜里浮上他心头，并且变得不那么理直气壮了;十八岁时，他见到王老西挡在批斗他爹的红卫兵身前，挥舞着流氓拳一阵乱打，脸上都是血，虽然寡不敌众，但那种不要命的样子却当真把众人吓退了;二十二岁，他见到黑白电视里的审判和一系列平反……\r\n+ 后来，在漫长的岁月里，那口唾沫总是像心脏里埋着的一颗小石头，不鲜明、不显著，却总是硌得他生疼，尤其是喝了点酒、心被酒泡软了的时候，那石头的边缘几乎把心划破……\r\n\r\n轻云的父亲在倒卖外汇中被调查，谢家父子帮他重新回到厂子，但却时刻面临着调查组或公安局的调查与追捕，他不想和王老西一起做生意，但想和他一起走，南下，避风头。他也不会想到自己会请求同与厂子谈判的英国人帮他出国，更不会想到在轻云出生后将十年见不到她和她的妈妈。\r\n\r\n我记得谢一凡对员工的同情、对父亲遗命的遵从、对微月的关怀、对轻云及她妈妈的照顾。\r\n\r\n还有轻云从They are watching you到寻找自我的经历！\r\n\r\n+ 对于内心中经历过的痛苦感受，我觉得最重要的不是痛苦的来源，也不是痛苦的类型，而是自我对痛苦的意识以及之后的反应。有时候我们会误解痛苦的意义。我们走不出痛苦，不仅因为痛苦过于沉重，也因为我们沉溺其中，缺乏走出的动力。时常听到“痛苦孕育深刻”、“苦难造就伟大”之类的说辞，这对经历痛苦的人有一种诱惑的误导。可是实际上，痛苦并不是让人沉溺的东西，也不是让人用来自我标榜，或者向世界索取报偿的东西。人的命运由自己负责，世界并不负责为你的痛苦给你补偿。最终是人对痛苦的跨越，而不是痛苦本身，标示了人的价值。只有走出痛苦才能肯定它的意义。\r\n+ 对人如此，对国度也是如此。\r\n\r\n**生于一九八四，郝景芳/著**","cover":"/images/born-in-1984.jpeg","link":"born-in-1984-reading-notes.html","preview":"\u003cp\u003e有时候我宁愿相信，人生的诸多不顺，只是因为最适合你的那条路尚未出现。\u003c/p\u003e\n","title":"《生于一九八四》·阅读小记"},{"content":"\r\n\r\n一部《万历十五年》,就是一部简明扼要的明朝兴衰史。黄仁宇以独到的眼光以六个人物为代表并以万历年间为切入点 深 入阐述了一个王朝由盛极衰的原因。作者在本书中渗透的历史观足以让每一位读者对中国古代封建社会形成更为深入的理解。\r\n\r\n**皇帝以儒家伦理纲常为基维护统治秩序而又不得不与文官集团相抗衡。**\r\n\r\n封建王朝统治秩序的维护在很大程度上是依靠封建伦理道德实现的。自汉武帝罢黜百家独尊儒术确立儒家思想的正统地位伊始,直至清廷覆灭,两千年的封建社会高度契合,几无例外。上至天子,下到百姓,无不遵守。文官集团是儒家伦理的极力推动者与坚决维护者,一方面他们以此维护整个地主阶级的统治利益,另一方面他们也以此与皇帝对抗保全小集团私利。庞大的帝国并不是有一位励精图治殚精竭虑的君主就可以实现统治的,维系统治的纽带正是这各级文官与文官集团推崇的伦理纲常。英明的君主会洞悉这种 “ 潜规则 ” ,合理利用文官集团中的矛盾不仅可以牵制双方而且能够达到自己维护统治秩序稳定的目的。这万历皇帝自小就熟悉各种礼仪,受张居正的影响 ( 正面影响 ) 是具备成为好皇帝的潜质的。但权倾朝野的首辅张居正去世之后,在文官集团的检举之下其种种劣端行径暴露无疑,这位曾经被万历极度推崇依赖的首辅竟是在自己面前一套背地里一套,这给了万历莫大的打击,也为万历皇帝日后的懒政埋下了隐患。自小被礼仪伦理捆绑,为文官教导的万历就越想挣脱这种束缚,就以不上朝等行为对抗文官集团。\r\n\r\n不得不说,以伦理纲常维护统治秩序这确是一大创举,成效也是卓著的,其在诛心。程朱理学存天理灭人欲以达到维护统治秩序的目的,而由皇室与文官集团表现出来的尊卑有序君为臣纲更是为⺠间提供了一套典范,以此便能使得统治秩序的稳定。但是这也是一种愚⺠政策,在三纲五常的捆绑之下⺠智不开社会思想就难以激流勇进,发展到清朝末期其弊端显而易⻅。","cover":"/images/the-Fifteen-Years-of-Wanli.jpg","link":"thoughts-on-the-fifteen-years-of-wanli.html","preview":"\u003cp\u003e一部《万历十五年》,就是一部简明扼要的明朝兴衰史。\u003c/p\u003e\n","title":"关于《万历十五年》的一点思考"},{"content":"\r\n\r\n暑假在读客官微上看到了关于清明上河图密码的一期推送,说实话,我对悬疑推理小说兴致并不高,但我却是一个十足的历史爱好者,受这一因素的驱动,于收假后特意买来拜读。\r\n\r\n虽说我是一个典型的文科生,但是于历史而言更多的只是历史课本上学到的,以悬疑推理的方式 深 入历史还是第一次,倒也兴致高涨。故事定位在北宋末年,以《清明上河图》为原型,以四个不同领域的人物 ( 当前共出了四本 ) 为线索较为完整的串联起了北宋社会的士农工商兵等方方面面,书名也绝非沽名钓誉,确实配的上这幅画的思想精髓。\r\n\r\n一幅清明上河图就是一部北宋兴衰史,北宋帝国承平日久,图中一片欣欣向荣之景,但事实上已经危机四伏。方腊掣肘,金兵为患,辽国、西夏、高丽亦对中原王朝⻁视眈眈。清明上河图完成不久金兵便大举入侵焚城杀人,北宋繁华一夕扫尽。\r\n\r\n第一部以宗室子弟讼绝赵不尤破八子案、赵墨儿破香袋案、赵瓣儿破范楼案、宗室子弟赵不弃破变身案、以及最后搁浅的梅船案来展开布局,尤其是梅船案,目前看来这一案件是贯穿四部书的线索。本部书主要涉及到的是士子,即士农工商兵中的 “ 士 ” 。八子案中以东水八子的恩怨纠葛阐明了改革派与守成派之间的矛盾,八子案也是整部书的引子,贯穿四部书的梅船案更是与八子案密不可分。\r\n\r\n第二部是以牙绝冯赛跌宕起伏的人生经历为眉目展开的。包括金篇银篇铜篇三大部分,分别是三商案、百万案、⻜钱案。猪行、碳行、⻥行的货源被截一时间供货紧张,百万⻜钱不翼而⻜,牙绝冯赛在妻女失踪家产被抄的困境下揪出贯穿本案的引子 “ 母钱 ” 以及背后主使者广宁监的几位工人。牵扯到的社会阶层为 “ 商 ” 。而最终又回到范楼与梅船,照应了本书的主题,紧密联系了第一部,同时也给第三部埋下了伏笔。\r\n\r\n第三部以斗绝梁兴破化灰案、⻝儿案、空仓案、骷髅案为着墨点。至第三部就牵扯到了方腊,一时间读者联系前两部的各种悬疑,就会更 深 入的了解清明上河图密码之所以为密码的原因。该部书梁兴本是军中之人,因此涉及到的社会阶层是 “ 兵 ” 。\r\n\r\n第四部以作绝张用破萝卜案、焦船案、艮岳案、秘阁案为线索,一个整日疯疯癫癫的人却聪明绝顶连破四大案件,究其疯癫的原因不料确是装出来的,这里面的苦心孤诣不是三言两语能够道的清的。本部书以皇室修建艮岳为起因而揭示了日益激化的阶级矛盾,再加上⺠族矛盾使得读者很容易感觉到北宋帝国的危在旦夕。本部书主要涉及到的社会阶层为 “ 工 ” 。而社会阶层 “ 农 ” 则贯穿于每部书,毕竟农业才是封建王朝的根本。\r\n\r\n总之,就目前出的这四部书看来,作者的布局是相当庞大的,而每一部书的构思又极为精巧,每一个案件的推理与展开更是显得恰到好处而游刃有余,最为精妙的当属作者的填词。从书中看得出作者对北宋社会的⻛貌研究的很透彻,对清明上河图观察的很独到,真心希望本书能够尽快出版第五部与第六部,以飨读者!","cover":"/images/qingmingshanghetu.jpg","link":"a-domestic-masterpiece-of-conscientious-suspicious-reasoning.html","preview":"\u003cp\u003e一幅清明上河图就是一部北宋兴衰史,北宋帝国承平日久,图中一片欣欣向荣之景,但事实上已经危机四伏。\u003c/p\u003e\n","title":"《清明上河图密码》一部良心的国产悬疑推理大作"},{"content":"\r\n\r\n昨夜⻛雨洒庭轩,心微凉,夜茫茫。最是相逢仲夏晚,无料,难吟月光寒。\r\n\r\n前年漫流华表语,何所似,孤鸿影。一生难再此佳年,莫惧,蓑雨任平生。\r\n\r\n农历丙申年六月十五日作于故邑","cover":"/images/huanxisha.jpg","link":"rain-sprinkled-the-courtyard-las-night.html","preview":"\u003cp\u003e一生难再此佳年,莫惧,蓑雨任平生。\u003c/p\u003e\n","title":"浣溪沙 · 昨夜⻛雨洒庭轩"}]