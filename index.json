[{"content":"\r\n\u003cfont style=\"font-family:Consolas\"\u003e\r\n# Ⅰ. Second-order determinant\r\n\r\nLet a\u003csub\u003e11\u003c/sub\u003e, a\u003csub\u003e12\u003c/sub\u003e, a\u003csub\u003e21\u003c/sub\u003e, a\u003csub\u003e22\u003c/sub\u003e be four numbers, we call\r\n\r\n![Second-order determinant](/images/article/second-order determinant.png)\r\n\r\nis a second-order determinant, where each number a\u003csub\u003eij\u003c/sub\u003e is called an element. And where the subscripts i and j are the row and column labels of the element, respectively. a\u003csub\u003e11\u003c/sub\u003e, a\u003csub\u003e22\u003c/sub\u003e are the main diagonal elements and a\u003csub\u003e12\u003c/sub\u003e, a\u003csub\u003e21\u003c/sub\u003e are minor diagonal elements.\r\n\r\nThe value of the second-order determinant is equal to the product of the main diagonals minus the product of the second diagonal elements. This is the diagonal rule of the second order determinant.\r\n\r\n# Ⅱ. Third-order determinant\r\n\r\nAnalogously, we call\r\n\r\n![Third-order determinant](/images/article/third-order determinant.png)\r\n\r\nis a third-order determinant. Its operation still obeys the diagonal rule.\r\n\u003c/font\u003e","cover":"/images/advanced-algebra.jpg","link":"second-and-third-order-determinants.html","preview":"\u003cp\u003eSecond-order determinant and Third-order determinant.\u003c/p\u003e\n","title":"Second- and third-order determinants"},{"content":"\r\n\r\n## 回顾\r\n\r\n上文中，setup.s通过段间跳转指令`jmpi`跳转至`8:0`处执行，即开始执行system模块的head.s程序。由于setup.s将system模块移动到了内存始址处，而head.s程序在被编译后，会被连接成system模块的最前面开始部分，即head.s程序就是位于内存始址处。\r\n\r\nhead.s汇编程序与之前的汇编程序不同，其采用AT\u0026T的汇编语言格式，并且使用GNU的gas和gld进行编译连接，最明显的特征是操作数的结合方向是自左向右，与Intel汇编更好相反。\r\n\r\n## 一、设置数据段与栈段寄存器\r\n\r\nhead.s的开始要设置数据段寄存器，其本质是将数据段寄存器从实模式转向保护模式。实模式下代码段寄存器(cs)与数据段寄存器(ds、es、fs、gs)保存的就是代码段或数据段的基址，而保护模式下保存的则是代码段或数据段的选择符。cs寄存器在setup.s中已经完成了转变，因此这里需要对数据段寄存器进行设置，以使其适应32位保护模式。代码如下\r\n\r\n```\r\nstartup_32:\r\n    movl $0x10,%eax\r\n    mov %ax,%ds\r\n    mov %ax,%es\r\n    mov %ax,%fs\r\n    mov %ax,%gs\r\n```\r\n\r\n对于GNU汇编来说，每个直接数要以`$`开始，否则表示的是地址，而每个寄存器名都要以`%`开头，eax表示的是32位的ax寄存器。\r\n\r\n这里的直接数`$0x10`依然要转化为二进制来看待，即`00010000`，那么第一第二位表示内核特权级，第三位表示的是GDT，第四和第五位为二进制`10`也就是十进制2，即GDT索引为2的那一项。这里使用的GDT依旧是定义在setup.s中的GDT，即上文中解释过的GDT项。也从侧面说明了ds、es、fs、gs的段基址、段限长、特权级都是相同的，段基址就是GDT索引为2的那一项指明的基址，即内存始址`0x0000000`(参见上文)，段限长为8MB，特权级为内核特权级。\r\n\r\n上述通过eax寄存器设置了数据段寄存器，那么接下来设置栈段寄存器，代码如下\r\n\r\n```\r\n    lss _stack_start,%esp\r\n```\r\n\r\n`lss`指令，即Load Stack Segment Register，是80386及以后的CPU才有的指令，其指令格式如下\r\n\r\n```\r\nlss Mem, Reg\r\n```\r\n\r\n若`Reg`为16位寄存器，则`Mem`必须是32位指针(地址)；若`Reg`是32位寄存器，则`Mem`必须是48位指针，其低32位给指令中指定的寄存器，高16位给指令中的段寄存器。\r\n\r\nstack_start定义在kernel/sched.c中，为\r\n\r\n```\r\nstack_start = { \u0026 user_stack[PAGE_SIZE\u003e\u003e2], 0x10}\r\n```\r\n\r\n上述代码将栈顶指针指向`user_stack`数据结构的最末位置，该数据结构定义在kernel/sched.c中，为\r\n\r\n```\r\nlong user_stack [ PAGE_SIZE\u003e\u003e2 ]\r\n```\r\n\r\n大概位于`0x1E25C`处。这里的`0x10`将ss设置为与前面4个段选择符相同的值，即段基址都是`0x0000000`，段限长都是8MB，特权级都是内核特权级，其后的压栈动作就要在这里进行。\r\n\r\n经过上述设置，代码段基址、数据段基址以及栈段基址都位于内存始址(`0x00000`处)。而栈顶指针则指向`0x1E25C`的位置，如下图所示\r\n\r\n![代码段基址、数据段基址以及栈段基址,栈顶内存映像](/images/article/202001031656.png)\r\n\r\n## 二、重新设置IDT与GDT\r\n\r\n接下来要设置IDT，之前在setup.s中设置过IDT，但是只是将IDT的基地址传递给了IDTR，而IDT本身则没有设置，这里则进行设置，代码如下\r\n\r\n```\r\n    call setup_idt\r\n```\r\n\r\n通过`call`指令调用了`setup_idt`子程序，该子程序为\r\n\r\n```\r\nsetup_idt:\r\n    lea ignore_int,%edx\r\n    movl $0x00080000,%eax\r\n    movw %dx,%ax        /* selector = 0x0008 = cs */\r\n    movw $0x8E00,%dx    /* interrupt gate - dpl=0, present */\r\n\r\n    lea _idt,%edi\r\n    mov $256,%ecx\r\nrp_sidt:\r\n    movl %eax,(%edi)\r\n    movl %edx,4(%edi)\r\n    addl $8,%edi\r\n    dec %ecx\r\n    jne rp_sidt\r\n    lidt idt_descr\r\n    ret\r\n```","cover":"/images/os.jpg","link":"adapt-to-32-bit-protection-mode-and-create-kernel-paging-mechanism.html","preview":"","title":"Linux内核源码分析：适应32位保护模式并创建内核分页机制"},{"content":"\r\n\r\n## 回顾\r\n\r\n从上文得知，在BIOS将Linux的磁盘引导程序`bootsect`加载到`0x07C00`之后，bootsect开始执行，其先是将自己移动到了`0x90000`处，然后设置了段寄存器ds、es、ss，后将setup、system程序加载至了指定位置，并确认了根设备号，最终通过段间跳转指令将CPU控制权交给了setup程序。\r\n\r\n至此，操作系统的内核程序已经加载完成，但是计算机依旧运行在16位的实模式下，也就意味着只能利用20根地址总线(即`0 ~ 19`号地址线)，寻址空间仅1MB，也就是寻址范围为`0 ~ 0xFFFFF`。实模式下的特征是在1MB寻址空间内可以直接软件访问BIOS及周边硬件，但是没有硬件支持的分页机制和实时多任务概念。对于一个现代操作系统来说，这显然是不合适的。因此，从setup开始，做的至关重要的一件事情就是从实模式转变到保护模式下，成为一个真正的现代操作系统。\r\n\r\n## 一、从BIOS中获取系统数据\r\n\r\nsetup做的第一件事就是从BIOS中获取系统数据，并将其保存到`0x90000 - 0x901FF`的位置。`0x90000`是bootsect的始址，并不超过`0x90200`，但是由于bootsect已经完成了任务，所以这段空间可以直接覆盖掉。\r\n\r\n先是读取光标位置，通过BIOS中断`0x10`的`0x03`号功能来实现，代码如下\r\n\r\n```\r\n! ok, the read went well so we get current cursor position and save it for\r\n! posterity.\r\n\r\n    mov ax,#INITSEG ! this is done in bootsect already, but...\r\n    mov ds,ax\r\n    mov ah,#0x03    ! read cursor pos\r\n    xor bh,bh\r\n    int 0x10        ! save it in known place, con_init fetches\r\n    mov [0],dx      ! it from 0x90000.\r\n```\r\n\r\n该功能号的入口参数为页号码，通过寄存器`bx`的高八位`bh`来传递，这里传入的是0，即通过`xor`运算将`bh`寄存器清零。\r\n\r\n返回的参数包括\r\n\r\n+ `ch`，扫描开始线；\r\n+ `cl`，扫描结束线；\r\n+ `dh`，行号(`0x00`是顶端)；\r\n+ `dl`，列号(`0x00`是左边)。\r\n\r\n`dx`寄存器总共两个字节，从`0x90000`开始保存，即占用`0x90000`和`0x90001`两个字节。\r\n\r\n接下来获取拓展内存大小(即RAM中高于1MB的部分)，调用`0x15`中断的`0x88`功能号实现，代码如下\r\n\r\n```\r\n! Get memory size (extended mem, kB)\r\n\r\n    mov ah,#0x88\r\n    int 0x15\r\n    mov [2],ax\r\n```\r\n\r\n返回值保存在`ax`寄存器中，共两个字节，保存在`0x90002`和`0x90003`中。\r\n\r\n接下来读取显卡数据，通过`0x10`中断的`0x0f`功能实现，代码如下\r\n\r\n```\r\n! Get video-card data:\r\n\r\n    mov ah,#0x0f\r\n    int 0x10\r\n    mov [4],bx      ! bh = display page\r\n    mov [6],ax      ! al = video mode, ah = window width\r\n```\r\n\r\n返回参数为\r\n\r\n+ `ah`，字符列数；\r\n+ `al`，显示模式；\r\n+ `bh`，当前显示页。\r\n\r\n然后分别保存在偏移为`4`和`6`的位置。\r\n\r\n接下来检查显示方式并取参数，分别通过`0x10`中断的`0x12`及`0x10`功能来实现，代码如下\r\n\r\n```\r\n! check for EGA/VGA and some config parameters\r\n\r\n    mov ah,#0x12\r\n    mov bl,#0x10\r\n    int 0x10\r\n    mov [8],ax\r\n    mov [10],bx\r\n    mov [12],cx\r\n```\r\n\r\n返回参数为\r\n\r\n+ `bh`，显示状态(`0x00`-彩色模式, I/O端口 = `0x3dX`；`0x01`-单色模式, I/O端口=`0x3bX`)；\r\n+ `bl`，安装的显示内存；\r\n+ `cx`，显示卡特性参数。\r\n\r\n然后分别保存在偏移为`8`, `10`, `12`的位置。\r\n\r\n接着读取第一个硬盘的信息。需要注意的是，第一个硬盘参数表的首地址是中断向量`0x41`的向量值，该参数表的长度为16字节，保存的地址始址为`0x90080`，连续16个字节(`0x10`)。代码如下\r\n\r\n```\r\n! Get hd0 data\r\n\r\n    mov ax,#0x0000\r\n    mov ds,ax\r\n    lds si,[4*0x41]\r\n    mov ax,#INITSEG\r\n    mov es,ax\r\n    mov di,#0x0080\r\n    mov cx,#0x10\r\n    rep\r\n    movsb\r\n```\r\n\r\n和前面不一样，这里使用`es:di`来指向传输的目的地址，而`ds:si`则指向参数表的地址，即源地址。\r\n\r\n接下来要读取第二个硬盘的信息，代码逻辑和上述一致，其参数表的地址是中断向量`0x46`的地址值，由于第一个硬盘参数表刚好保存到`0x9008F`的位置，那么第二个硬盘的参数表就是从`0x90090`开始，连续16个字节(`0x10`)，代码如下\r\n\r\n```\r\n! Get hd1 data\r\n\r\n    mov ax,#0x0000\r\n    mov ds,ax\r\n    lds si,[4*0x46]\r\n    mov ax,#INITSEG\r\n    mov es,ax\r\n    mov di,#0x0090\r\n    mov cx,#0x10\r\n    rep\r\n    movsb\r\n```\r\n\r\n最后要做的是检查系统是否存在第二个硬盘，如果不存在则将上述保存的第二个硬盘参数表清零，代码如下\r\n\r\n```\r\n! Check that there IS a hd1 :-)\r\n\r\n    mov\tax,#0x01500\r\n    mov\tdl,#0x81\r\n    int\t0x13\r\n    jc\tno_disk1\r\n    cmp\tah,#3\r\n    je\tis_disk1\r\nno_disk1:\r\n    mov\tax,#INITSEG\r\n    mov\tes,ax\r\n    mov\tdi,#0x0090\r\n    mov\tcx,#0x10\r\n    mov\tax,#0x00\r\n    rep\r\n    stosb\r\n```\r\n\r\n这个过程通过调用中断`0x13`的`0x15`号功能来实现。入口参数为`dl=驱动器号`，其中`0x8X`表示硬盘：`0x80`表示第一个硬盘、`0x81`表示第二个硬盘，那么自然这里必然是`0x81`。其出口参数为`ah=类型码`，`00`表示不存在此盘，并将`CF`置位；`01`表示软驱，没有`change-line`支持；`02`表示软驱或其它可移动设备，有`change-line`支持；`03`表示硬盘。\r\n\r\n通过`jc`指令检查`CF`是否置位，如果置位即不存在第二个硬盘，那么就跳转至`no_disk1`处清零第二个参数表。如果存在第二个硬盘，那么`jc`指令自然不满足则执行`cmp`指令判断设备是否为硬盘，如果是则将标志寄存器`ZF`置位(即`ah == 03`)。再通过`je`指令判断`ZF`是否置位，如果置位那么代表设备为硬盘，那么就跳转至`is_disk1`处继续执行。即\r\n\r\n```\r\nis_disk1:\r\n```\r\n\r\n## 二、关中断！并将system移动至0x00000处\r\n\r\n`is_disk1`第一句代码就是关中断，如下\r\n\r\n```\r\nis_disk1:\r\n\r\n! now we want to move to protected mode ...\r\n\r\n    cli         ! no interrupts allowed !\r\n```\r\n\r\n`cli`指令将CPU标志寄存器中中断允许标志`IF`置零，即不允许中断。关中断是16位实模式进入32位保护模式的标志性动作，这意味着接下来就可以废除16位实模式下的中断向量表，并初步打开32位寻址空间、建立保护模式下的中断响应机制等，这些都是与32位保护模式相配套的。\r\n\r\n\r\n作为转变的开始，已经关闭了中断，那么接下来系统将不会响应中断，以便一心一意向保护模式转变。现在开始将system移动至内存始址处，代码如下\r\n\r\n```\r\n! first we move the system to it's rightful place\r\n\r\n    mov\tax,#0x0000\r\n    cld             ! 'direction'=0, movs moves forward\r\ndo_move:\r\n    mov\tes,ax       ! destination segment\r\n    add\tax,#0x1000\r\n    cmp\tax,#0x9000\r\n    jz\tend_move\r\n    mov\tds,ax       ! source segment\r\n    sub\tdi,di\r\n    sub\tsi,si\r\n    mov cx,#0x8000\r\n    rep\r\n    movsw\r\n    jmp\tdo_move\r\n```\r\n\r\n其中`es:di`指向目的地址`0x0000:0x0`处，`ds:si`指向源地址`0x10000:0x0`处，由于起初假设system模块不会超过`0x80000`，即`512KB`，那么就不会超过`0x90000`,即system最初不会覆盖bootsect。那么这段程序就是将`[0x10000, 0x10000 + 512KB)`的内存数据块移动`[0x00000, 0x00000 + 512KB)`处，移动的数据块长度为`0x8000`节，即`512KB`。也就是说将每个源地址字节向内存低端移动`0x10000`个位置最终到达目标位置，上述汇编代码可以用如下伪码描述\r\n\r\n```\r\nax = 0x0000\r\nwhile truees = ax\r\n    ax += 0x1000\r\n    ds = ax\r\n    di = si = 0x0\r\n    ds:si to es:di, moving one seg continuously, i.e. 64KB\r\n    if ax + 0x1000 == 0x9000\r\n        break\r\n```\r\n\r\n再进一步地说明，上述伪码中各参数变动情况如下所示(注：下述`while`循环用来解释上述中的`ds:si to es:di, moving one seg continuously, i.e. 64KB`)\r\n\r\n```\r\nThe first cycle is as follows:\r\n  es = 0x0000, ax = 0x1000, ds = 0x1000, di = 0x0, si = 0x0, cx = 0x8000\r\n    while cx != 0x0000\r\n      ds:si to es:di, one word at a time, i.e. movsw\r\n      cx -= 0x0001\r\n\r\nThe second cycle is as follows:\r\n  es = 0x1000, ax = 0x2000, ds = 0x2000, di = 0x0, si = 0x0, cx = 0x8000\r\n    while cx != 0x0000\r\n      ds:si to es:di, one word at a time, i.e. movsw\r\n      cx -= 0x0001\r\n...\r\n```\r\n\r\n这就很容易理解了。那么该段汇编就可以整体上用如下伪码描述\r\n\r\n```\r\nax = 0x0000\r\nwhile truees = ax\r\n    ax += 0x1000\r\n    ds = ax\r\n    di = si = 0x0\r\n    cx = 0x8000\r\n    while cx != 0x0000\r\n        ds:si to es:di, one word at a time, i.e. movsw\r\n        cx -= 0x0001\r\n    if ax + 0x1000 == 0x9000\r\n        break\r\n```\r\n\r\n至此，就完成了对system模块的移动。对system模块的移动起到了如下的效果\r\n\r\n+ 废除了BIOS中断向量表，等同于废除了BIOS所提供的实模式下的中断服务程序；\r\n+ 回收已经无用的内存空间，因为要向保护模式转变，BIOS中断向量表所占空间自然无用，应当回收；\r\n+ 让system模块占据内存物理地址最天然、有利的位置。\r\n\r\n## 三、设置IDT与GDT\r\n\r\nIDT，即中断描述符表(Interrupt Descriptor Table)，其保存的是所有中断服务程序的入口地址，就类似于实模式下的中断向量表，这也是构建保护模式下中断机制的开始。实模式下终端向量表的始址在`0x00000`处，这个位置是固定的，而保护模式下IDT的位置是不固定的，可以在任何位置，那么为了找到IDT就要将IDT的入口地址保存在一个寄存器当中，这个寄存器就是IDTR(Interrupt Descriptor Table Register, IDT基址寄存器)，该寄存器共48位，即3个字长，第一个字是限长，剩余的两个字是基地址，结构如下\r\n\r\n```\r\n47----15-----0\r\n base | limit \r\n```\r\n\r\n将IDT入口地址传递给IDTR的过程就是设置IDTR，代码如下\r\n\r\n```\r\n    lidt    idt_48      ! load idt with 0,0\r\n```\r\n\r\n那么这里标号`idt_48`对应的就是IDT的入口地址，`idt_48`的内容如下\r\n\r\n```\r\nidt_48:\r\n    .word\t0           ! idt limit=0\r\n    .word\t0,0         ! idt base=0L\r\n```\r\n\r\n按照上面的解释，这就很容易理解了。第一个字为限长，这里为0，剩余两个字为基址，也是0，即基址就是`0x00000`处。这里基址用两个字描述的初衷在于第三个字是段基址，第二个字就是偏移，那么整个地址`0x00000`就是`0x00000 = 0x0000 * 16 + 0x0000`。即这里的IDT依旧是放在内存开始处。下面的GDTR结构的解读也是同理。\r\n\r\n与实模式不同的是，保护模式下的段寻址是通过GDT(Global Descriptor Table, 全局描述符表)完成的，GDT中存放的是段寄存器内容，其数据结构为数组。GDT在操作系统进程切换中意义重大，其中存放了每个任务的LDT(Local Descriptor Table, 局部描述符表)地址和TSS(Task Structure Segment, 任务状态段)地址，以完成进程中各段的寻址、现场保护与现场恢复。\r\n\r\nGDT的初始内容已经写在了setup程序中，如下\r\n\r\n```\r\ngdt:\r\n    .word   0,0,0,0     ! dummy\r\n\r\n    .word   0x07FF      ! 8Mb - limit=2047 (2048*4096=8Mb)\r\n    .word   0x0000      ! base address=0\r\n    .word   0x9A00      ! code read/exec\r\n    .word   0x00C0      ! granularity=4096, 386\r\n\r\n    .word   0x07FF      ! 8Mb - limit=2047 (2048*4096=8Mb)\r\n    .word   0x0000      ! base address=0\r\n    .word   0x9200      ! data read/write\r\n    .word   0x00C0      ! granularity=4096, 386\r\n```\r\n\r\n可以整理为如下一张表\r\n\r\n```\r\n index |    GDT\r\n------------------\r\n   2   | 00C0 9200\r\n       | 0000 07FF\r\n------------------\r\n   1   | 00C0 9A00\r\n       | 0000 07FF\r\n------------------\r\n   0   | 0000 0000\r\n       | 0000 0000\r\n```\r\n\r\n其中每个GDT表项共64位，即8字节/4字，结构如下\r\n\r\n```\r\n31------------------------------16-15-----------------------0\r\n             Base 0:15            |         Limit 0:15\r\n63--------56-55---52-51---------48-47---------40-39--------32\r\n Base 24:31 | Flags | Limit 16:19 | Access Byte | Base 16:23\r\n```\r\n\r\nAccess Byte的结构如下\r\n\r\n```\r\n8---7-------5---4----3----2----1---0\r\n Pr | Privl | 1 | Ex | Dc | RW | Ac\r\n```\r\n\r\nFlags的结构如下\r\n\r\n```\r\n8---7----6---5--4\r\n Gr | Sz | 0 | 0\r\n```\r\n\r\n特别说明的`Privl`为特权级，如果为`00`表示内核特权级，如果为`11`，则表明用户特权级；`Gr`标志位为颗粒度标志，如果为1，那么段限长的单位为4KB，如果为0，那么就是1B。\r\n\r\n显而易见，GDT将段基址与段限长拆分保存在不连续的bit位中。这是为了兼容286架构。那么现在GDT表项就很容易理解了。\r\n\r\n以第一项GDT为例，其内容为\r\n\r\n```\r\n00C0 9A00\r\n0000 07FF\r\n```\r\n\r\n第`0-15bit`与`48-51bit`构成段限长，内容为\r\n\r\n```\r\n007FF\r\n```\r\n\r\n将其转换为10进制就是2047bit，即2KB；再看一下颗粒度标志，其包含在最后一个字节，即\r\n\r\n```\r\n00C0    // 00000000 11000000\r\n```\r\n\r\n可见，颗粒度标志位的值为1，那么也就意味着段限长实际上为`0x007FF * 4KB = 8MB`。确定了段限长，我们再确定一下段基址，`16-31bit`、`32-39bit`、`56-63bit`构成了段基址，那么合起来就是\r\n\r\n```\r\n0x0000000\r\n```\r\n\r\n即内存始址。\r\n\r\n现在我们知道了GDT的内容与含义，那么设置GDT就是将GDT表的始址保存在GDTR(Global Descriptor Table Register, GDT基地址寄存器)中，通过下述指令完成\r\n\r\n```\r\n    lgdt    gdt_48      ! load gdt with whatever appropriate\r\n```\r\n\r\n也就是GDT的始址信息保存在`gdt_48`标号处，其内容为\r\n\r\n```\r\ngdt_48:\r\n    .word   0x800       ! gdt limit=2048, 256 GDT entries\r\n    .word   512+gdt,0x9 ! gdt base = 0X9xxxx\r\n```\r\n\r\nGDTR与IDTR的结构一致，那么也就是说第一个字`0x800`为限长，即十进制`2048bit 或 2KB`，由于每`8Byte`构成一个段描述符，所以GDT中共有256项；第三个字也就是GDT的基地址，即`0x9000`；第二个字当中，`512`为一扇区，也就是`0x00200`，`gdt`为setup程序中`GDT`表的偏移，那么`512+gdt`实际上就是指向了`0x9000`段中偏移为`gdt`的位置处。所以整个地址就可以计算为`0x9000 * 16 + (512 + gdt)`。\r\n\r\n综上，总结一下，IDTR与GDTR分别说明了IDT与GDT的入口地址在哪(base)，也说明了IDT和GDT中最多有多少个表项(limit)。\r\n\r\n## 四、打开A20，实现32位寻址\r\n\r\n这是进入保护模式的关键，因为保护模式下必须突破16位寻址以实现32位寻址，就是通过打开A20地址线实现的。\r\n\r\nIBM公司最初的PC机使用的是Intel 8088处理器。该微机中地址线只有20根(`A0-A19`)，当是RAM只有几百KB不到1MB，这20根地址线是完全够用的，所能寻址的最高地址为`0xffff:0xffff`，即1MB处(`0xfffff = 0xffff * 16 + 0xffff`)，那么对于超过1MB的寻址地址将环绕到内存始址处(注意这个细节，可以利用这个特点来检测A20地址线是否打开)。当1985年引入AT机时使用的Intel 80286处理器具有24根地址线，最高寻址16MB，并且有一个与8088完全兼容的实模式运行方式，但是，在寻址值超过1MB时，80286却无法像8088那样实现地址寻址环绕。为了完全实现兼容，IBM最终使用了一个被称之为A20的信号，当A20为0时，那么比特20及以上的地址线都会被清除，从而实现兼容。\r\n\r\n机器启动时，A20是默认关闭的，所以只能实现实模式下1MB寻址，那么要进入保护模式就需要打开A20，实现32位寻址。代码如下\r\n\r\n```\r\n! that was painless, now we enable A20\r\n\r\n    call  empty_8042\r\n    mov   al,#0xD1      ! command write\r\n    out   #0x64,al\r\n    call  empty_8042\r\n    mov   al,#0xDF      ! A20 on\r\n    out   #0x60,al\r\n    call  empty_8042\r\n```\r\n\r\n选通A20之后，Linux 0.11就可以实现32位寻址，其线性寻址空间就是4GB!\r\n\r\n## 五、对8259A中断控制器进行重编程\r\n\r\n由于CPU在保护模式下，`int 0x00 - int 0x1F`被Intel保留为内部不可屏蔽中断和异常中断。如果不对8259A进行重新编程的话，那么也就意味着`int 0x00 - int 0x1F`会被保护模式下的Intel保留中断所覆盖掉，因此，必须重新编程，其本质就是重新建立映射关系。代码如下\r\n\r\n```\r\n! well, that went ok, I hope. Now we have to reprogram the interrupts :-(\r\n! we put them right after the intel-reserved hardware interrupts, at\r\n! int 0x20-0x2F. There they won't mess up anything. Sadly IBM really\r\n! messed this up with the original PC, and they haven't been able to\r\n! rectify it afterwards. Thus the bios puts interrupts at 0x08-0x0f,\r\n! which is used for the internal hardware interrupts as well. We just\r\n! have to reprogram the 8259's, and it isn't fun.\r\n\r\n    mov al,#0x11        ! initialization sequence\r\n    out\t#0x20,al        ! send it to 8259A-1\r\n    .word   0x00eb,0x00eb       ! jmp $+2, jmp $+2\r\n    out\t#0xA0,al        ! and to 8259A-2\r\n    .word   0x00eb,0x00eb\r\n    mov\tal,#0x20        ! start of hardware int's (0x20)\r\n    out\t#0x21,al\r\n    .word   0x00eb,0x00eb\r\n    mov\tal,#0x28        ! start of hardware int's 2 (0x28)\r\n    out\t#0xA1,al\r\n    .word   0x00eb,0x00eb\r\n    mov\tal,#0x04        ! 8259-1 is master\r\n    out\t#0x21,al\r\n    .word   0x00eb,0x00eb\r\n    mov\tal,#0x02        ! 8259-2 is slave\r\n    out\t#0xA1,al\r\n    .word   0x00eb,0x00eb\r\n    mov\tal,#0x01        ! 8086 mode for both\r\n    out\t#0x21,al\r\n    .word   0x00eb,0x00eb\r\n    out\t#0xA1,al\r\n    .word   0x00eb,0x00eb\r\n    mov\tal,#0xFF        ! mask off all interrupts for now\r\n    out\t#0x21,al\r\n    .word   0x00eb,0x00eb\r\n    out\t#0xA1,al\r\n```\r\n\r\n重新编程前后的中断请求号与中断号之间的对应关系如下\r\n\r\n```\r\n    before       |        after\r\n-----------------------------------\r\nIRQ0  -\u003e 0X00    |    IRQ0  -\u003e 0X20\r\nIRQ1  -\u003e 0X01    |    IRQ1  -\u003e 0X21\r\n...\r\nIRQ14 -\u003e 0X0E    |    IRQ14 -\u003e 0X2E\r\nIRQ15 -\u003e 0X0F    |    IRQ15 -\u003e 0X2F\r\n```\r\n\r\n## 六、进入32位保护模式\r\n\r\nsetup执行以来，从关中断到对8259A重编程，都是在为进入保护模式做准备，下面两行代码直接设置CPU进入32位保护模式运行。\r\n\r\n```\r\n    mov\tax,#0x0001  ! protected mode (PE) bit\r\n    lmsw    ax      ! This is it!\r\n```\r\n\r\n`lmsw`指令的作用是加载机器状态字，即load Machine Status Word，也称之为控制寄存器`CR0`，共32位，存放系统控制标志，其第0位为`PE(Protected Mode)`，若为1则表明设置处理器工作方式为保护模式。\r\n\r\n`#0x0001`就是总共16位，最低位为1，上述代码加在`CR0`之后就可以通过ax寄存器将`PE`位置1，自此，CPU正式进入保护模式。\r\n\r\n## 七、跳转！进入system执行head.s\r\n\r\nCPU进入保护模式工作后，最明显的特征就是要根据GDT决定后续执行程序所在段(即，要执行的程序在哪)。setup向head.s跳转也是同理，如下\r\n\r\n```\r\n    jmpi    0,8     ! jmp offset 0 of segment 8 (cs)\r\n```\r\n\r\n通过段间跳转指令`jmpi`跳转至`8:0`处执行，这里的8如何理解呢？\r\n\r\n如果将8转为二进制就容易了，即`1000`，这里的每个比特位都有含义，第一第二位表示内核特权级，前面说过，`00`表示GDT表项为内核特权级，`11`则为用户特权级；第三位用于区分GDT和LDT，若为`0`则表示GDT，`1`表示LDT；第四位`1`表示GDT的第二项，即索引为1的那一项，我们前面刚好分析过这一项。那么上述代码就是跳转到以第二项GDT的base为段地址，以0位偏移的内存处。上面分析过，第二项GDT的base为`0x0000000`，即内存始址，那么再加上偏移0还是内存始址，这里是什么呢？就是system模块的head.s程序。\r\n\r\n本文完！","cover":"/images/os.jpg","link":"from-16-bit-real-mode-to-32-bit-protection-mode.html","preview":"\u003cp\u003e从实模式到保护模式。\u003c/p\u003e\n","title":"Linux内核源码分析：转变！从16位实模式到32位保护模式"},{"content":"\r\n\r\n## 一、财政政策效果的IS-LM分析\r\n\r\n财政政策效果取决于IS曲线和LM曲线的斜率。详见下表\r\n\r\n![财政政策效果的IS-LM分析](/images/article/caizhneg.png)\r\n\r\n## 二、货币政策效果的IS-LM分析\r\n\r\n货币政策效果依旧取决于IS曲线和LM曲线的斜率。详见下表\r\n\r\n![货币政策效果的IS-LM分析](/images/article/huobi.png)\r\n\r\n### 三、对LM曲线斜率影响的补充说明(重要)\r\n\r\n产品市场是通过利率决定产出的，不管是从推导看还是政策效果看一直都是利率决定产出，即r→i→s→y。这个很容易理解，上述分析政策效果时凡是涉及产品市场斜率的都不是问题，很容易就可以得出结论，但是货币市场LM曲线则不然。\r\n\r\n我们知道，货币市场是有关利率决定的市场，即是通过产品市场产出决定利率的，但是为了建立IS-LM模型我们是反着来的，即r→m2→m1→y,因此给人造成一种错觉，即货币市场也是利率决定产出，这是不对的。这个传导路径只是为了建立IS-LM模型，除此之外别无他用。真实的传导路径应该是y→m1→m2→r,一定要记住！如果混淆了二者，那么就对上述分析政策效果时凡是涉及货币市场的情况产生很大的误区。举个例子\r\n\r\n若货币当局实行扩张性货币政策，由于LM曲线依旧是通过r传导m2，所以m2此时并没有改变,只是通过货币市场均衡条件时扩大了交易需求从而产生高产出，换句话说，也只有这么高的产出才会用到(需要)这个大的货币需求，但是产品市场并没有更高的均衡水平(因为受货币市场影响的利率并未发生变动)，那么这扩大的交易需求会导致货币市场存在货币供给大于货币需求的失衡，解决办法就是提升投机需求即降低利率，由于利率降低必然会刺激产品市场投资从而形成产出，产出的多少取决于投资的量，更根本的，取决于利率的高低，即利率越低产出投资越大产出越大，那么利率怎样才能更低呢？由于m2受m1影响，m1减少，m2增加，那么就是m2增加时什么条件下利率才更低呢？考虑以下投机需求函数曲线：\r\n\r\n![投机需求函数曲线](/images/article/lms.png)\r\n\r\n可以看出,如果投机需求虚线更加陡峭，那么在m2增加时对应的利率更低，即r1 \u003c r2，那么很自然的就最大程度上刺激了投资从而产生高产出，自然而然的，货币政策效果更加明显。归根结底，传导是m2→r，而不是r→m2，更进一步的是y→m1→m2→r。\r\n\r\n谨记！\r\n\r\n\u003cp style=\"font-family:Consolas;text-align:right\"\u003eLast updated at 11:15, October 27, 2019\u003c/p\u003e","cover":"/images/nopic.jpg","link":"is-lm-analysis-of-the-effect-of-fiscal-policy-and-monetary-policy.html","preview":"\u003cp\u003e财政政策效果的IS-LM分析、货币政策效果的IS-LM分析、对LM曲线斜率影响的补充说明(重要)。\u003c/p\u003e\n","title":"财政政策效果和货币政策效果的IS-LM分析"},{"content":"\r\n\r\n## 一、经济增长的决定因素\r\n\r\n经济增长的决定因素可以通过宏观生产函数来说明，如下\r\n\r\n![宏观生产函数](/images/article/eg1.png)\r\n\r\n即经济增长取决于技术A、劳动N、资本K。作为因变量的Y与自变量A、N、K是同方向变动的。\r\n\r\n从函数关系上说，当自变量中的一个或多个变量发生变化时，产出Y就会发生变化，更进一步说，当自变量中的一个或多个变量增加时时，产出Y就会增加，引起经济增长。\r\n\r\n## 二、新古典经济增长模型\r\n\r\n上述是分析了经济增长的直接原因，但本质上属于静态分析，没有引入时间的因素。为了进一步描述经济增长，必须对经济进行动态分析。\r\n\r\n新古典经济增长模型关注的是经济增长的直接原因，其假设如下\r\n\r\n1. 经济由一个部门组成，该部门生产一种即可用于投资也可用于消费的商品；\r\n2. 该经济为不存在国际贸易的封闭经济，且政府部门被忽略；\r\n3. 生产的规模不变；\r\n4. 该经济的技术进步人口增长及资本折旧的速度由外生因素决定；\r\n5. 社会储蓄函数为S=sY，s为储蓄率。\r\n\r\n首先分析没有技术进步的新古典增长模型\r\n\r\n## 三、没有技术进步的新古典增长模型\r\n\r\n在没有技术进步的情况下，那么暂时忽略生产函数中的技术，生产函数如下：\r\n\r\n![没有技术进步的宏观生产函数](/images/article/eg2.png)\r\n\r\n上式中，变量分别为总产出、总量劳动和总量资本，它们均随时间推移而变化。\r\n\r\n根据生产规模报酬不变的假定，有：\r\n\r\n![生产规模报酬不变假定下的宏观生产函数](/images/article/eg3.png)\r\n\r\n对于任何正数λ都成立，特别地，取λ=1/N，上式变为：\r\n\r\n![人均产出函数](/images/article/eg4.png)\r\n\r\n上式实质上是求了人均产出，即单个劳动力投入(1)下人均资本(K/N)的投入下的人均产出。为了说明简单起见，假定全部人口都参与生产，那么上式表明，人均产量Y/N只依赖于人均资本K/N。那么用y表示人均产量，用k表示人均资本，则生产函数可以写成如下形式：\r\n\r\n![调整后的函数](/images/article/eg5.png)\r\n\r\n式中，f(k)=F(1,k)。\r\n\r\n一般而言，资本积累受两种因素影响，即投资(形成新资本)和折旧(旧资本的损耗)。假定折旧是资本存量的一个固定比率δ(0 \u003c δ \u003c 1),人口增长率为n，且储蓄能够有效转化为投资(I = S),则有\r\n\r\n![资本存量增量=投资-对资本存量的折旧](/images/article/eg6.png)\r\n\r\n即资本存量增量=投资-对资本存量的折旧(也就是投资等于折旧时，资本存量只会维持而不会增加，如果大于时，资本存量会增加)。那么人均资本存量增量就可以表示为\r\n\r\n![人均资本存量增量](/images/article/eg7.png)\r\n\r\n此外，由于人均资本k=K/N，对该式关于时间变量求导，利用`N(N上一点)/N=n`经运算得：\r\n\r\n![人均资本存量增量](/images/article/eg8.png)\r\n\r\n其中，等式左边是人均资本存量增量。从而有：\r\n\r\n![人均资本存量增量](/images/article/eg9.png)\r\n\r\n那么联立如下等式：\r\n\r\n![联立](/images/article/eg10.png)\r\n\r\n并整理，得新古典增长模型的基本方程：\r\n\r\n![新古典增长模型的基本方程](/images/article/eg11.png)\r\n\r\n即人均资本存量增量为人均储蓄(投资)减去(n+δ)k项。(n+δ)k可以拆分为nk和δk，前者表示人口增长率下人口增长对人均资本的损耗，后者表示折旧率下折旧对人均资本的损耗，联想“资本存量增量=投资-折旧”，那么必然有“人均资本存量增量=人均投资(储蓄)-资本折旧和人口增加对人均资本损耗之和”。\r\n\r\n保持经济增长就要保证人均资本存量不减少即至少保证人均资本存量增量为0，总体的资本存量可无法保证经济增长，因为再大的资本存量也经不住庞大的人口的平均，因此，人均资本存量就是保证经济增长的一个重要指标。要保证人均资本存量的不减少，就是要及时对资本老化(即折旧)带来的人均资本存量减少和人口增长导致的人均资本减少(因为被平均了)进行补充，也就是说老化多少补充多少，人口增加被平均掉多少就要补充多少，即补充的量就是nk和δk之和，整理一下，就是(n+δ)k，n+δ是对人均资本存量k的损耗程度，即新资本必须保持与n+δ相同的程度才能保证人均资本稳定，进而实现经济增长。即如果满足下式：\r\n\r\n![投资刚好抵消资本损耗，没有产生人均资本存量增量](/images/article/eg12.png)\r\n\r\n那就意味着人均储蓄(投资)刚好抵消掉了对人均资本的磨损，从而人均资本存量不变；再进一步说，如果满足下式\r\n\r\n![投资大于资本损耗，产生了人均资本存量增量](/images/article/eg13.png)\r\n\r\n那么意味着人均储蓄(投资)大于对人均资本的损耗，从而产生人均资本存量增量，即提升了人均资本存量。\r\n\r\n根据上述解释，新古典增长模型的方程可以描述为：\r\n\r\n![新古典增长模型的方程的直观描述](/images/article/eg14.png)\r\n\r\n资本广化就是维持人均资本存量k不变时的储蓄或投资，即`(n+δ)k`(sf(k)刚好等于)，资本深化就是人均储蓄(投资)大于维持人均资本存量k不变时所必需的数量。\r\n\r\n## 四、具有技术进步的新古典增长模型\r\n\r\n这里不再推导，直接给出具有技术进步的新古典增长模型的基本方程，如下\r\n\r\n![具有技术进步的新古典增长模型的基本方程](/images/article/eg15.png)\r\n\r\n依旧和没有技术进步的新古典增长模型基本方程一样，等式左边就是人均资本存量增量，其依旧等于人均储蓄(投资)减去各种因素对人均资本存量的损耗。只不过增加了技术增长率对人均资本存量的损耗。不再解释。\r\n\r\n## 五、新古典增长模型的稳态及其条件\r\n\r\n稳态是指包括资本存量和产出在内的有关内生变量将不会随着时间推移而变化的一种状态。从而，新古典增长模型中，稳态的条件就是人均资本存量增量为0，即\r\n\r\n![稳态的总体条件](/images/article/eg16.png)\r\n\r\n更进一步的，对于没有技术进步的新古典增长模型而言，稳态的条件就是\r\n\r\n![没有技术进步的新古典增长模型稳态的条件](/images/article/eg17.png)\r\n\r\n即\r\n\r\n![没有技术进步的新古典增长模型稳态的条件](/images/article/eg18.png)\r\n\r\n同理，对于具有技术进步的新古典增长模型的稳态条件就是\r\n\r\n![没有技术进步的新古典增长模型稳态的条件](/images/article/eg19.png)\r\n\r\n稳态除过可以用方程表示外，还可以用图形表示，详见教材(人大高鸿业第七版宏观部分p561，马工程下册p219)。\r\n\r\n如果资本存量不处于稳态水平怎么办呢？有两种可能，第一种，低于稳态水平时，即人均资本存量增量大于0(不要纠结，看一下图就明白了)，那么意味着投资超额抵消掉了对人均资本存量的损耗，从而人均资本存量k增加，随着人均资本存量的增加，投资增加的速度不及对人均资本损耗的速度快，那么之前增加的人均资本存量就会被这样损耗掉，从而人均资本存量k减少，又回到了稳态水平，第二种情况则是，高于稳态水平时，即人均资本存量增量小于0(不要纠结，看一下图就明白了)，那么意味着投资没有完全抵消掉对人均资本存量的损耗，即人均资本存量较大，这样会使得人均资本存量减少即向左移动，又会慢慢回到稳态水平。综上，当经济偏离稳定状态时，无论人均资本过多还是过少，都存在某种力量使其恢复到稳态，即新古典增长模型所确定的稳态是稳定的。\r\n\r\n需要注意的是，在不考虑技术进步的情况下，该模型中稳态的产量增长率由外生变量n即人口增长率决定，独立于储蓄率s；在加入技术进步因素后，技术进步会导致人均产出的持续增长，一旦经济达到稳定状态，人均产出的增长率就只取决于技术进步的速率α。\r\n\r\n## 六、应用新古典增长模型解释收入差异和增长率差异\r\n\r\n先是**储蓄率s增加对稳态收入的影响**，参照教材新古典增长模型稳态图可以发现，储蓄率增加后形成的新的储蓄曲线(绕原点逆时针转动)与对资本损耗曲线相较于一个更高水平的交点，即提高了稳态水平，也就是提升了总产出和人均资本存量；但是由于稳态中的产量独立于储蓄率，在长期内随着资本的积累，增长率逐渐降低，最终又会落回到人口增长的水平上。总结一下：储蓄率的增加不能影响到稳态增长率，但是能够提高收入的稳态水平。\r\n\r\n再看一下**人口增加对稳态收入的影响**。人口的增加意味着对人均资本存量平均的更加厉害，也就是加重了人均资本存量的损耗，即同等人均资本存量上人口增加后的(n+δ)k曲线会产生更高的人均资本存量损耗，即(n+δ)k曲线绕原点逆时针转动，那么与投资曲线的交点更低，即稳态水平更低，也就是降低了人均资本存量和总产出。进而得出的一个结论就是：人口增长率高的国家将会有低的稳态的人均资本存量，进而有低的人均收入。\r\n\r\n现在**对增长率差异进行解释**。直接给出结论：一个国家的初始人均资本比起稳态水平低的越多，则经济增长的越快也就是增长率越高；同样，一个国家的初始人均资本存量远高于它的稳态水平，那么它的资本存量将迅速减少(因为储蓄曲线也就是投资的增长在稳态之后不及对资本损耗的增长快)，随着这个国家的资本存量逼近稳态水平，资本存量下降的速度将趋近于0。\r\n\r\n## 七、内生增长理论模型\r\n\r\n新古典增长理论认为经济的长期增长来自于技术进步，但是这只是一个假设。内生增长理论则充分说明了技术进步对经济增长的影响。\r\n\r\n内生增长理论放弃了资本边际收益递减的假设，因为其认为如果对资本进行更加广义的解释，其边际收益不变的假设就显得更加合理。一些西方学者认为，知识是经济生产中的一种重要投入，如果把知识看作一种资本，那么与通常意义上的资本相比，假设知识表现出边际收益递减就显得不合理了。千言万语就是一点，资本边际收益不再递减，即生产函数曲线不再是随着资本的持续投入而变得水平。那么就有了如下简单的生产函数：\r\n\r\n![放弃边际收益不变假设的简单的生产函数](/images/article/eg20.png)\r\n\r\n上式Y是产出，K是资本存量，A是一个常数，用来衡量一单位资本所生产的产出，可以看出，没有反应出资本边际收益递减的性质，即它是一条向右上方倾斜的斜线，而不是随资本持续投入而变得水平。\r\n\r\n仍然假设收入中的一定比例s用于储蓄或投资，因此经济中的资本积累就可以描述为：\r\n\r\n![资本积累](/images/article/eg21.png)\r\n\r\n即资本存量增量=投资-折旧，将上式与生产函数Y=AK结合在一起，并经过一些运算之后就可以得到：\r\n\r\n![产出增长率](/images/article/eg22.png)\r\n\r\n这一公式表明，决定产出增长率△Y/Y的是什么，即只要sA \u003e δ,即使没有外生技术进步的假设，经济增长率也为正即可以一直增长。\r\n\r\n上述被称为AK模型的内生增长模型提供了一条内生化的稳态增长率路径，即如果可以被累积的生产要素由固定报酬(比如知识)，那么稳态增长率将会这些要素的累计率所影响。由关系式得知，储蓄率s越高越会被A累积，那么产出增长率越高。总之，该模型暗示了，那么能永久提高投资率的政府政策会使经济增长率不断提高。\r\n\r\n\u003cp style=\"font-family:Consolas;text-align:right\"\u003eLast updated at 08:48, October 27, 2019\u003c/p\u003e","cover":"/images/nopic.jpg","link":"economic-growth-model.html","preview":"\u003cp\u003e经济增长的决定因素、新古典经济增长模型、没有技术进步的新古典增长模型、具有技术进步的新古典增长模型、新古典增长模型的稳态及其条件、应用新古典增长模型解释收入差异和增长率差异、内生增长理论模型。\u003c/p\u003e\n","title":"解释经济增长的经济增长模型"},{"content":"\r\n\r\n## 一、乘数原理与加速数原理\r\n\r\n当投资变动时将会引起收入的变动，收入的变化量与引起这一变化量的投资变化量的比值k\u003csub\u003ei\u003c/sub\u003e被称为投资乘数。即\r\n\r\n![投资乘数公式](/images/article/ma1.png)\r\n\r\n调整一下形式，就变成了\r\n\r\n![调整后的投资乘数公式](/images/article/ma2.png)\r\n\r\n△K/△Y是投资增量对收入增量的比率，即增加一单位收入被用于投资的量，由于投资等于储蓄，那么△K/△Y就等于△S/△Y，即等于储蓄函数的斜率1 - β。那么投资乘数就变成了如下形式\r\n\r\n![投资乘数公式](/images/article/ma3.png)\r\n\r\n分母越大，k\u003csub\u003ei\u003c/sub\u003e越小，分母越小k\u003csub\u003ei\u003c/sub\u003e越大。那么β越大时分母越小那么投资乘数越大，一定的投资变动引起的收入变动就越大，具体而言，由于是投资对收入的影响，那么当投资为正(即正投资)时，国民收入都会增长，只是增长量不同，增长量取决于投资乘数的大小，而当投资为负(即负投资)时，国民收入就会减少，减少的量依旧取决于投资乘数的大小。\r\n\r\n以上是乘数原理。以下说明加速数原理。\r\n\r\n加速数原理是用来说明国民收入变动对投资变动的影响的。具体而言，当收入变动时将会引起投资支出的变动。用v表示加速数，I\u003csub\u003et\u003c/sub\u003e表示t时期总投资的变化量(即净投资量)，Y\u003csub\u003et\u003c/sub\u003e表示t时期的收入，Y\u003csub\u003et-1\u003c/sub\u003e表示上期收入，那么加速度被定义为：\r\n\r\n![加速数公式](/images/article/ma4.png)\r\n\r\n即投资增量在收入增量中的比值。由于是收入对投资的影响，那么我们可以看出，如果t期收入小于t-1期收入，那么意味着加速数是负数，也就是投资会负增长(即负投资)；而t期收入大于t-1期收入，那么意味着加速数是正数，也就是投资会正增长(即正投资)。\r\n\r\n## 二、乘数-加速数下经济周期的描述方程\r\n\r\n用乘数和加速数模型的交互作用来解释经济的周期性波动的理论模型被称为乘数-加速数理论模型。其基本假定是：\r\n\r\n1. 考虑三部门经济，且税收为0；\r\n2. 第二收入时间因素，本期收入由消费、本期投资与本期的政府购买组成；\r\n3. 消费函数采取长期形式，且本期消费是上一期的函数；\r\n4. 投资由自发投资与引致投资组成，引致投资由消费的变动量引起。\r\n\r\n根据前两条假设，产品市场均衡公式可以被描述为：\r\n\r\n![产品市场均衡公式](/images/article/ma5.png)\r\n\r\n上式分别是t期收入，t期消费支出，t期投资支出，t其政府购买支出。上式也说明了，在一个封闭经济中，根据凯恩斯主义的国民收入决定理论，t期收入等于t期消费、投资和政府购买之和。\r\n\r\n根据第三条假设，t期消费采取长期形式且为上一期的函数，那么消费函数为\r\n\r\n![消费函数](/images/article/ma6.png)\r\n\r\n由于t期的投资取决于加速数和消费的变动，那么t期的投资为\r\n\r\n![t期的投资](/images/article/ma7.png)\r\n\r\n由于t期政府购买既定，即\r\n\r\n![t期政府购买](/images/article/ma8.png)\r\n\r\n综上，可以得出经济周期的描述方程：\r\n\r\n![经济周期描述方程](/images/article/ma9.png)\r\n\r\n由于前两期的收入以及既定的政府支出已知，那么如果知道边际消费倾向β和加速数v，那么就可以根据上式推算出本期的国民收入。\r\n\r\n## 三、乘数-加速数对经济周期的解释\r\n\r\n首先，经济周期中的波动的根源在于经济体内部，乘数和加速数相互作用强化了经济波动的趋势。当政府支出(自主投资)增加，那么在乘数作用下国民收入得到乘数倍的增加。由于收入对投资具有引致作用，那么在加速数作用下，投资又加速的增加(需要注意的是这里在乘数作用下,国民收入是正增长，那么也就意味着加速数为正，即产生正投资)，结果就是国民收入在比原先更大的基数上结合乘数作用又获得增长，以此循环往复不断增长。这样，经济就会进入繁荣阶段，但是经济最终会遇到社会资源的制约，收入的增长迟早会达到社会资源所允许的最高限度，一旦经济达到顶峰就会停止扩张，当国民收入停止增长时，因加速数作用会使得投资减少，再通过乘数作用使得国民收入减少，二者再次相互作用使得经济进入衰退和萧条。如此循环往复，形成经济周期性波动。\r\n\r\n其次，从总体上看，宏观经济波动的幅度取决于边际消费倾向和加速数的大小(联系经济周期方程式)，如果这两个参数较小，则经济波动幅度较小。\r\n\r\n再次，由于投资-收入之间的这种不稳定的关系使得经济体系形成了周期性波动，因此，政府可以通过经济干预政策来缓解经济周期性波动，比如刺激投资等。\r\n\r\n最后，乘数-加速数模型作用是有条件的。一是必须以现存的全部资本被充分利用，同时还必须有充分的、未被利用的原材料和劳动力为前提，否则不可能增加资本、购买机器设备等净投资；二是假定每期收入或者总产量的增加是引起信投资增加的唯一因素，即不考虑外生变量引起的自发投资的作用；三是假定对于扩充设备所需要的资金，没有任何信贷上的障碍也不存在任何“瓶颈”现象。同时，乘数-加速数模型也表明，该模型必须假定一开始就有收入变动，不然加速数无法启动，引致投资也不会出现，从而乘数也无法发挥作用。\r\n\r\n\u003cp style=\"font-family:Consolas;text-align:right\"\u003eLast updated at 08:20, October 27, 2019\u003c/p\u003e","cover":"/images/nopic.jpg","link":"multiplier-accelerator-model.html","preview":"\u003cp\u003e乘数原理与加速数原理、乘数-加速数下经济周期的描述方程、乘数-加速数对经济周期的解释。\u003c/p\u003e\n","title":"解释经济周期的乘数-加速数模型"},{"content":"\r\n\r\n## 一、AD曲线的推导与移动\r\n\r\n\r\n**总需求曲线可以由IS-LM模型推导出来。**由于总需求曲线是产出(需求量)关于价格水平的曲线，那么在IS-LM模型中主要就是建立AD曲线中价格水平与LM曲线的关系，因为只有LM曲线的实际货币供给和价格水平有关。如下图所示\r\n\r\n![AD曲线推导](/images/article/aa1.png)\r\n\r\n当价格水平P较高时，那么在货币名义供给一定的条件下，实际货币供给更少，那么意味着LM曲线更靠近左上方，自然地与IS曲线的交点更靠近左上方，即对应的产出小，也就是**价格水平高时低产出**；\r\n\r\n当价格水平P较低时，那么在货币名义供给一定的条件下，实际货币供给更多，意味着LM曲线向右下方移动，自然地与IS曲线的交点更靠近右下方，即对应的产出更大，也就是**低价格水平对应高产出**；\r\n\r\n综上，**价格水平与产出或者总需求量是反相关的，即总需求曲线向右下方倾斜。**\r\n\r\n由于AD曲线经由IS-LM模型推导，那么这两条曲线的移动都会引起AD曲线的移动，具体而言：\r\n\r\n政府扩张性财政政策会引起IS曲线向右上方移动，那么就会与LM曲线相相交于较高的产出对应的均衡点，从而提升了既定价格水平下的总产量，即总需求曲线也向右方移动；反之，政府实行紧缩性的财政政策则会使得IS曲线与LM曲线相交于较低产出对应的均衡点，从而降低既定价格水平下的总产量，即总需求曲线向左方移动。\r\n\r\n货币当局实行扩张性的货币政策，那么也就意味着既定价格水平下实际货币供给增加，会引起LM曲线右移，右移后的LM曲线与IS曲线相交于较高价格水平对应的均衡点，从而提升了既定价格水平下的总产量，即总需求曲线也右移；若货币当局实行紧缩性的货币政策，那么在既定价格水平下实际货币供给减少，会引起LM曲线左移，左移后的LM曲线与IS曲线相交于较低的产出对应的均衡点，从而使得既定价格水平下总产量减少，即AD曲线向左方移动。\r\n\r\n## 二、AS曲线的推导与移动\r\n\r\nAS曲线是由劳动市场均衡、生产函数推导出来的。凯恩斯主义总供给曲线是一种短期总供给曲线，其基本假设是货币工资的下降具有“刚性”，其基本含义是：人们对货币工资的下降会进行抵抗，但是欢迎货币工资上升，也就是说货币工资只能上升，但是不能下降。由于AS曲线根据劳动市场均衡和生产函数推导而来，那么先看一下劳动市场均衡：\r\n\r\n![劳动市场均衡](/images/article/aa2.png)\r\n\r\n上图反映了劳动市场的均衡，当市场价格水平高于P\u003csub\u003e0\u003c/sub\u003e时，那么在货币工资不变的情况下意味着实际工资水平W/P下降，从而低于劳动市场均衡时的实际工资水平W/P\u003csub\u003e0\u003c/sub\u003e，那么这种情况下劳动市场供不应求，企业之间会互相争夺劳动者，他们会选择提高货币工资水平W，按照货币工资刚性假设，货币工资上升不会受到阻碍，那么随着货币工资的上升，实际工资水平又会回到劳动市场均衡时的水平，从而实现劳动市场均衡，此时实现充分就业，那么劳动市场能够提供的劳动力数量就是N\u003csub\u003e0\u003c/sub\u003e。**再进一步说，任何高于P\u003csub\u003e0\u003c/sub\u003e的价格水平都会在企业提升货币工资的情况下快速回到劳动力市场均衡时的实际工资水平，即任何高于P\u003csub\u003e0\u003c/sub\u003e的价格水平都能实现充分就业，或者说任何高于P\u003csub\u003e0\u003c/sub\u003e的价格水平都能拥有充分就业时的劳动力数量。**\r\n\r\n相反，当市场价格水平低于P\u003csub\u003e0\u003c/sub\u003e时，那么意味着在货币工资不变的情况下实际工资W/P会提升，从而高于劳动市场均衡时的实际工资水平W/P\u003csub\u003e0\u003c/sub\u003e，这种情况下意味着劳动力市场供过于求，那么只有在降低货币工资的情况下劳动力市场才能实现均衡，但是由于货币工资刚性假设，在工人的抵抗下货币工资不不可能降低，那么企业也就只有雇佣较高货币工资水平下的劳动力数量了，如下图\r\n\r\n![市场价格水平低于P\u003csub\u003e0\u003c/sub\u003e时的劳动市场供求](/images/article/aa3.png)\r\n\r\n可见企业之雇佣了N\u003csub\u003e2\u003c/sub\u003e的劳动力数量，远少于劳动市场均衡时的N\u003csub\u003e0\u003c/sub\u003e。更进一步，若价格水平持续降低，那么企业雇佣的劳动力数量越少，越低于充分就业水平，即失业人数更多。**即任何低于P\u003csub\u003e0\u003c/sub\u003e的价格水平都无法实现充分就业，都无法提供充分就业时的劳动力数量，且价格水平越低，就业人数越少，失业人数越多。**\r\n\r\n以上分析了价格水平与劳动力数量的关系，那么劳动力最终是作为生产要素要通过生产函数来形成产出的，假定一个经济社会在一定技术水平下使用总量意义上的劳动和资本两种生产要素进行生产，那么宏观生产函数就可以表示为：\r\n\r\n![宏观生产函数](/images/article/aa7.png)\r\n\r\n式中，y为总产出，N为整个社会的就业水平或者就业量，K为整个社会的资本存量；为避免复杂，技术水平没有明确表示出来。由于在生产的短期内，资本存量和技术水平不会有很大改变，所以姑且认为而这时不变的常数，那么决定整个经济社会产出的就是经济社会就业水平N了，从而短期宏观生产函数可以简写为：\r\n\r\n![调整后的短期宏观生产函数](/images/article/aa8.png)\r\n\r\n此外，西方宏观经济学假定宏观生产函数有两条重要的性质：一是总产量随着总就业量的增加而增加；二是在技术不变和K为常数的假设条件下，由于“边际收益递减规律”的作用，随着总就业量的增加，总产量按递减的比率增加。这样，关于总就业量的生产函数曲线就可以如下图表示了：\r\n\r\n![总就业量的生产函数曲线曲线](/images/article/aa4.png)\r\n\r\n那么现在联系一下劳动市场的就业状况，假定劳动力市场实现均衡时的价格水平为P\u003csub\u003e0\u003c/sub\u003e，那么从上述对劳动力市场的分析得知，若价格水平高于P\u003csub\u003e0\u003c/sub\u003e，那么劳动力市场总能因企业提高货币工资而提供充分就业时的就业量，即劳动力市场均衡时的就业量，那么也就意味着凡是高于P\u003csub\u003e0的\u003c/sub\u003e价格水平得到的就业量是一样的，从而产出也就一样，即在以价格水平为横轴，产出为纵轴的坐标系当中，高于P\u003csub\u003e0\u003c/sub\u003e的价格水平对应的AS曲线是一条垂线，即高于P\u003csub\u003e0\u003c/sub\u003e价格水平上的任意价格水平产出一致。\r\n\r\n那么在价格水平低于P\u003csub\u003e0\u003c/sub\u003e时，劳动力市场只能提供比充分就业更小的就业量，由于生产函数是增函数，那么较小的就业量实现较低的产出，且价格水平越低，就业量越小从而产出越低，那么也就是说，在以价格水平为横轴，产出为纵轴的坐标系当中，低于P\u003csub\u003e0\u003c/sub\u003e的价格水平对应的AS曲线是一条向右上方(或左下方)倾斜的曲线。\r\n\r\n综上，得出AS曲线如下图所示\r\n\r\n![AS曲线](/images/article/aa5.png)\r\n\r\n为了分析方便，西方经济学家往往把左下方倾斜的部分近似的看做水平线。\r\n\r\n既然AS曲线通过劳动市场均衡和生产函数推导出来，那么二者的移动必然会引起AS曲线的移动，具体来说：\r\n\r\n生产函数变动导致的AS曲线变动：若经济中出现技术进步，而这种技术进步只会影响到劳动的平均生产率而不会影响其边际生产力，也没有发生劳动就业量的增加或者减少，那么生产函数曲线会向上移动，即技术进步后同一就业水平上产出增加；那么AS曲线就会向右移动。因为就业水平由价格水平通过劳动市场决定，即既定价格水平的既定就业量上产出增加，即既定价格水平产出增加，那么必然是AS曲线右移；反之同理。\r\n\r\n劳动需求变动导致的AS曲线变动：在其他条件都相同，只有技术进步因素使平均劳动生产率和边际劳动生产率同时得到提高，对劳动需求增加，即劳动需求曲线和生产函数曲线都会向上方移动，从而会使总供给曲线向右移动更大的距离，不再解释，通过推导曲线的过程就可以得知。另外，在其他条件不变时，如果资本存量增加，同时，对劳动的需求也会增大，那么也会使得劳动需求曲线向右上移动，从而总供给曲线向右方移动。\r\n\r\n劳动供给变动导致的总供给曲线的变动：劳动供给取决于劳动者的劳动意愿和偏好，也取决于人口和劳动力的多少。如果人们在收入增加之后更加注重休闲，那么劳动供给就会减少，从而劳动供给曲线左上方移动，使得充分就业水平降低，那么生产减少，即AS曲线向左边移动；反之同理。\r\n\r\n\r\n## 三、古典总供给曲线与凯恩斯总供给曲线\r\n\r\n凯恩斯总供给曲线适用于短期分析或者经济萧条情况下，即曲线中的水平形状。它表示在经济萧条情况下，价格处于最低水平既不会下降也不会上升，因为在经济严重萧条时，由于存在大量闲置不用的劳动力和资本设备，所以当整个社会的产出量或者国民收入增长时，只是闲置劳动力和机器设备得到了充分利用，资本家不会提升价格，但是到了充分就业状态下，国民收入的增长则会引起价格提升。\r\n\r\n古典经济学派认为，在生产的长期内，价格和货币工资都具有充分的伸缩性，也就是说经济一直处于充分就业状态。具体而言，当价格水平上升时和凯恩斯总供给曲线一样企业会提升货币工资从而使得劳动力市场均衡达到充分就业进而得到充分就业量，即高于劳动力市场均衡价格水平的价格水平都会得到充分就业量，从而产出一致，即总供给曲线是垂线；当价格水平下降时，由于价格和货币工作完全可伸缩，也就是货币工资W会发生和价格水平相同幅度的变动，从而两个变动相互抵消仍然处于充分就业水平，从而产出一致，即低于劳动力市场均衡价格水平的价格水平也会得到充分就业量，从而产出一致，即总供给曲线还是垂线。**综上，古典总供给曲线就是一条劳动力市场均衡时价格水平对应的充分就业的恒定的产出，即一条垂线。**\r\n\r\n## 四、AD-AS模型：总供给曲线的不同特征的经济含义\r\n\r\n用上述古典总供给曲线替代凯恩斯供给曲线中的长期部分(即垂直的部分)，就可以得到各种总供给曲线的综合，如下图所示\r\n\r\n![AD-AS模型：各种总供给曲线的综合](/images/article/aa6.png)\r\n\r\n1. 当价格出现刚性时，经济中就会出现价格不变时的凯恩斯总供给曲线，即一条水平线。含义是：总需求的增加只会引起经济中的生产要素充分利用，比如闲置的劳动力和设备，最终只会通过生产函数引起产出增加而不会使得价格水平提升。即，此时经济中的供求，不存在价格调节，只存在数量调节。\r\n2. 当价格处于黏性或弹性(即可变动)且总供给可增加时，经济中就会出现价格可变动时的凯恩斯总供给曲线。含义是：总需求的增加仍然会引起生产要素充分利用，但是总供给的增加速度已经慢下来了，也就是没有总需求增加速度快，那么就会在提升产量的同时引起物价上涨。即，此时经济中的供求，即存在价格调节，也存在数量调节。\r\n3. 而当价格处于黏性或弹性，但是总供给无法增加时，经济中就会出现古典总供给曲线。含义是：经济处于充分就业状态，技术水平也无法改变，总供给无法增加，从而总需求的增加只会引起物价上升。即，此时经济中的供求，只存在价格调节，不存在数量调节。\r\n\r\n## 五、AD-AS模型对经济波动的解释\r\n\r\n从AD-AS模型的视角看，宏观经济短期波动有两个基本原因：AD曲线移动和AS曲线移动。在宏观经济学中，使得AD曲线发生移动的事件被称为需求冲击，使得AS曲线发生移动的事件被称为供给冲击。\r\n \r\n从上图(看价格可变动时的凯恩斯总供给曲线)可以看出：\r\n\r\n1. 当AD曲线左移意味着同等价格水平上产出减少，这是由于远离充分就业引起的，即AD曲线左移意味着失业；\r\n2. 当AD曲线右移意味着同等价格水平上产出增加，这是由于就业增加通过影响生产函数而引起的，但是产出的增加速度不及需求增加速度快，使得价格上升，即通货膨胀；\r\n3. 当AS曲线左移时，意味着同等价格水平上产出减少和同等产出上物价上涨，前者是因为失业引起的，即劳动力减少通过生产函数影响产出，后者则是物价上涨，即AS左移意味着会陷入失业与通胀并存的滞胀状态。\r\n\r\n\u003cp style=\"font-family:Consolas;text-align:right\"\u003eLast updated at 16:48, October 26, 2019\u003c/p\u003e","cover":"/images/nopic.jpg","link":"analysis-of-total-supply-and-total-demand.html","preview":"\u003cp\u003eAD曲线的推导与移动、AS曲线的推导与移动、古典总供给曲线与凯恩斯总供给曲线、AD-AS模型：总供给曲线的不同特征的经济含义、AD-AS模型对经济波动的解释。\u003c/p\u003e\n","title":"宏观经济总供求分析"},{"content":"\r\n\r\n## 一、汇率的标价与汇率制度\r\n\r\n汇率是一国货币折算成另一国货币的比率，表示两个国家货币之间的互换关系。\r\n\r\n汇率的标价有两种方法，一种是直接标价法，是用一单位外币作为标准，折算为一定数额的本币来表示的汇率，如今天(2019年10月25日20时46分)一单位外币(美元)折算为一定数额本币(人民币)的汇率为￥7.0699，这种情况下，汇率的提升意味着一单位外币能够兑换更多数量的本币，即外币的升值或本币的贬值，相反，汇率的下降意味着外币的贬值或本币的升值。另一种是间接标价法，即用一单位本币作为标准，折算为一定数额的外币来表示汇率，例如今天(同上)一单位本币(人民币)折算为一定数额的外币(美元)的汇率是$0.1414，这种标价法下，汇率的提升意味着一单位本币折算的外币的增加，即本币的升值或外币的贬值，相反，利率的下降意味着外币的升值或本币的贬值。\r\n\r\n直接标价法与间接标价法是倒数的关系，可以通过倒数来实现互换。\r\n\r\n汇率制度指一国(或地区)货币当局对本国汇率变动的基本方式所作的一系列制度安排或规定。分为固定汇率制和浮动汇率制。\r\n\r\n固定汇率制指一国货币同他国货币的汇率基本固定，其波动限于一定的幅度之内。在固定汇率制下，一国中央银行随时准备按事先承诺的价格从事本币与外币的买卖。一般情况下，固定汇率制的运行通过货币市场套利行为影响一国货币供给。比如，以美国为例，若美联储宣布将汇率固定在1美元兑换100日元上，那么为了有效实行这种政策，美联储就要有美元储备和日元储备。若由于种种原因，外汇市场的均衡汇率为1美元兑换150日元，即如果套利者把1美元交给美联储只能得到(购得)100日元，但是如果在外汇市场上则可以换到(购得)150日元，这其中相对于美联储的标价就产生了50日元的盈余，那么套利者将这150日元又卖给美联储可以得到1.5美元，从而盈利0.5美元，即美联储多向货币市场投放了0.5美元，也就是美联储从套利者手中购买这些日元时，向套利者支付的美元(增量)移动增加了美国货币供给，美元供给增加意味着美元贬值，即外汇市场上一单位美元能够兑换的日元的日元减少即小于150日元，这样汇率就会慢慢降低到1美元兑换100日元上。相反，如果外汇市场为1美元兑换50日元，那么套利者会通过向美联储用1美元购买100日元，然后把这100日元在外汇市场上卖出去(兑换)就可以得到2美元，即净赚1美元而获利，而当美联储向套利者卖出这100日元时美联储会得到1美元会自动减少美元货币供给，从而美元升值，即外汇市场上一单位美元兑换日元增加，慢慢也会回到一单位美元兑换100日元的水平。\r\n\r\n浮动汇率制指一国不规定本国货币与他国货币的官方汇率，听任汇率由外汇市场的供求关系自发的决定，货币当局不承担维持汇率波动幅度的义务。\r\n\r\n## 二、名义汇率与实际汇率\r\n\r\n上面所说的汇率就是名义汇率，即两个国家通货的相对价格，其没有考虑两个国家的价格水平情况。比如，如果本币对外币升值，即一单位本币可以兑换更多外币，那么购买外国商品一定是划算的吗？不一定，如果外国商品的价格水平(以外币计)相对升高了，那么即使本币升值也对购买外国商品无益。所以，有必要通过价格水平调整一下名义汇率，使调整后的汇率可以反映两国价格水平差异，这样才可以真正衡量货币的购买力，调整后的汇率就是实际汇率。\r\n\r\n一国对他国的实际汇率(间接标价法表示)等于该国对他国的名义汇率与该国对他国的物价水平比率之积。举个例子，假定美元对日本的名义汇率(间接表示法，即以一单位本币表示外币)为1:120，即名义汇率为120，再假定美国的一辆汽车价值1万美元，日本的一辆汽车价值240万日元，那么美国对日本的物价水平比为1/240，那么美元对日元的实际汇率就是120×1/240＝0.5，即如果考虑两个国家价格水平情况，美元是不及日元值钱的，1美元相当于0.5日元。\r\n\r\n![其中，ε为名实际汇率,е为名义汇率，P为本国产品价格，Pf为外国产品价格](/images/article/mf-1.png)\r\n\r\n即，**实际汇率＝名义汇率×物价水平比率**，那么在名义汇率一定的条件下，实际汇率的大小取决于物价水平比率，或者说取决于本国物价水平与他国物价水平。如果实际汇率较高(升值)，那么意味着本国物价水平更高而他国物价水平更低，从而使得物价水平比率更高，这种情况下本国商品相对昂贵(因为物价水平高)外国商品相对便宜。相反，如果实际汇率更低(贬值)，那么意味着本国物价水平更低而他国物价水平更高从而降低了物价水平比率，这样本国商品相对便宜，他国商品更贵。\r\n\r\n## 三、净出口与资本净流出\r\n\r\n一个开放经济以两种方式和其他经济相互交易，一是在世界产品市场上购买或者销售产品与劳务，二是在世界金融市场上购买或销售股票和债券这类资本资产。\r\n\r\n净出口与第一种方式经济活动相关。在影响净出口的诸多因素中，汇率与国内收入水平被认为是最重要的两个因素。具体而言，若实际汇率降低，那么国内商品更便宜，从而外国人想购买更多的本国产品而本国人减少的购买外国产品(因为外国商品贵)，这就导致该国净出口增加，反之同理，总而言之，一国的净出口反向依赖于实际汇率(即(本币对外币)实际汇率越低也就是本币贬值，净出口更大，一方面因为外币升值外币购买力增强，另一方面本币贬值购买外国商品成本提升购买本国商品成本低，深层次的原因就是本国商品价格下降)。而当一国收入升高时，该国消费者用于购买本国产品和进口产品(外国产品)的支出都会增加，从而净出口反向地取决于一国的实际收入。这两个因素中，对净出口影响最大的是汇率，即**净出口是实际汇率的减函数**，以横轴为净出口，纵轴为实际汇率，那么净出口函数曲线向右下方倾斜，即实际汇率越低净出口越大(即本国商品价格下降引起外国人购买，外国商品价格上升导致本国人减少购买)，反之同理。综上，净出口函数为：\r\n\r\n![净出口函数](/images/article/mf-2.png)\r\n\r\n那么对应的净出口曲线就是\r\n\r\n![净出口曲线](/images/article/mf-3.png)\r\n\r\n资本净流出指本国居民购买的外国资产与外国人购买的本国资产之间的差额。一国和世界各国之间的资本流动一般采取两种形式:本国对外国的直接投资、本国对外国的有价证券投资。而在影响资本净流出的诸多因素中本国的实际利率是较重要的因素。当本国实际利率较高时，那么投资者认为同样一笔钱投资在本国收益更大，因为高利率高收益，从而本国流向外国的资本减少。更甚至，外国资本也会因为本国高利率而流入，即资本净流出为负数；而当本国实际利率较低时，那么投资者认为同样一笔钱投资在外国收益更大，从而资本外流，此时资本净流出为正值。综上，**资本净流出是本国实际利率的减函数**，即本国利率越高，资本净流出越少，对本国投资越大。反之同理。那么在以横轴为资本净流出，纵轴为本国实际利率的坐标系中，资本净流出曲线也是一条向右下方倾斜的曲线。综上，资本净流出函数可以描述为\r\n\r\n![资本净流出函数](/images/article/mf-4.png)\r\n\r\n对应的曲线为\r\n\r\n![资本净流出曲线](/images/article/mf-5.png)\r\n\r\n净出口衡量一国出口与其进口之间的不平衡，而资本净流出衡量本国居民购买的外国资产(资本外流)与外国人购买的本国资产(资本流入)之间的不平衡。需要特别注意的是，**对一国而言，资本净流出必然等于净出口**。因为，当一国有了净出口即存在贸易盈余，那么意味着该国人用他们的产品和劳务获得了更多的外国通货，而该国人必然用这些通货购买外国资产，即资本净流出。相反，如果一国存在贸易赤字，就意味着国外资本的流入。\r\n\r\n## 四、开放经济的蒙代尔-弗莱明模型的两个假设\r\n\r\n蒙代尔-弗莱明模型与IS-LM模型密切相关，它们都强调了产品市场与货币市场的相互作用，它们都假定物价水平是固定的，它们都是在说明是什么因素引起的总产出的短期波动。主要差异在于IS-LM模型假设的是一个封闭经济，而蒙代尔-弗莱明模型假设的是一个开放经济；IS-LM模型假设是通过利率影响产出来说明总产出的变动，而蒙代尔-弗莱明模型则是通过实际汇率与产出的影响来说明产出变动。\r\n\r\n即蒙代尔-弗莱明模型与IS-LM模型直观上的区别就是模型的纵轴是实际汇率而不是利率，因为前者研究的是开放经济中总产出的被影响。\r\n\r\n**蒙代尔-弗莱明模型的一个关键假设是开放经济的资本是完全流动的，即“资本完全流动的小型开放经济”，这也就意味着小型开放经济中的利率r必然等于世界利率rω。**为什么呢？因为资本完全流动！当国内利率高于世界利率时，外国人会认为向该国投资能够获得更高的收益，从而资本大量流入，资本的流入必然会使得该国的利率降低到世界水平；相反，如果该国的利率低于世界利率，那么该国资本就会外流以谋取高收益，资本的流出使得国内资本减少从而利率提高(就是货币市场的均衡过程)。因此，这这个前提假设下国际资本流动之迅速，可以使得国内利率等于世界利率。\r\n\r\n**蒙代尔-弗莱明模型的另一个假设是国内物价水平与国外物价水平都是固定的，**即实际汇率与名义汇率同比例，即名义汇率可以替代实际汇率通过名义利率来说明实际汇率。那么净出口函数就可以使用名义汇率替换实际汇率。\r\n\r\n## 五、开放经济的蒙代尔-弗莱明模型的IS*曲线及移动\r\n\r\n不同于封闭经济，开放经济的总产出需要加上净出口一项，即开放经济中产品市场的总产出函数为：\r\n\r\n![开放经济中产品市场的总产出函数](/images/article/mf-6.png)\r\n\r\n根据开放经济的蒙代尔-弗莱明的两个假设，国内利率等于世界利率，名义汇率替换实际汇率，那么总产出函数就变成了：\r\n\r\n![调整后的总产出函数](/images/article/mf-7.png)\r\n\r\n我们把它称之为IS\\*方程。(星号提醒我们该函数把利率保持在不变的世界利率世界利率水平上)，如果把上述方程绘制在横轴为收入/产出，纵轴为(名义)汇率的图形上，就得到了IS\\*曲线，如下\r\n\r\n![IS*曲线](/images/article/mf-8.png)\r\n\r\n即(名义)汇率的上升会引起总产出的下降，利率的下降会引起总产出的上升。具体传导过程为：由于净出口曲线是汇率的反函数，那么意味着利率降低是净出口较大，从而净出口对总产出的贡献大，那么总产出也会随之升高，反之同理。更深层的解释(传导)就是：随着汇率的上升，本国货币贬值，那么意味着一单位外币能够兑换的本国国币数量上升，那么就会刺激外国对本国商品的需求；而同样由于本国货币的贬值能够兑换的外币更加少成本更高那么会减少对进口(对国外商品需求)，那么由于出口额的增加和进口额的减少必然会使得总产出增加。\r\n\r\nLM\\*曲线的移动：在其他因素不变时，**政府购买增加，那么IS\\*曲线向右方移动**，即同等汇率水平下产出增加或者同等产出水平上汇率增加。因为净出口只是总产出的一部分，政府购买增加会通过影响总产出函数的参数g来影响总产出，即同等汇率水平上总产出会增加；反之，**政府购买减少时，IS\\*曲线向左方移动**。\r\n\r\n## 六、开放经济的蒙代尔-弗莱明模型的LM*曲线及移动\r\n\r\n蒙代尔-弗莱明模型用与IS-LM模型相似的方程来表示货币市场的均衡：\r\n\r\n![货币市场方程](/images/article/mf-9.png)\r\n\r\n即实际货币供给M/P等于货币需求L(r,y),而实际货币需求反向取决于利率r，正向取决于收入y，其中货币供给M是由中央银行控制的外生变量，即假定不变。由于国内利率等于世界利率的假设，那么上述货币市场均衡方程可以写成：\r\n\r\n![利率调整后的货币市场方程](/images/article/mf-10.png)\r\n\r\n我们将其称之为LM\\*方程，同样在货币供给M/P固定的情况下通过LM推导过程来推导LM曲线，其实就是把IS-LM模型中的LM搬过来，唯一不同的是利率是固定的，即国内利率等于世界利率，那么就可以从LM曲线中得到固定利率下的产出，如下\r\n\r\n![LM*曲线](/images/article/mf-11.png)\r\n\r\nLM\\*曲线之所以垂直是因为汇率并没有影响LM曲线，只是固定的利率即与世界利率相等的国内利率通过LM曲线影响产出。\r\n\r\nLM\\*曲线的移动：当**货币供给量增加时会使得LM曲线右移**，从而同等利率水平上(等同于世界利率的国内利率)对应产出增加，那么对应的LM\\*曲线就会右移，即无论何种汇率水平上产出增加；相反，货币供给量M减少时，LM\\*曲线向左移动。\r\n\r\n## 七、蒙代尔-弗莱明模型\r\n\r\n将上述IS\\*曲线和LM\\*结合起来就可以得到蒙代尔-弗莱明模型，即联立IS\\*方程与LM\\*方程，如下\r\n\r\n![蒙代尔-弗莱明模型表达式](/images/article/mf-12.png)\r\n\r\n那么就是求IS\\*曲线与LM\\*曲线的交点，这个交点就是产品市场和货币市场的共同均衡点，该点就是两个市场共同均衡时的收入与对应的汇率水平。\r\n\r\n![蒙代尔-弗莱明模型曲线](/images/article/mf-13.png)\r\n\r\n该模型可以用来说明收入y和汇率e对经济政策变动做出什么反应。\r\n\r\n## 八、浮动汇率制下蒙代尔-弗莱明模型的财政政策和货币政策效果\r\n\r\n浮动汇率制下，汇率由市场供求力量决定，允许汇率对经济状况的变动做出反应，自由变动。该种情况下，汇率e调整可以达到开放经济下货币市场和产品市场的共同均衡。\r\n\r\n先是浮动汇率制度下，该模型下的财政政策效果。\r\n\r\n政府实行扩张性财政政策，那么会使得IS\\*曲线右移，如下图\r\n\r\n![浮动汇率制下蒙代尔-弗莱明模型的财政政策效果](/images/article/mf-14.png)\r\n\r\n可以发现，**汇率的提升并没有改变总产出，即开放经济下在浮动汇率制下政府的财政政策只会引起汇率的提升但是却不会增加产出，这是因为LM\\*曲线是垂直的。**但是在封闭经济中LM曲线是向右上方倾斜的，那么IS曲线的移动会引起利率和产出的双变动。为什么会产生这种情况呢？封闭经济中产出的增加有赖于投资，但是开放经济中则包括了净出口，政府扩张性财政政策会增加投资从而引起国民收入上升，但是该政策则会引起汇率提升引起净出口减少，这样二者就相互抵消掉了，所以产出没有变动。\r\n\r\n再考虑开放经济中浮动汇率制下货币政策的效果。\r\n\r\n一国货币当局实行扩张性财政政策，那么会引起LM\\*曲线的右移，即如下\r\n\r\n![浮动汇率制下蒙代尔-弗莱明模型的货币政策效果](/images/article/mf-15.png)\r\n\r\n可以发现，**汇率的降低了且总产出提升，即开放经济下在浮动汇率制下政府的货币政策会引起汇率的下降和产出的增加。**这和IS-LM模型中的政策效果是类似的，即货币政策都会引起封闭经济或开放经济下总产出的增加，但是作用机制是不同的。\r\n\r\n在封闭经济中，扩张性货币政策在交易需求一定的条件下会降低利率，从而刺激了产品市场的投资从而引起产出增加。但是在小型开放经济中，利率是固定的，那么就不存在这一传递渠道了，那么国民收入增加由什么引起呢？答案是汇率，汇率的下降意味着本国货币贬值，即本国商品便宜外国商品较贵，那么就会使得净出口增加，从而净出口引起总产出增加，而不是投资引起总产出增加。\r\n\r\n## 九、固定汇率制下蒙代尔-弗莱明模型的财政政策和货币政策效果\r\n\r\n在固定汇率制度下，一国中央银行宣布一个汇率值并随时准备买卖货币以便将汇率保持在宣布的水平上，也就意味着政府货币供给是可变的，不再是外生变量。\r\n\r\n若一国政府实行扩张性财政政策，那么会首先会引起IS\\*曲线的右移，即如下\r\n\r\n![固定汇率制下蒙代尔-弗莱明模型的财政政策效果](/images/article/mf-16.png)\r\n\r\n从而造成了汇率提升。由于固定汇率制下货币当局会随时准备货币的买卖，即货币供给是变动的，那么由于外汇市场汇率的上升，套利者会从外汇市场买入外币然后没卖给货币当局以套利，货币当局多支付的货币就构成了货币供给，从而又会引起LM\\*曲线右移，如下\r\n\r\n![固定汇率制下蒙代尔-弗莱明模型的财政政策效果](/images/article/mf-17.png)\r\n\r\n从而LM*2与IS*2的新的交点实现了开放经济下产品市场与货币市场的共同均衡，可见**汇率复位**了，但是**产出增加**了。\r\n\r\n若一国货币当局实行扩张性货币政策，那么最初的影响是会引起LM\\*曲线右移，即降低了汇率，也就是外汇市场利率下降，那么套利者首先向货币当局出售本国通货然后获得外币，然后用外币去外汇市场套利。货币当局对本国通货的回收会减少本国货币供给使得LM\\*曲线左移，又返回到了初始的LM\\*曲线位置，可见**产出和汇率均没有变化**。\r\n\r\n## 十、对开放经济下蒙代尔-弗莱明模型的政策效应的总结\r\n\r\n![开放经济下蒙代尔-弗莱明模型的政策效应总结](/images/article/mf-18.png)\r\n\r\n可见，蒙代尔-弗莱明模型说明了开放经济中财政政策和货币政策的效果，即开放经济中政策效果取决于所实行的汇率制度。在浮动汇率制度下只有货币政策可以影响收入，财政政策则因为汇率上升引起的净出口下降和政府支出增加引起的投资增加所抵消，从而财政扩张无法影响总产出。在固定汇率制度下，只有财政政策会影响收入，货币政策正常潜力的丧失则是因为货币供给全部用在了把汇率维持在所宣布的水平上了。\r\n\r\n**补充**：通过开放经济中的蒙代尔-弗莱明模型一样可以推导出开放经济中的总需求曲线，其走向与封闭经济中的总需求曲线无异。\r\n\r\n\u003cp style=\"font-family:Consolas;text-align:right\"\u003eLast updated at 10:57, October 26, 2019\u003c/p\u003e","cover":"/images/nopic.jpg","link":"mundell-fleming-model-in-open-economy.html","preview":"\u003cp\u003e汇率的标价与汇率制度、名义汇率与实际汇率、净出口与资本净流出、开放经济的蒙代尔-弗莱明模型的两个假设、开放经济的蒙代尔-弗莱明模型的IS*曲线及移动、开放经济的蒙代尔-弗莱明模型的LM*曲线及移动、蒙代尔-弗莱明模型、浮动汇率制下蒙代尔-弗莱明模型的财政政策和货币政策效果、固定汇率制下蒙代尔-弗莱明模型的财政政策和货币政策效果、对开放经济下蒙代尔-弗莱明模型的政策效应的总结。\u003c/p\u003e\n","title":"开放经济下蒙代尔-弗莱明模型"},{"content":"\r\n\r\n## 一、凯恩斯理论的循环推论与解决方案IS－LM模型\r\n\r\n从推导IS曲线的传导可以看出，产品市场均衡产出是由货币市场的利率决定的；而货币市场的利率又是由产品市场的产出决定的。如果两个市场相互决定，那么就意味着这两个市场的均衡永远是相对的。因为利率决定的产出的增加意味着同等利率水平上交易所需的货币量增加，在货币供给一定量的条件下，只有减少投机需求即提升利率才能保证货币市场的均衡(即`m = m1 + m2`)；伴随着利率的提升产品市场的投资就会减少，投资的减少意味着产品市场均衡被打破，因为储蓄可不受投资直接影响，原来的较高储蓄无法与现在较低的投资等同，产品市场必然失衡。紧接着由于产品市场投资减少，作为影响国民收入的一部分，国民收入必然会减少，国民收入的减少意味着交易需要的货币量的减少，但是先前已经投入了较高的货币供给，即货币市场存在超额货币供给，那么为了使得货币市场均衡就必然要在货币供给量一定的条件下提升货币投机需求即降低利率，从而实现货币市场均衡；紧接着，利率的降低又会刺激产品市场投资需求从而使得国民收入增加，随后产品市场会均衡，进而引起货币市场较高的货币交易需求，又打破了货币市场的均衡......\r\n\r\n可见，循环推论使得产品市场与货币市场永远无法实现共同均衡，即使实现了单一市场均衡那么也会很快因为另一市场的失衡对应的调整措施陷入失衡状态。循环往复，单一市场永远无法长久均衡，两个市场永远无法共同均衡。\r\n\r\n凯恩斯的后继者发现了这一循环推论的错误，通过将两个市场通过某种手段结合起来实现了产品市场和货币市场的一般均衡，即IS－LM模型，从而解决了循环推论的错误。\r\n\r\n这个手段就是反向推导LM曲线，即国民收入通过交易需求函数影响交易需求然后通过货币市场均衡条件影响投机需求然后通过投机需求函数影响货币市场的利率，那么反过来说也是一个道理。即建立货币市场的利率与国民收入的关系，从而就可以与产品市场利率与国民收入的关系联合起来放在一个坐标系里面讨论，二者走向相反，必然会存在一个交点，这个交点就是两个市场共同均衡时的决定产品市场国民收入的货币市场的利率水平和对应的决定货币市场利率水平的产品市场的国民收入。这个实现两个市场共同均衡的模型就是IS－LM模型。\r\n\r\nIS－LM模型不过是将两个曲线放在一个坐标系里面讨论，因此暂不涉及推导，直接放在一起就可以了，其图形如下\r\n\r\n![IS－LM模型](/images/article/image9.png)\r\n\r\n图中的交点就是两个市场的共同均衡点，即在这个点上，产品市场不会因为货币市场利率变化而失衡；货币市场不会因为产品市场产出变化而失衡。从而二者不再循环推论，实现共同均衡，即使失衡，也会通过调整实现最终的均衡。\r\n\r\n那么IS－LM模型除过均衡点之外的广大部分，即失衡点是什么含义以及如何实现均衡呢？\r\n\r\n## 二、IS－LM模型非均衡的四个区域的含义及实现均衡的过程\r\n\r\n可以将非均衡分为四个部分，如下图所示\r\n\r\n![示意图](/images/article/image7.jpg)\r\n\r\n在第I区域，随便找一个点，假设点a，作点a到x轴的垂线，那么意味着点a与该垂线和IS曲线的交点有着相同的国民收入，但是点a的利率r明显比交点的利率大，利率与投资反相关，那么也就意味着点a的投资小于交点的投资或储蓄(因为交点处于均衡点，投资与储蓄相等)，也就意味着点a是投资小于储蓄的非均衡，由于投资包括计划投资与存货投资，二者之和等于储蓄，由于a点利率上升引起计划投资减少(因为利率对计划投资影响大)，那么意味着存货投资增加，即存在超额产品供给，那么代表IS曲线右边所有非均衡点的a点就代表投资小于储蓄时的超额产品供给。以上是对该区域非均衡的解释，其实现均衡的过程为：由于投资小于储蓄(即应有的能够实现均衡的投资)，即投资减少，那么经过IS曲线传导会对应较低国民收入，即国民收入减少，国民收入减少意味着货币市场上存在着超额货币供给，为了减少超额的交易需求，必须增加投机需求即降低利率，从而a点在减少国民收入与降低利率两股力量的共同作用下就会达到均衡，如下图a点移动方向\r\n\r\n![示意图](/images/article/image8.jpg)\r\n\r\n可见，非均衡点的调整仍然是两个市场共同作用的结果，即货币市场利率影响投资从而影响产品市场产出，产品市场产出又进一步影响货币市场交易需求从而影响投机需求乃至利率，最终在这两股力量驱使下，实现非均衡点的均衡。\r\n\r\n总结一下，以a点和b点为例，有关于产品市场非均衡点下实现两个市场共同均衡过程的如下**结论**：\r\n\r\n**(产品市场上的)IS曲线右边以a点为例，同等收入上非均衡点(如a)对应利率更高，由于利率与投资反相关，因此产生低投资从而通过IS曲线推导的传导产生低产出，在低产出的作用下会使得均衡点往左移动(因为左边是y，往左移动即减少，也就是产出的减少量)；货币市场上，该点在LM曲线的左边，意味着同等利率下非均衡点a代表的区域收入更低从而货币交易需求较低，但是该利率对应的LM曲线的收入较大即均衡点的货币供给更大，从而点a代表的LM曲线左边区域在产品市场上处于货币需求小于货币供给的存在超额货币供给的非均衡状态。为了实现均衡，就需要降低交易需求增加投机需求即降低利率，从而在低利率下会使得点a向下移动。那么非均衡点a代表的非均衡区域在这两股力量作用下会实现两个市场共同均衡(即通过向量加法使得两股力量朝着一个方向斜着趋于共同均衡)。**\r\n\r\n**(产品市场上的)IS曲线左边以b点为例，同等收入上非均衡点(如b)对应利率更低，由于利率与投资反相关，因此产生高投资从而通过IS曲线推导的传导产生高产出，在高产出的作用下会使得均衡点往右移动(因为右边是y，往右移动即增加，也就是产出的增量)；货币市场上，该点在LM曲线的右边，意味着同等利率下非均衡点b代表的区域收入更高从而货币交易需求较高，但是该利率对应的LM曲线的收入较小即均衡点的货币供给更小，从而点b代表的LM曲线右边区域在产品市场上处于货币需求大于货币供给的存在超额货币需求的非均衡状态。为了实现均衡，就需要增加交易需求减少投机需求即提高利率，从而在高利率下会使得点b向上移动。那么非均衡点b代表的非均衡区域在这两股力量作用下会实现两个市场共同均衡(即通过向量加法使得两股力量朝着一个方向斜着趋于共同均衡)。**\r\n\r\n以上两个点代表的两个市场的不同失衡状态可以产生四个非均衡组合，详见教材(人大高鸿业第七版宏观部分p432，马工程下册p110)。\r\n\r\n\u003cp style=\"font-family:Consolas;text-align:right\"\u003eLast updated at 21:13, October 20, 2019\u003c/p\u003e","cover":"/images/nopic.jpg","link":"is-lm-model-circula-inference-and-solution-of-keynesian-theory.html","preview":"\u003cp\u003e凯恩斯理论的循环推论与解决方案IS－LM模型，IS－LM模型非均衡的四个区域的含义及实现均衡的过程。\u003c/p\u003e\n","title":"IS－LM模型：凯恩斯理论的循环推论与解决方案"},{"content":"\r\n\r\n## 一、LM曲线由什么决定？如何决定？\r\n\r\nLM曲线由货币投机需求关于利率的投机需求函数(`m2 = -hr`)、货币市场均衡条件(`m = m1 + m2`)、货币交易需求关于国民收入的交易需求函数(`m1 = ky`)决定。\r\n\r\nLM曲线的推导是从产品市场的延伸开始的，产品市场国民收入y通过货币交易需求函数影响货币交易需求m1(即产品市场国民收入的增加意味着货币市场货币交易需求的增加)，由于货币供应量是一个外生变量，即其值固定，那么在货币交易需求增加的同时必须减少货币投机需求量m2，而货币投机需求m2是关于利率r的减函数，因此，货币投机需求m2的减少会使得利率r上升。即传导路径为：`y → m1 → m2 → r`，也就是最终是由国民收入y决定利率r的。\r\n\r\n***tip：可见产品市场与货币市场循环推论，即相互作用、相互影响，货币市场的利率r影响产品市场投资最终影响产品市场均衡产出y；而产品市场的产出y影响货币交易需求最终影响货币市场的利率r。由于循环推论，最终需要将LM曲线与IS曲线通过利率r关于产出y的模型结合起来以寻求二者的共同均衡，即IS - LM模型。***\r\n\r\n结论：LM曲线上任何一点都代表一定利率和收入的组合，在这样的组合下，货币需求和供给是相等的，即货币市场是均衡的。也就是说，LM曲线上都是`m = m1 + m2`的货币市场均衡点，不过是均衡水平不同，这是由于不同产出影响下货币的交易需求不同引起的货币投机需求不同而引起的利率不同，即产出影响下利率的水平不同或者利率对应产出的均衡水平不同。\r\n\r\n## 二、LM曲线走向由什么决定？如何决定？\r\n\r\n由于LM曲线由由货币投机需求关于利率的投机需求函数(`m2 = -hr`)、货币市场均衡条件(`m = m1 + m2`)、货币交易需求关于国民收入的交易需求函数(`m1 = ky`)决定，那么LM曲线的走向必然由此三者决定。\r\n\r\n虽然LM曲线的推导是以产品市场均衡产出y开始的，我们这里反着来，道理是一样的。也是通过对四象限图的再解释来说明其走向。\r\n\r\n1. 第一象限中，由于利率r是关于货币投机需求m2的反函数，也就意味着第一象限的特征是“高r低m2，低r高m2”，由于是反着来，我们认为是利率r决定货币投机需求m2，即“`r → m2`”；\r\n2. 第二象限中，由于货币市场的均衡条件是`m = m1 + m2`，那么意味着这是一条斜率为`-1`，截距为货币供给量的反函数形式的曲线，即m1与m2关于货币供给量互补，那么第二象限的特征就是“低m2高m1，高m2低m1”，综合第一象限来看，其总体特征就是“高r低m2高m1，低r高m2低m1”，即“`r → m2 → m1`”；\r\n3. 第三象限中，由于货币交易需求m1是关于均衡产出y的增函数，意味着“高m1高y，低m1低y”，那么在综合第一二象限特征来看就是“高r低m2高m1高y，低r高m2低m1低y”，即“`r → m2 → m1 → y`”。即最终关系是“高r高y，低r低y”，很明显了，就是一条向右上方倾斜的曲线，那么第四象限就可以得出这个曲线，图略。\r\n\r\n结论：LM曲线的形状(或走向)是通过利率r、货币投机需求、货币交易需求以及均衡产出y之间的相互作用决定的，最终走向为一条向右上方倾斜的曲线(横轴为y，纵轴为r)。\r\n\r\n## 三、LM曲线斜率由什么决定？如何决定？\r\n\r\n由于LM曲线是由货币投机需求关于利率的投机需求函数(`m2 = -hr`)、货币市场均衡条件(`m = m1 + m2`)、货币交易需求关于国民收入的交易需求函数(`m1 = ky`)推导的，那么其斜率必然取决于投机需求函数曲线的斜率或者交易需求函数曲线的斜率。货币市场均衡条件的代数表达式为：\r\n\r\n![货币市场均衡条件代数表达式](/images/article/formula3.png)\r\n\r\n上式可化为：\r\n\r\n![转换后的货币市场均衡条件代数表达式](/images/article/formula4.png)\r\n\r\n或者:\r\n\r\n![转换后的货币市场均衡条件代数表达式](/images/article/formula5.png)\r\n\r\n即LM曲线的斜率为`k / h`。可见，代表投机需求对利率反应程度的参数h和代表交易需求对收入反应程度的参数k都会影响LM曲线的斜率，即平缓程度，我们分别来看。(此处不再作图，原理和IS曲线那里的一致，我们通过文字或符号传导来描述即可)\r\n\r\n首先是参数h，当k为定值时，h越大，说明货币投机需求对利率反映越敏感，也就意味着“在h变大之后，相对于变动前的利率(就是变动前后两条曲线的交点)，利率的少量下降会引起投机需求的极大上升，利率的少量提升会引起投机需求的极大下降，因为m2对r敏感”，那么h变大后，第一象限的特征就是“低r高高m2，高r低低m2”，这个高高和低低是相对于变动前的m2说的，即比变动前的m2高和比变动前的m2还低；从而传导到第二象限特征就变成了“高r低低m2高高m1，低r高高m2高低m1”，因为m2比之前越高，那么意味着m1比之前越低，反之同理；接着传导到第三象限其特征为“高r低低m2高高m1高高y，低r高高m2高低m1低低y”，因为m1比之前越高那么必然y比之前的高，反之同理。可以看出，高r对应着高高y，即同一利率水平上，利率越高，那么h变大后引起的货币投机需求的相对于之前投机需求的急剧降低会导致货币交易需求相对于之前上升从而导致均衡产出相对于之前上升，即“高r高高y”，那么利率降低(就是低于变动前后投机需求曲线的交点)就会引起m2上升从而m1相对于之前下降最终y相对于之前下降，即“低r低低y”，那么满足这个条件的就只有LM曲线更加平缓了，如下图所示(做个图)\r\n\r\n![h引起的LM曲线变化](/images/article/image5.png)\r\n\r\n结论：**简言之，由于m2对r敏感，那么h的增大，引起的在同一利率水平下m2的增加(不是增量)在货币市场均衡条件下势必会导致m1的减少(依旧是与增加的m2相同的利率水平)，那么减少后的m1(不是增量)会通过交易需求函数(曲线)得到减少后的均衡产出(不是增量)，也就是说同一利率水平下产出减少了，这句话可以用符号描述为“`r· → m2↑ → m1↓ → y↓，r· → y↓`”，即“利率不变，该利率上投机需求增加，投机需求增加引起交易需求减少，交易需求减少引起产出减少，从而不变的利率下引起均衡产出减少”。那么h增大引起的在同一利率水平上投机需求的减少就可以用符号描述为“`r· → m2↓ → m1↑ → y↑，r· → y↑`”，从而得到斜率变动后的LM曲线或者LM曲线斜率的变动，即变得平缓。相应的产出减少或者增加量取决于投机需求的增加或减少量与其乘数之积。**\r\n\r\n再是参数k，当h为定值时，k，k越大，说明货币交易需求对收入反映越敏感，也就意味着“在h变大之后，相对于变动前的收入(就是变动前后两条曲线的交点)，收入的少量下降会引起交易需求的较大下降，收入的少量提升会引起交易需求的较大增加，因为m1对y敏感”，那么h变大后，第一象限的特征不变，仍然是“低r高m2，高r低m2”，传导到第二象限也没有变，即“高r低m2高m1，低r高m2低m1”，但是到第三象限，由于y的上升(相比变动前后曲线的交点)会引起m1的较大上升，即第三象限总体特征为“高y高高m1，低y低低m1”，反过来说就是，即“高m1低低y，低m1高高y”(此处不要纠结，画个图一目了然，不要钻死心眼)，即m1高于交点对应的m1时收入y较低也就是低于m1水平对应的原曲线的y的水平，反之同理，那么传导过来，就变成了“高r低m2高m1低低y，低r高m2低m1高高y”，即较高水平的r(高于交点对应的r即可)对应比k未变之前的y更低的产出y，较低水平的r(低于交点对应的r即可)对应比k未变之前的y更高的产出y。也就是LM曲线变得陡峭了，如下图所示\r\n\r\n![k引起的LM曲线变化](/images/article/image6.png)\r\n\r\n可见，LM变得陡峭了。\r\n\r\n结论：**简言之，由于m1对y敏感，那么k的增大，引起的在同一收入水平上交易需求的增加(条件是收入高于变动前后两条曲线的交点对应收入)反过来说交易需求对应y变小。由于投机需求函数没变化，那么就是在某一较低(只要低于变动前后的两条交易需求曲线的交点对应的利率就好)利率水平下较高的投机需求(此处指的是低利率对应的高投机需求而不是指利率或者投机需求的增加，投机需求函数并未改变)在货币市场均衡条件下会有较低的交易需求，从而这个较低的交易需求会在新的陡峭的交易需求曲线下对应一个较大的产出，这句话可以用符号描述为“`r· → m2· → m1· → y↑，r· → y↑`”，即“利率不变，该利率上投机需求没有增减，从而投机需求引起的交易需求没有增减，但是交易需求通过新的陡峭的交易需求曲线引起收入增加，从而不变的利率下引起均衡产出增加”。那么k增大引起的在同一收入水平下交易需求的减少(条件是收入低于变动前后两条曲线的交点对应收入)在较高的没有改变的利率(即投机需求曲线未发生变化)对应的较低的(未变的)投机需求对应的较高的(未变的)交易需求对应的产出减少(不要纠结，画图就很明了)就可以用符号描述为“`r· → m2· → m1· → y↓，r· → y↓`”，从而得到斜率变动后的LM曲线或者LM曲线斜率的变动，即变得平缓。相应的产出增加或者减少量取决于交易需求的减少或增加量与其乘数之积。**\r\n\r\n结论：**h表示利率变动一定幅度时投机需求变动的程度，如果h值较大，即投机需求对于利率变化比较敏感，那么LM曲线斜率绝对值就较小，即IS曲线平缓。这是因为投机需求对利率较敏感时，利率的较小变动就会引起投机需求的较大变化，进而引起交易需求的较大变化并最终影响产出(就是传导过程)。k表示收入变动一定幅度时交易需求变动的程度，如果k较大，即交易需求对于收入变化比较敏感，那么LM曲线斜率绝对值就较大，即IS曲线陡峭。这是因为低利率下较高投机需求对应的较低的交易需求会在第三象限对应一个较高的产出(高于变化前的产出)，反之同理，从而LM曲线陡峭。**\r\n\r\n## 四、LM曲线平移由什么决定？如何决定？\r\n\r\nLM曲线的平移是由实际货币供给量m的变动引起的。实际货币供给量与名义货币供给量的关系如下\r\n\r\n![实际货币供给量与名义货币供给量的关系](/images/article/formula6.png)\r\n\r\n那么在此条件下引起LM曲线变动的因素就是两个子因素：\r\n\r\n1. **名义货币供给量变大，价格水平不变，那么实际货币供给量变大**，即第二象限斜率为-1的曲线向右上方平移即截距增大(截距就是实际货币供给量)，从而每个利率水平上对应的投机需求对应的交易需求都会产生一个增量，由于交易需求与产出正相关，那么经过第三象限的传导必然会在各个水平的交易需求上产生一个产出增量即每个利率水平上都产生了产出增量，即LM曲线向右下方移动了；反之同理。\r\n2. **价格水平上升，名义货币供给不变，意味着实际货币供给减少**，即第二象限斜率为-1的曲线向左下方平移即截距变小(截距就是实际货币供给量)，从而每个利率水平上对应的投机需求对应的交易需求都会产生一个较少量，由于交易需求与产出正相关，那么经过第三象限的传导必然会在各个水平的交易需求上产生一个产出减少量即每个利率水平上都产生了产出减少量，即LM曲线向左上方移动了；反之同理。\r\n\r\n\u003cp style=\"font-family:Consolas;text-align:right\"\u003eLast updated at 16:52, October 20, 2019\u003c/p\u003e","cover":"/images/nopic.jpg","link":"derivation-slope-and-translation-of-lm-curve.html","preview":"\u003cp\u003eLM曲线由什么决定？如何决定？LM曲线走向由什么决定？如何决定？LM曲线斜率由什么决定？如何决定？\u003c/p\u003e\n","title":"有关LM曲线的推导、斜率及平移"},{"content":"\r\n\r\n## 一、IS曲线由什么决定？如何决定？\r\n\r\nIS曲线由投资关于利率的投资函数(`i = e - dr`)、产品市场均衡条件(`i = s`)、储蓄关于国民收入的储蓄函数(`s = -α + (1 - β)y`)决定。\r\n\r\nIS曲线的推导是从货币市场的延伸开始的。货币市场的利率r通过投资函数(`i = e - dr`)决定产品市场的投资i，投资i通过产品市场均衡条件(`i = s`)进而影响(或决定)储蓄s，储蓄s通过储蓄函数(`s = -α + (1 - β)y`)来最终决定均衡产出y。即传导路径为`r → i → s → y`，也就是最终是由利率r决定均衡国民收入y的。\r\n\r\n结论：**IS曲线反映的是利率r与收入y之间的相互关系，在IS曲线上任何一点都代表一定的利率与收入的组合在这些组合下，投资和储蓄都是相等的，即`i = s`，从而产品市场是均衡的。**也就是说，IS曲线上都是`i = s`的产品市场均衡点，只不过是均衡水平不同，这是由于不同利率水平下投资量的不同导致的储蓄的不同从而导致的均衡产出的不同。\r\n\r\n## 二、IS曲线走向由什么决定？如何决定？\r\n\r\n由于IS曲线由投资函数(`i = e - dr`)、产品市场均衡条件(`i = s`)、储蓄函数(`s = -α + (1 - β)y`)决定，那么IS曲线的走向必然由此三者决定。\r\n\r\n教材上是通过四象限图来解释IS曲线的形成(也就说明了IS曲线的走向)，由于四象限图画起来比较麻烦，这里采用对其描述的方式来解释，当然对照四象限图效果更佳，如下\r\n\r\n1. 第一象限中，由于投资函数中投资i是利率r的减函数，也就意味着低r对应着高i，高r对应着低i，即第一象限的特征就是“低r高i，高r低i”。可以看出，先是利率影响投资，即“`r → i`”；\r\n2. 第二象限中，由于产品市场均衡条件(`i = s`)是一条`45°`线，即投资i与储蓄s相等，那么必然，当投资i较高时，储蓄s同样较高，投资i较低时，储蓄s就较低，那么单看第二象限，其特征就是“高i高s，低i低s”，再和第一象限结合起来，那么第二象限的完整特征就是“低r高i高s，高r低i低s”，即第二象限投资的高低是由第一象限的利率r引起的，必须记住这一点。可以看出这里是利率影响投资影响储蓄，即“`r → i → s`”\r\n3. 第三象限中，由于储蓄函数(`s = -α + (1 - β)y`)是关于国民收入的增函数，也就是说单看第三象限的特征就是“高s高y，低s低y”，那么再将其与第二象限的完整特征结合起来就是“低r高i高s高y，高r低i低s低y”。可以看出，这里就是利率影响投资影响储蓄影响收入，即“`r → i → s → y`”，就是r决定y，它们之间的关系就是“低r高y，高r低y”，很明显，就是一个向右下方倾斜的曲线，那么第四象限就可以一条向右下方倾斜的IS曲线，图略。\r\n\r\n结论：**IS曲线的形状(或走向)是通过利率r、投资i、储蓄s以及收入y之间的相互作用决定的，最终走向为一条向右下方倾斜的曲线(横轴为y，纵轴为r)。**\r\n\r\n## 三、IS曲线斜率由什么决定？如何决定？\r\n\r\n由于IS曲线是由投资函数(`i = e - dr`)、产品市场均衡条件(`i = s`)、储蓄函数(`s = -α + (1 - β)y`)推导的，那么其斜率必然取决于投资函数的斜率或者储蓄函数的斜率。再具体而言，两部门经济中，均衡产出的代数表达式为：\r\n\r\n![均衡产出代数表达式](/images/article/formula1.png)\r\n\r\n上式可化为：\r\n\r\n![转换后的均衡产出代数表达式](/images/article/formula2.png)\r\n\r\n也就是说IS曲线的斜率的绝对值为`(1 - β) / d`，即IS曲线的斜率或者说IS曲线的平缓与否取决于参数β与d。其中β是边际消费倾斜，d是投资函数的斜率，即β代表的是消费对收入的敏感程度，d代表的是投资对利率的敏感程度。我们分别来看：\r\n\r\nd表示投资i对利率r的敏感程度，即d越大，那么代表投资i对利率r越敏感，也就是“r的较小变动会引起i的较大变动，反映到投资曲线上就是d变动后，若r相对于变动前的利率r变小，那么同样利率水平下投资会增加，若r相对于变动前的利率r变大，那么同样利率水平下投资会减少”，按照这个要求绘制投资曲线就可以很清楚的发现，满足这个要求的投资曲线更加平缓，即\r\n\r\n![d引起的投资函数变化](/images/article/image1.png)\r\n\r\n图中已经明显标出了变动前后的曲线关系，通过二者之间的交点说明了i对r的敏感关系。可见，当利率小于3时，投资额增加，根据1.2的结论，由于投资i与产出y的作用关系是“高i高s高y，低i低s低y”，也就是说当利率小于3时增加出来的这一部分投资额会导致收入增加，增加的幅度就是投资额的增量与乘数之积，这部分收入增量必然是加在投资曲线变动前的均衡收入之上的，但是全部都要加吗？当然不是，由于当利率小于3时，才会产生投资增量进而产生收入增量，那么也就只对利率小于3的IS曲线上加上这部分收入增量，换句话说，在IS曲线上当利率小于3时在同等利率水平上对应的均衡产出比原来要多(因为利率小于3时加上了投资增量引起的收入增量)，那么就可以据此绘制出如下IS曲线变化：\r\n\r\n![d引起的IS曲线变化](/images/article/image2.png)\r\n\r\n可见，IS曲线也变得平缓，同样上图也解释了利率大于3时的情况，不再赘述。可见，投资曲线的交点处，两条投资曲线在相同利率水平上投资一致(利率当然一致)，所以产出也一致，表现为两条IS曲线相交于`r = 3`时的一点。以上就是d变动引起的投资曲线的变动从而引起的IS曲线的变动。当然，上述只是解释了四象限图中的第一象限和第四象限，第二象限和第三象限则是通过推论得出的，因为投资i与储蓄s以及产出y均是增函数，因此完全可以略过有储蓄函数参与的第二三象限，而且产出的增加(或减少)仅仅是由投资额增加(或减少)引起的，引入储蓄函数的二三象限也没有多大必要。\r\n\r\n结论：**简言之，由于i对r敏感，那么d的增大，引起的在同一利率水平下投资的增加(不是增量)在产品市场均衡条件下势必会导致储蓄的增加(依旧是与增加的投资相同的利率水平)，那么增加后的储蓄(不是增量)会通过储蓄函数得到增加后的均衡产出(不是增量)，也就是说统一利率水平下产出增加了，这句话可以用符号描述为“`r· → i↑ → s↑ → y↑，r· → y↑`”，即“利率不变，利率下投资增加，投资引起储蓄增加，储蓄引起产出增加，从而不变的利率下引起均衡产出增加”。那么d增大引起的在同一利率水平下投资的减少就可以用符号描述为“`r· → i↓ → s↓ → y↓，r· → y↓`”，从而得到斜率变动后的IS曲线或者IS曲线斜率的变动，即变得平缓。相应的产出增加或者减少量取决于投资的增加或减少量与投资乘数之积。**\r\n\r\n再看β，β为边际消费倾向，β越大那么边际消费倾向越高，由于储蓄与消费此消彼长，那么在同等收入下更多的收入用作消费必然使得储蓄减少，即“β上升，同等收入下储蓄s必然下降”，表现在储蓄函数曲线上，就是储蓄曲线平缓，如下\r\n\r\n![β引起的储蓄曲线变化](/images/article/image3.png)\r\n\r\n与投资曲线的变动不同，后者是从四象限图的开头传导的，所以显得很自然，储蓄曲线就有点突兀。但是如果我们选择从四象限图的开头来传导的话也就显得很自然了：由于投资函数没发生变化，即某一利率水平上对应的投资在产品市场均衡条件作用下得到对应的相同的储蓄，重点来了，这个储蓄会在变化后的储蓄函数曲线上对应较大的产出,因为由于β的作用使得储蓄曲线平缓。从而该利率水平最终对应的产出变大。由于新旧储蓄曲线有一个交点，β可以理解为c关于y的敏感程度，这个交点就是一个基准，当y大于这个交点的值s对应的y或者当s大于这个交点对应的s时，会刺激居民消费，从而在消费需求的作用下产出增加，相反小于的话居民就会减少消费从而降低产出。那么已经很明显了，在这个交点之上的s对应的低利率自然会对应高产出，至于高多少取决于消费增量或者储蓄减少量与消费乘数的乘积，即“低r对应高高y”，“高高”是相对于低r本身对应的高y而言的，即在这个高y的基础上还有个增量，即“高高”。在这个交点之下的s对应的高利率则会对应低产出，低多少也取决于储蓄减少量与消费乘数之积，即“高r对应低低y”，“低低”是相对于高r本身对应的低y而言的，即在这个低y的基础上还有个减少量，即“低低”。那么最终的曲线就是\r\n\r\n![β引起的IS曲线变化](/images/article/image4.png)\r\n\r\n即IS曲线平缓了。\r\n\r\n结论：**简言之，由于c对y敏感，那么β的增大，引起的在同一收入水平下消费的增加(条件是消费对应储蓄高于新旧储蓄曲线交点对应的储蓄)从而储蓄减少对应产出增加。由于投资函数没变化，那么就是在某一较低(只要低于新旧储蓄曲线的交点对应的利率就好)利率水平下较高的投资在产品市场均衡条件下会有较高的储蓄(只要高于新旧储蓄曲线交点的储蓄就好)，从而这个较高储蓄会在新的平缓的储蓄曲线下对应一个较大的产出，这句话可以用符号描述为“`r· → i· → s· → y↑，r· → y↑`”，即“利率不变，利率下投资没有增减，从而投资引起的储蓄没有增减，但是储蓄通过新的平缓的储蓄曲线引起收入增加，从而不变的利率下引起均衡产出增加”。那么β增大引起的在同一收入水平下消费的减少(条件是消费对应储蓄低于新旧储蓄曲线交点对应的储蓄)从而储蓄增加对应产出减少就可以用符号描述为“`r· → i· → s· → y↓，r· → y↓`”，从而得到斜率变动后的IS曲线或者IS曲线斜率的变动，即变得平缓。相应的产出增加或者减少量取决于消费的增加或减少量(或者储蓄的减少或增加量)与消费乘数之积。**\r\n\r\n结论：**综上，可以看出，d变大引起的同一利率水平上投资变动最终通过传导引起的产出变动是通过国民收入决定理论中的投资需求对国民收入的影响来实现的。而β变动引起的同一收入水平上储蓄变动并通过投资函数从头传导引起的产出变动是通过国民收入决定理论中的消费需求对国民收入的影响来实现的。从而就将均衡产出的IS曲线与国民收入决定理论联系了起来。**\r\n\r\n结论：**d表示利率变动一定幅度时投资变动的程度，如果d值较大，即投资对于利率变化比较敏感，那么IS曲线斜率绝对值就较小，即IS曲线平缓。这是因为投资对利率较敏感时，利率的较小变动就会引起投资的较大变化，进而引起收入的较大变化(投资是影响产出的一大因素)。Β是边际消费倾向，如果β较大，IS曲线斜率绝对值较小，这是因为β较大意味着支出乘数较大，从而利率变动引起投资变动时，收入也会加大幅度变动，因而IS曲线平缓。**\r\n\r\n## 四、IS曲线平移由什么决定？如何决定？\r\n\r\n由于IS曲线是由投资函数(`i = e - dr`)、产品市场均衡条件(`i = s`)、储蓄函数(`s = -α + (1 - β)y`)推导的，那么其平移必然取决于投资函数(曲线)的平移或者储蓄函数(曲线)的平移。\r\n\r\n**先看投资函数曲线平移引起(决定)的IS曲线平移。**曲线的平移是斜率没变，截距发生了变化，类似于消费函数的截距被称为自发消费，投资函数的截距被称为自发投资，即利率为0时也会进行的投资。如果由于种种原因(比如，投资边际效率提高、技术革新或者企业家对经济前景预期乐观)，那么在同样利率水平上投资需求都会增加，即投资曲线向右上方移动，由于投资增加，那么经过四象限图传导，首先使得储蓄增加，然后储蓄通过储蓄函数使得产出增加，由于是每个利率水平都产生了同样的投资增量，那么也就意味着对应的储蓄也是在每个投资水平上同等增加进而产出同等增加，即IS曲线会向右上方移动，代表同等利率水平上由于投资增加引起的均衡产出同等增加。反之，投资需求曲线向左下方移动，IS曲线向左下方移动。移动的量取决于投资增量或者减少量与乘数之积。\r\n\r\n**储蓄函数曲线平移引起(决定)的IS曲线平移。**若人们储蓄意愿增加，那么储蓄曲线会向左上方移动，即同等收入水平上储蓄增加，那么经由投资曲线传导得到储蓄后在储蓄曲线上会对应较少的产出，即IS曲线会向左下方移动，原因在于储蓄增加使得消费减少从而影响国民收入，均衡产出的减少量(或移动量)取决于储蓄增加量与乘数之积。反之同理。\r\n\r\n**消费函数引起的IS曲线平移。由于消费与储蓄此消彼长，那么刚好与储蓄函数引起的IS曲线平移相反**，不再赘述。\r\n\r\n在三部门经济中，还存在政府部门，**政府的税收与支出同样会对国民收入产生影响**，具体如下\r\n\r\n1. 增加政府购买性支出，其效果相当于企业自发投资增加，即会使得IS曲线向右上方移动，移动量取决于政府购买性支出增加量与乘数之积；反之同理；\r\n2. 政府减税会减轻企业和居民负担，间接增加企业投资和居民消费，从而IS曲线向右上方平移，移动量取决于减税幅度与乘数之积；政府增税反之。\r\n3. 增加政府转移支付，实际上等于增加了人们的收入，其效果与消费对IS曲线的影响大致相同；反之同理；\r\n\r\n在四部门经济中，还存在国际部门，国外需求同样会影响IS曲线。**国外需求的增加会增加总需求引起IS曲线右上方移动**，反之同理。\r\n\r\n增支减收都属于政府扩张性财政政策，会引起IS曲线右上方移动；增收减支属于政府紧缩性财政政策，会引起IS曲线左下方移动。**IS曲线的目的在于分析财政政策如何影响国民收入变动。**\r\n\r\n\u003cp style=\"font-family:Consolas;text-align:right\"\u003eLast updated at 20:37, October 19, 2019\u003c/p\u003e","cover":"/images/nopic.jpg","link":"derivation-slope-and-translation-of-is-curve.html","preview":"\u003cp\u003eIS曲线由什么决定？如何决定？IS曲线走向由什么决定？如何决定？IS曲线斜率由什么决定？如何决定？\u003c/p\u003e\n","title":"有关IS曲线的推导、斜率及平移"},{"content":"\r\n\r\n本系列文章基于Linux 0.11内核源代码，共计14000+行左右，基本上都是Linux系统的精髓；而最新版Linux内核已经发展到了5.2.14已上千万行，是不利于学习Linux内核的。\r\n\r\n## 引言\r\n\r\n我们知道，计算机的运行主要是以RAM为对象的CPU运算，即程序执行的前提是被调入RAM当中。操作系统作为底层软件，理所当然地需要被加载至RAM中通过CPU运算构建整个操作系统体系以接管、分配和调度系统资源。\r\n\r\n由于CPU无法直接与外设进行数据交互，那么位于软盘/硬盘中的操作系统程序就必须首先调入RAM中。但是现在RAM中空空如也，既没有数据，也没有指令，那么是谁通过CPU将操作系统程序调入RAM中的呢？\r\n\r\n答案是`BIOS`！\r\n\r\n## 一、BIOS的启动原理\r\n\r\n既然是BIOS将操作系统程序调入RAM当中，那么问题来了，BIOS又是如何启动的？\r\n\r\n答案就在于`0xFFFF0`地址处！\r\n\r\nPC机加电伊始，基于80x86结构的CPU将会自动进入实模式(实模式下CPU的地址总线为20根，其寻址能力为2\u003csup\u003e20\u003c/sup\u003e即1MB，这是因为80x86CPU是采取一种用两个16位地址合成一个20位地址的方法给出物理地址的，即物理地址=段地址×16+偏移地址)，并且CPU将会强制将CS寄存器的值设置为`0xF000`、IP寄存器的值设置为`0xFFF0`，即CPU将会指向`0xFFFF0`地址处，这个地址通常是ROM-BIOS的入口地址，即BIOS程序的第一条指令就在这个位置。等等，不是说RAM中没有任何数据和指令吗？那么CPU指向这个位置不也是空的吗？有什么意义？要注意的是CPU实际指向的是由主存地址空间(RAM)、显存地址空间(RAM)、显卡BIOS地址空间(ROM)、网卡BIOS地址空间(ROM)、系统BIOS地址空间(ROM)等物理存储器编址而成的逻辑存储器，被称为内存地址空间(以下简称内存)。所以CPU此时指向的地址是装有系统BIOS程序的构成内存地址空间的ROM地址空间，而非空无一物的主存地址空间。BIOS程序被固化在ROM芯片上，由于ROM的非易失性使得其内部并非空无一物。80x86 PC机内存地址空间图示如下\r\n\r\n![80x86PC机内存地址空间示例](/images/article/memory-address-space.png)\r\n\r\n言归正传，那么此刻CPU已经指向`0xFFFF0`的位置，意味着BIOS开始启动，紧接着将是BIOS程序在CPU中执行，屏幕上会显示出显卡信息、内存信息等，这说明CPU在进行自检，期间一项非常重要的工作就是BIOS在内存中构建中断向量表和中断处理程序。BIOS会在内存(主存RAM)的开始位置(`0x00000`)用1KB的内存空间(`0x00000` ～ `0x003FF`)构建BIOS中断向量表，在紧挨着中断向量表的位置用256字节内存空间构建BIOS数据区(`0x00400` ～ `0x004FF`)，并在大约57KB以后的位置(`0x0E05B`)加载大约8KB的与中断向量表对应的若干中断处理程序。如下图所示\r\n\r\n![构建BIOS之后的内存布局](/images/article/ram-bios.png)\r\n\r\n中断向量表中有256个中断向量，每个中断向量占4字节，刚好是`1KB(256 × 4Byte = 1KB)`。其中两个字节是该中断向量对应的处理程序的CS的值，剩下的两个字节是对应IP的值(所以段地址和偏移地址都是16位，可以用来合成20位物理地址，达到实模式下1MB寻址范围)。\r\n\r\nBIOS构建完中断服务体系之后，CPU会接收到一个`int 0x19`中断(该中断的作用是把可启动设备的第一个扇区的程序加载至内存的指定位置)，然后CPU在中断向量表中查找该中断对应的中断处理程序地址，随后执行该中断的中断处理程序将启动设备(这里是软盘)的第一个扇区中的程序加载到内存的`0x07C00(31KB)`处。\r\n\r\n那么软盘第一个扇区中的程序是什么呢？就是Linux的磁盘引导程序`bootsect`。\r\n\r\n## 二、bootsect对内存的规划\r\n\r\nbootsect是完全用汇编语言写成的，其首先要对实模式下可寻址(最大范围`1MB`,即`0x00000 ～ 0xFFFFF`)的内存进行规划。代码如下所示\r\n\r\n```\r\n...\r\nSYSSIZE  = 0x3000\r\n...\r\nSETUPLEN = 4                    ! nr of setup-sectors\r\nBOOTSEG  = 0x07c0               ! original address of boot-sector\r\nINITSEG  = 0x9000               ! we move boot here - out of the way\r\nSETUPSEG = 0x9020               ! setup starts here\r\nSYSSEG   = 0x1000               ! system loaded at 0x10000 (65536).\r\nENDSEG   = SYSSEG + SYSSIZE     ! where to stop loading\r\n...\r\n```\r\n\r\n其中`SYSSIZE`是system模块的节数，由于16字节为1节，所以system模块共`0x30000Byte`(对应的十进制为`196608Byte`)，即`192KB (196608 / 1024)`;`SETUPLEN`为setup程序的扇区数，即4个扇区，由于bootsect为第1扇区，那么setup必然就是第2扇区到第5扇区;`BOOTSEG`为bootsect程序段的初始位置，也就是BIOS加在到内存中的位置，即`0x07c0`;`INITSEG`为bootsect将要移动的新位置，为`0x9000`;`SETUPSEG`为setup程序的始址，由于bootsect大小为1个扇区，且新始址为`0x9000`，也就是在`576KB`处(`0x9000`节，即`0x90000Byte`，转化为十进制为`589824Byte`，即`589824 / 1024 = 576KB`),由于第一扇区大小为`512Byte`,即`0.5KB`，那么bootsect的末端就在`576.5KB`处，即十进制`590336Byte`处，对应的十六进制为`0x90200Byte`，也就是`0x9020`(节)处，也就是setup程序紧跟着bootsect，可见Linus对内存的精妙控制;`SYSSEG`为system模块的段始址，即地址`0x10000`处，也就是64KB(对应十进制`65536KB / 1024`)处;`ENDSEG`自然为system模块的地址末端。\r\n\r\n反映到实模式下的内存上，如下图所示\r\n\r\n![bootsect设置的内存布局](/images/article/memory-bootsect.png)\r\n\r\n接下来bootsect将会按照上述内存布局进行相应的操作。\r\n\r\n## 三、bootsect对自身的复制\r\n\r\nbootsect先将自身的全部内容(1个扇区)从内存`0x07C00`处(段地址BOOTSEG)复制到内存`0x90000`处(段地址INITSEG),对应的汇编代码如下\r\n\r\n```\r\nentry _start\r\n_start:\r\n    mov ax,#BOOTSEG\r\n    mov ds,ax\r\n    mov ax,#INITSEG\r\n    mov es,ax\r\n    mov cx,#256\r\n    sub si,si\r\n    sub di,di\r\n    rep\r\n    movw\r\n```\r\n\r\n数据段寄存器ds与源变址寄存器si构成bootsect的源地址`0x07c00`，即`ds:si = 0x07c0:0x0000`;而附加段寄存器es与目的变址寄存器di构成了bootsect的目的地址`0x9000`，即`es:di = 0x9000:0x0000`。通过计数寄存器cx控制循环的次数，这里`cx = 256`,由于cx为16位寄存器，即这里代表256个字，也就是`512Byte`，刚好是一个扇区的数目。然后通过`rep movw`循环进行复制操作。\r\n\r\n这段代码执行完毕后，整个内存空间将含有两段bootsect的数据，即以BOOTSEG开始的`512Byte`数据和以INITSEG开始的`512Byte`数据。接下来通过执行段间跳转指令跳转到INITSEG段的go代码块处继续执行bootsect，如下\r\n\r\n```\r\n\tjmpi\tgo,INITSEG\r\n```\r\n\r\n## 四、设置段寄存器ds、es、ss\r\n\r\n进入go代码块中，要设置ds、es、ss寄存器，代码如下\r\n\r\n```\r\ngo:\tmov\tax,cs\r\n\tmov\tds,ax\r\n\tmov\tes,ax\r\n! put stack at 0x9ff00.\r\n\tmov\tss,ax\r\n\tmov\tsp,#0xFF00\t\t! arbitrary value \u003e\u003e512\r\n```\r\n\r\n由于cs此时指向的是bootsect的段地址，即0x9000，那么上述代码就是将数据段寄存器ds、附加段寄存器es以及栈基址寄存器ss设置成与代码段寄存器cs相同的位置，然后将栈顶指针sp指向偏移地址`0xFF00`处。其内存映像如下所示\r\n\r\n![对ds、es、ss、sp的设置](/images/article/memory-bootsect-ds-es-ss-sp.png)\r\n\r\n至此，由于对ss、sp寄存器的设置，此后程序便可以基于栈进行复杂数据运算了。\r\n\r\n## 五、加载setup程序\r\n\r\n接下来bootsect需要将setup程序加载至SETUPSEG处，setup位于软盘/磁盘第2扇区到第5扇区连续四个扇区，共`2KB(512Byte * 4 = 2048Byte = 2KB)`,代码如下\r\n\r\n```\r\n! load the setup-sectors directly after the bootblock.\r\n! Note that 'es' is already set up.\r\n\r\nload_setup:\r\n\tmov\tdx,#0x0000\t\t! drive 0, head 0\r\n\tmov\tcx,#0x0002\t\t! sector 2, track 0\r\n\tmov\tbx,#0x0200\t\t! address = 512, in INITSEG\r\n\tmov\tax,#0x0200+SETUPLEN\t! service 2, nr of sectors\r\n\tint\t0x13\t\t\t! read it\r\n\tjnc\tok_load_setup\t\t! ok - continue\r\n\tmov\tdx,#0x0000\r\n\tmov\tax,#0x0000\t\t! reset the diskette\r\n\tint\t0x13\r\n\tj\tload_setup\r\n```\r\n\r\n与BIOS加载bootsect不同的是，bootsect加载setup用的是`int 0x13`中断而不是`int 0x19`中断，系统通过几个通用寄存器来给BIOS中断处理程序传参，含义如下\r\n\r\n+ dx寄存器中，高8位dh为磁头号，低8位dl为驱动器号；\r\n+ cx寄存器中，高8位ch为磁道(柱面)号的低8位，低8位cl为开始扇区；\r\n+ bx寄存器，配合es段寄存器指向内存缓冲区，即SETUPSEG的位置；\r\n+ ax寄存器中，高8位`ah = 0x02`代表的是读磁盘扇区到内存中；低8位al代表要读出的扇区数量。\r\n\r\n根据上述解释，这段程序指明通过驱动器0(dl)的0号磁头(dh)对应盘面的0磁道(ch)第2扇区(cl)开始的连续4个扇区(al)读到内存中(ah)`es:bx`指向的位置`0x9000:0200`，即`0x90200`处。\r\n\r\nBIOS对文件、磁盘等IO的操作是通过检测CF位来判断是否成功的，若`CF = 0`表示成功，`jnc`指令通过判断`CF = 0`来实现跳转，即读取成功则跳转至`ok_load_setup`处继续执行。代码如下\r\n\r\n```\r\nok_load_setup:\r\n\r\n! Get disk drive parameters, specifically nr of sectors/track\r\n\r\n\tmov\tdl,#0x00\r\n\tmov\tax,#0x0800\t\t! AH=8 is get drive parameters\r\n\tint\t0x13\r\n    seg cs\r\n\tmov\tsectors,cx\r\n\tmov\tax,#INITSEG\r\n\tmov\tes,ax\r\n...\r\nsectors:\r\n\t.word 0\r\n```\r\n\r\n加载setup成功之后，获取磁盘驱动器的参数，特别是每道扇区数量。\r\n\r\n仍然是通过`int 0x13`中断实现的，其中dl代表驱动器号，这里是0号，ax的高8位`ah = 8`代表获取驱动器参数(上面`ah = 2`代表读磁盘扇区到内存)，然后调用`0x13`中断的处理程序获取数据，这里会返回ah = 0, al = 0, bl = 驱动器类型(AT/PS2),ch = 最大磁道号的低8位,cl = 每磁道最大扇区数(第0到第5位)最大磁道号高2位(第6到第7位),dh = 最大磁头数,dl = 驱动器数量。如果读取出错，则CF位置为1，同时ah为状态码。而`es:di`指向软驱磁盘参数表。\r\n\r\n然后将获取到的每磁道扇区数保存起来，供确认根设备号时使用，即`mov sectors,cx`。由于上述`es:di`指向了软驱磁盘参数表，因此这里需要将es复位，即`mov es,ax`。\r\n\r\n若setup加载失败，即`CF = 1`,那么不断重试！\r\n\r\n加载成功后执行到ok_load_setup获取磁盘参数表之后，就要为加载system模块做准备了。\r\n\r\n## 六、加载system模块\r\n\r\n由于system模块多达240扇区，因此加载起来需要一定的时间，所以需要打印一些提示字符串(Loading system ...)告诉用户并未死机，代码如下\r\n\r\n```\r\n! Print some inane message\r\n\r\n\tmov\tah,#0x03\t\t! read cursor pos\r\n\txor\tbh,bh\r\n\tint\t0x10\r\n\t\r\n\tmov\tcx,#24\r\n\tmov\tbx,#0x0007\t\t! page 0, attribute 7 (normal)\r\n\tmov\tbp,#msg1\r\n\tmov\tax,#0x1301\t\t! write string, move cursor\r\n\tint\t0x10\r\n...\r\nmsg1:\r\n\t.byte 13,10\r\n\t.ascii \"Loading system ...\"\r\n\t.byte 13,10,13,10\r\n```\r\n\r\n先看msg1段，可以算出来刚好是24个字符。\r\n\r\n通过`int 0x10`中断的功能号为03H的子功能(ah = 0x03)先获取光标位置，以下参数将传递给`int 0x10`中断的功能号为13H的子功能(ax寄存器的高8位，即13)，如下\r\n\r\n+ cx寄存器指明共24个字符即循环24次\r\n+ bh指明页码，`bh = 0`，即第0页；bl为属性值，这里bl = 7；\r\n+ `es:bp`指向要打印的字符串，即msg1。由于msg1在bootsect中，因此段地址es适用，bp为msg1的段内偏移。\r\n\r\n然后调用`int 0x10`中断的功能号为13H的子功能打印字符串。\r\n\r\n已经提示用户正在加载系统了，那么接下来就是正式加载system模块，如下\r\n\r\n```\r\n! ok, we've written the message, now\r\n! we want to load the system (at 0x10000)\r\n\r\n\tmov\tax,#SYSSEG\r\n\tmov\tes,ax\t\t! segment of 0x010000\r\n\tcall\tread_it\r\n...\r\n```\r\n\r\nbootsect加载system模块是通过read_it子程序来完成的，子程序的输入参数为es，即`es = SYSSEG`。read_it仍然是通过`int 0x13`中断来加载system模块的。为第6扇区开始的连续约240个扇区。\r\n\r\nsystem加载完成之后，整个操作系统的内核代码都已经进入内存了，最后要做的一件事情就是再次确定一下根设备号。\r\n\r\n## 七、确定根设备号\r\n\r\n首先查看根设备号是否已经定义，如果已经定义(即!=0)那么将检查过的根设备号保存起来，即`mov root_dev,ax`;否则根据BIOS报告的每磁道扇区数来确定使用`/dev/PS0(2,28)`还是`/dev/at0(2,8)`。这里两个设备文件的含义为，在Linux中软驱的主设备号是2，次设备号 = type × 4 + nr，其中nr为0 - 3，分别对应软驱A、B、C或D；type是软驱的类型，1.2MB的驱动器为2,1.44MB的驱动器为7。所以1.2MB的A驱动器的次设备号为2 × 4 + 0 = 8，所以`/dev/at0(2,8)`指的是1.2MB A驱动器；而1.44MB A驱动器的次设备号为7 × 4 + 0 = 28，所以`/dev/PS0(2,28)`指的是1.44MB A驱动器。\r\n\r\n其次，设备号的计算公式为：设备号 = 主设备号 × 256 + 次设备号。那么1.44MB A驱动器的设备号就是2 × 256 + 28 = 540，对应的16进制就是0x021c；同理计算1.2MB A驱动器的设备号为0x0208。\r\n\r\n```\r\n! After that we check which root-device to use. If the device is\r\n! defined (!= 0), nothing is done and the given device is used.\r\n! Otherwise, either /dev/PS0 (2,28) or /dev/at0 (2,8), depending\r\n! on the number of sectors that the BIOS reports currently.\r\n\r\n\tseg cs\r\n\tmov\tax,root_dev\r\n\tcmp\tax,#0\r\n\tjne\troot_defined\r\n\tseg cs\r\n\tmov\tbx,sectors\r\n\tmov\tax,#0x0208\t\t! /dev/ps0 - 1.2Mb\r\n\tcmp\tbx,#15\r\n\tje\troot_defined\r\n\tmov\tax,#0x021c\t\t! /dev/PS0 - 1.44Mb\r\n\tcmp\tbx,#18\r\n\tje\troot_defined\r\nundef_root:\r\n\tjmp undef_root\r\nroot_defined:\r\n\tseg cs\r\n\tmov\troot_dev,ax\r\n...\r\nroot_dev:\r\n\t.word ROOT_DEV\r\n```\r\n\r\n先将上述获取到的每磁道扇区数传送给通用寄存器bx，如果`bx = 15`，即每磁道扇区数为15,那么说明就是1.2MB的驱动器,如果为18，那么就是1.44MB的软驱，然后跳转到`root_defined`中将通用寄存器ax中定义的根设备号保存起来。如果获取到的每道磁盘扇区数既不为15也不为18那么就会跳过`je`指令直接进入`undef_root`段中，进入死循环。\r\n\r\n## 八.跳转至setup\r\n\r\n以上bootsect的任务几乎全部完成了，最后需要执行的指令就是\r\n\r\n```\r\n! after that (everyting loaded), we jump to\r\n! the setup-routine loaded directly after\r\n! the bootblock:\r\n\r\n\tjmpi\t0,SETUPSEG\r\n```\r\n\r\n即跳转到setup程序段的偏移地址为0处(也就是setup段首)继续执行，至此bootsect完成了CPU控制权的交接！","cover":"/images/os.jpg","link":"from-boot-up-to-disk-boot-program-execution.html","preview":"\u003cp\u003e本系列文章基于Linux 0.11内核源代码，共计14000+行左右，基本上都是Linux系统的精髓；而最新版Linux内核已经发展到了5.2.14已上千万行，是不利于学习Linux内核的。\u003c/p\u003e\n","title":"Linux内核源码分析：从加电启动到磁盘引导程序执行"},{"content":"\r\n\r\n## 一、September是什么？\r\n\r\nSeptember是一款依题源组卷工具，基于题源随机组卷，理论上只要样本容量足够大，可以生成互不重复的试题。\r\n\r\n为什么叫September？好吧，这个名字很随意，原因就是这个工具是我在九月份写出来的！！！姑且这样吧。\r\n\r\n## 二、使用方式\r\n\r\n该工具运行需要Java运行时环境，因此，需要确保你的PC机安装了`JRE`，需要根据你的PC机的位数下载合适的`JRE`，并配置`环境变量`，这个网上有很多，此处跳过。\r\n\r\n前往[此处](http://ibiur610399.java.jkj.wang/September.rar) 下载rar压缩包并解压至某个位置，接下来你有三种方式使用该工具，这里只介绍两种：\r\n\r\n+ 第一种方法是，直接点击`September.BAT`批处理程序，即可；\r\n+ 第二种方法是，将解压的文件夹加入到windows环境变量，具体操作方式如下：计算机 \u003cspan\u003e-\u003e\u003c/span\u003e 属性 \u003cspan\u003e-\u003e\u003c/span\u003e 高级系统设置 \u003cspan\u003e-\u003e\u003c/span\u003e 高级 \u003cspan\u003e-\u003e\u003c/span\u003e 环境变量 \u003cspan\u003e-\u003e\u003c/span\u003e 找到系统变量的path变量插入本文件夹路径即可。然后在`cmd`中输入命令`september`即可进入幻境。\r\n\r\n## 三、文件结构\r\n\r\n示例如下\r\n\r\n```\r\n!5\r\n2 C++类声明与定义，析构函数与this指针\r\n4 深入C++函数\r\n6 函数关于指针\r\n5 C++自定义数据类型\r\n3 C++中的预定义数据类型\r\n7 Redis设计与实现\r\n9 MySQL忘记root密码解决办法\r\n2 Spring MVC控制器使用详情\r\n1 Spring MVC控制器使用指南\r\n5 Spring AOP的XML实现方式\r\n7 Spring依赖注入的实现方式\r\n5 懒惰学习——K最近邻学习算法\r\n4 物以类聚——K均值聚类学习算法\r\n2 转导推理——支持向量机\r\n6 黑箱方法——人工神经网络\r\n2 分而治之——决策树学习算法\r\n5 地图着色问题\r\n```\r\n\r\n第一行为一个英文感叹号，其后直接跟一个数字，该数字为题目的行数偏移量。\r\n\r\n暂时写这么多，要睡觉了......","cover":"/images/c++.jpg","link":"intro-september.html","preview":"\u003cp\u003e依题源组卷工具September使用指南.\u003c/p\u003e\n","title":"依题源组卷工具September使用极简指南"},{"content":"\r\n\r\n## 一、C++类的声明与定义\r\n\r\n与函数的定义与声明相同，先在`.h`文件中声明类，字段及方法，然后在`.cpp`文件中提供类的定义，然后再使用。完整的类声明如下所示\r\n\r\n先是类的声明\r\n\r\n```\r\n// calculate.h -- Calculate class interface\r\n#ifndef CALCULATE\r\n#define CALCULATE\r\n\r\nclass Calculate {\r\n    private:\r\n\t\tint left;\r\n\t\tint right;\r\n    public:\r\n\t\tvoid setLeft(int left);\r\n\t\tvoid setRight(int right);\r\n\t\tint getLeft();\r\n\t\tint getRight();\r\n\t\tint add();\r\n\t\tint sub();\r\n\t\tint mul();\r\n\t\tint div();\r\n};\r\n#endif\r\n```\r\n\r\n再是类的定义\r\n\r\n```\r\n// calculate.cpp implementing the Calculate class\r\n#include \u003ciostream\u003e\r\n#include \"calculate.h\"\r\n\r\nvoid Calculate::setLeft(int l) {\r\n\tleft = l;\r\n}\r\n\r\nvoid Calculate::setRight(int r) {\r\n\tright = r;\r\n}\r\n\r\nint Calculate::getLeft() {\r\n\treturn left;\r\n}\r\n\r\nint Calculate::getRight() {\r\n\treturn right;\r\n}\r\n\r\nint Calculate::add() {\r\n\treturn left + right;\r\n}\r\n\r\nint Calculate::sub() {\r\n\treturn left - right;\r\n}\r\n\r\nint Calculate::mul() {\r\n\treturn left * right;\r\n}\r\n\r\nint Calculate::div() {\r\n\treturn left / right;\r\n}\r\n```\r\n\r\n最后是类的使用，如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n#include \"calculate.h\"\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tCalculate cal;\r\n\tcal.setLeft(10);\r\n\tcal.setRight(100);\r\n\tcout \u003c\u003c \"left num  : \" \u003c\u003c cal.getLeft() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"right num : \" \u003c\u003c cal.getRight() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's add : \" \u003c\u003c cal.add() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's sub : \" \u003c\u003c cal.sub() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's mul : \" \u003c\u003c cal.mul() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's div : \" \u003c\u003c cal.div() \u003c\u003c \"\\n\";\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nleft num  : 10\r\nright num : 100\r\ntwo num's add : 110\r\ntwo num's sub : -90\r\ntwo num's mul : 1000\r\ntwo num's div : 0\r\n```\r\n\r\n可以看出访问控制由`private`与`public`提供统一管理，既可以是字段也可以是方法，默认的访问权限是`private`。\r\n\r\n在类的定义中，通过`Class::field/method()`的形式来定义字段与方法。\r\n\r\n在类的使用上，与Java不同的是，Java需要通过`new`来创建对象，而C++中声明即创建对象，直接就可以使用。\r\n\r\n## 二、构造函数与析构函数\r\n\r\nC++同样可以提供一次性赋值的构造函数，默认的无参构造函数可以省略，但是如果定义了非默认构造函数那么一定要声明默认构造函数，否则会报错；\r\n\r\n由于C++可能采用动态内存管理，所以需要一种在类使用完毕统一释放内存或其他资源的方式，这里是通过析构函数来实现的，基于上述代码，添加了构造函数与析构函数的声明与定义如下\r\n\r\n```\r\n// calculate.h -- Calculate class interface\r\n#ifndef CALCULATE\r\n#define CALCULATE\r\n\r\nclass Calculate {\r\n    private:\r\n\t\tint left;\r\n\t\tint right;\r\n    public:\r\n\t\tCalculate();\r\n\t\tCalculate(int l, int r);\r\n\t\t~Calculate();\r\n\t\tvoid setLeft(int left);\r\n\t\tvoid setRight(int right);\r\n\t\tint getLeft();\r\n\t\tint getRight();\r\n\t\tint add();\r\n\t\tint sub();\r\n\t\tint mul();\r\n\t\tint div();\r\n};\r\n#endif\r\n```\r\n\r\n```\r\n// calculate.cpp implementing the Calculate class\r\n#include \u003ciostream\u003e\r\n#include \"calculate.h\"\r\n\r\nCalculate::Calculate() {};\r\n\r\nCalculate::Calculate(int l, int r) {\r\n\tleft = l;\r\n\tright = r;\r\n}\r\n\r\nCalculate::~Calculate() {\r\n\tstd::cout \u003c\u003c \"bye...\";\r\n}\r\n\r\nvoid Calculate::setLeft(int l) {\r\n\tleft = l;\r\n}\r\n\r\nvoid Calculate::setRight(int r) {\r\n\tright = r;\r\n}\r\n\r\nint Calculate::getLeft() {\r\n\treturn left;\r\n}\r\n\r\nint Calculate::getRight() {\r\n\treturn right;\r\n}\r\n\r\nint Calculate::add() {\r\n\treturn left + right;\r\n}\r\n\r\nint Calculate::sub() {\r\n\treturn left - right;\r\n}\r\n\r\nint Calculate::mul() {\r\n\treturn left * right;\r\n}\r\n\r\nint Calculate::div() {\r\n\treturn left / right;\r\n}\r\n```\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n#include \"calculate.h\"\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tCalculate cal;\r\n\tcal.setLeft(10);\r\n\tcal.setRight(100);\r\n\tcout \u003c\u003c \"left num  : \" \u003c\u003c cal.getLeft() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"right num : \" \u003c\u003c cal.getRight() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's add : \" \u003c\u003c cal.add() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's sub : \" \u003c\u003c cal.sub() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's mul : \" \u003c\u003c cal.mul() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's div : \" \u003c\u003c cal.div() \u003c\u003c \"\\n\";\r\n\t\r\n\tCalculate cal1(100, 200);\r\n\tcout \u003c\u003c \"left num  : \" \u003c\u003c cal1.getLeft() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"right num : \" \u003c\u003c cal1.getRight() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's add : \" \u003c\u003c cal1.add() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's sub : \" \u003c\u003c cal1.sub() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's mul : \" \u003c\u003c cal1.mul() \u003c\u003c \"\\n\";\r\n\tcout \u003c\u003c \"two num's div : \" \u003c\u003c cal1.div() \u003c\u003c \"\\n\";\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nleft num  : 10\r\nright num : 100\r\ntwo num's add : 110\r\ntwo num's sub : -90\r\ntwo num's mul : 1000\r\ntwo num's div : 0\r\nleft num  : 100\r\nright num : 200\r\ntwo num's add : 300\r\ntwo num's sub : -100\r\ntwo num's mul : 20000\r\ntwo num's div : 0\r\nbye...bye...\r\n```\r\n\r\n## 三、this指针\r\n\r\nthis指针代表类当前对象的引用，也就是说返回this指针就代表着返回当前类对象，如下\r\n\r\n给头文件添加如下函数并给`getLeft()`方法添加`const`关键字\r\n\r\n```\r\nint getLeft() const;\r\nconst Calculate \u0026 compare(const Calculate \u0026 cal) const;\r\n```\r\n\r\ncpp文件如下\r\n\r\n```\r\nint Calculate::getLeft() const {\r\n\treturn left;\r\n}\r\n\r\nconst Calculate\u0026 Calculate::compare(const Calculate \u0026 cal) const {\r\n\treturn left \u003e cal.getLeft() ? *this : cal;\r\n}\r\n```\r\n\r\n`compare()`方法通过比较两个对象的`left`字段，然后返回最大值的对象引用，主文件通过显示最大值来反映返回的引用是哪个对象的，如下\r\n\r\n```\r\ncout \u003c\u003c \"compare left value : \" \u003c\u003c cal1.compare(cal).getLeft() \u003c\u003c \"\\n\";\r\n```\r\n\r\n需要注意的是，在this指针中，如果一个函数调用了另一个函数，那么不仅要在调用者函数后面加上const关键字，还要在被调用函数要在参数列表后加上`const`关键字。","cover":"/images/c++.jpg","link":"cpp-class-declaration-and-definition-destructor-and-this-pointer.html","preview":"\u003cp\u003eC++类的声明与定义、构造函数、析构函数以及this指针。\u003c/p\u003e\n","title":"C++类声明与定义，析构函数与this指针"},{"content":"\r\n\r\n## 一、C++内联函数\r\n\r\n对常规函数的调用对应着跳转到标记函数起点的内存单元，然后执行函数代码，执行完毕后跳回到地址被保存的指令处。来回跳跃并记录跳跃位置是需要一定开销的。\r\n\r\nC++提供的内联函数与常规函数不同，内联函数在编译阶段就将函数代码与调用者内联起来了，也就是使用函数代码替换了函数的调用，从而实现较快的执行速度，但是代价是需要额外的存储空间。使用方式为\r\n\r\n+ 在函数声明前加上关键字`inline`;\r\n+ 在函数定以前加上关键字`inline`。\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\ninline void sayHello();\r\n\r\nint main() {\r\n\tsayHello();\r\n\treturn 0;\r\n}\r\n\r\ninline void sayHello() {\r\n\tstd::cout \u003c\u003c \"hello, world!\";\r\n}\r\n```\r\n\r\n通常的做法是省略函数原型，将整个定义放在本应提供原型的地方，如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\ninline void sayHello() { std::cout \u003c\u003c \"hello, world!\"; }\r\n\r\nint main() {\r\n\tsayHello();\r\n\treturn 0;\r\n}\r\n```\r\n\r\n## 二、引用变量\r\n\r\n引用变量常用于函数的参数传递中，由于对于简单类型，C++采用的是值传递的方式，也就是函数体中的操作并不会影响被传入的参数的实际值，如果想实现简单类型的引用传递要么使用指针，要么使用引用变量。二者是有区别的，如下\r\n\r\n+ 指针中`\u0026`符号代表的是取址，而引用变量中`\u0026`符号代表的是声明指向某具体类型的引用；\r\n+ 指针中可以先声明然后赋值，但是引用变量只能创建是就要进行初始化；\r\n+ 指针可以重复赋值，即改变指针单元的内存地址，但是引用变量一旦绑定就不可变了，但是并不意味着无法赋值，只是内存地址不变，赋值仍然会改变地址空间的值。\r\n\r\n### 2.1 引用变量作为函数参数\r\n\r\n用法如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nvoid show(int\u0026 i);\r\n\r\nint main() {\r\n\tint i = 0;\r\n\tshow(i);\r\n\tstd::cout \u003c\u003c \"now i = \" \u003c\u003c i;\r\n\treturn 0;\r\n}\r\n\r\nvoid show(int\u0026 i) {\r\n\tstd::cout \u003c\u003c \"enter function i = \" \u003c\u003c i \u003c\u003c \"\\n\";\r\n\tstd::cout \u003c\u003c \"exiting function i = \" \u003c\u003c ++i \u003c\u003c \"\\n\";\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nenter function i = 0\r\nexiting function i = 1\r\nnow i = 1\r\n```\r\n\r\n可见，函数中对于引用变量的使用只是函数形参定义方式不同，其余均没什么变化。\r\n\r\n### 2.2 引用变量的可变性与不可变性\r\n\r\n以下程序作为对引用变量引用的验证\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nint main() {\r\n\tint i = 0;\r\n\tint\u0026 j = i;\r\n\tstd::cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c \" j = \" \u003c\u003c j \u003c\u003c \"\\n\";\r\n\tstd::cout \u003c\u003c \"i's address is \" \u003c\u003c \u0026i \u003c\u003c \", j's address is \" \u003c\u003c \u0026j \u003c\u003c \"\\n\";\r\n\tint temp = 100;\r\n\tj = temp;\r\n\tstd::cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c \" j = \" \u003c\u003c j \u003c\u003c \"\\n\";\r\n\tstd::cout \u003c\u003c \"i's address is \" \u003c\u003c \u0026i \u003c\u003c \", j's address is \" \u003c\u003c \u0026j;\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\ni = 0 j = 0\r\ni's address is 0032FA74, j's address is 0032FA74\r\ni = 100 j = 100\r\ni's address is 0032FA74, j's address is 0032FA74\r\n```\r\n\r\n在引用变量中，如果想让引用对变量的修改操作不生效，即只读，那么用`const`修饰即可。\r\n\r\n\r\n## 三、默认参数\r\n\r\nC++可以为函数提供默认参数，方法是在函数原型上为参数直接赋值，需要注意的是，如果一个参数被赋默认值，那么该参数右边的所有形参都要提供默认值，如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nint addNum(int i, int j = 10);\r\n\r\nint main() {\r\n\tstd::cout \u003c\u003c addNum(10, 1) \u003c\u003c \"\\n\" \u003c\u003c addNum(10);\r\n\treturn 0;\r\n}\r\n\r\nint addNum(int i, int j) {\r\n\treturn i + j;\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\n11\r\n20\r\n```\r\n\r\n## 四、函数重载\r\n\r\n函数重载即同样的函数名不同类型或者不同个数的参数列表，如果调用函数时函数参数不完全匹配，就会进行强制类型转换后再匹配，示例如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nint addNum(int i, int j);\r\nint addNum(int i, int j, int k);\r\nint addNum(int i, double j);\r\n\r\nint main() {\r\n\tstd::cout \u003c\u003c addNum(10, 1) \u003c\u003c \"\\n\" \u003c\u003c addNum(10, 2.0) \u003c\u003c \"\\n\" \u003c\u003c addNum(10, 1, 3);\r\n\treturn 0;\r\n}\r\n\r\nint addNum(int i, int j) {\r\n\treturn i + j;\r\n}\r\n\r\nint addNum(int i, int j, int k) {\r\n\treturn i + j + k;\r\n}\r\n\r\nint addNum(int i, double j) {\r\n\treturn i + j;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n11\r\n12\r\n14\r\n```\r\n\r\n## 五、函数模板\r\n\r\n函数模板其实就是函数参数化类型，函数的参数类型是在定义函数原型是提供的。使用方式为在定义函数原型和实体的上面定义模板，如下\r\n\r\n```\r\ntemplate \u003cclass t\u003e\r\n```\r\n\r\n或者\r\n\r\n```\r\ntemplate \u003ctypename t\u003e\r\n```\r\n\r\n示例如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\ntemplate \u003cclass t\u003e\r\nvoid swap(t\u0026 i, t\u0026 j);\r\n\r\nint main() {\r\n\tint i = 10, j = 11;\r\n\tswap(i, j);\r\n\tstd::cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c \", j = \" \u003c\u003c j \u003c\u003c \"\\n\";\r\n\tfloat k = 11.0f, l = 51.1f;\r\n\tswap(k, l);\r\n\tstd::cout \u003c\u003c \"k = \" \u003c\u003c k \u003c\u003c \", l = \" \u003c\u003c l \u003c\u003c \"\\n\";\r\n\treturn 0;\r\n}\r\n\r\ntemplate \u003cclass t\u003e\r\nvoid swap(t\u0026 i, t\u0026 j) {\r\n\ti = i + j;\r\n\tj = i - j;\r\n\ti = i - j;\r\n}\r\n```\r\n\r\n上述程序实现两个数字的交换，运行结果为\r\n\r\n```\r\ni = 11, j = 10\r\nk = 51.1, l = 11\r\n```\r\n\r\n由于函数存在重载行为，那么模板函数也必然可以重载，不过是为每个重载的函数定义模板即可，不再赘述。","cover":"/images/c++.jpg","link":"deep-into-cpp-functions.html","preview":"\u003cp\u003eC++内联函数、引用变量、默认参数、函数重载、函数模板。\u003c/p\u003e\n","title":"深入C++函数"},{"content":"\r\n\r\n## 一、函数和一维数组\r\n\r\n有如下函数\r\n\r\n```\r\nint sum_arr(int arr[], int n);\r\n\r\nint sum_arr(int arr[], int n) {\r\n\tint total = 0;\r\n\tfor (int i = 0; i \u003c n; i ++) {\r\n\t\ttotal += arr[i];\r\n\t}\r\n\treturn total;\r\n}\r\n```\r\n\r\n其中函数`sum_arr(int arr[], int n)`接受一个数组，由于数组名代表的是数组首元素地址，也就是说这个函数实质上接受的是一个指针，正确的函数头应该是`int sum_arr(int * arr, int n)`，那么正确的函数定义就是\r\n\r\n```\r\n\r\nint sum_arr(int * arr, int n);\r\n\r\nint sum_arr(int* arr, int n) {\r\n\tint total = 0;\r\n\tfor (int i = 0; i \u003c n; i ++) {\r\n\t\ttotal += arr[i];\r\n\t}\r\n\treturn total;\r\n}\r\n```\r\n\r\n指向数组的指针访问数组元素仍然可以使用下标方式，指针方式也是适用的，如下\r\n\r\n```\r\nint sum_arr(int * arr, int n);\r\n\r\nint sum_arr(int* arr, int n) {\r\n\tint total = 0;\r\n\tfor (int i = 0; i \u003c n; i ++) {\r\n\t\ttotal += *(arr + i);\r\n\t}\r\n\treturn total;\r\n}\r\n```\r\n\r\n调用该函数直接将数组传入即可，因为归根结底依旧是传入地址，如下\r\n\r\n```\r\nint sum_arr(int * arr, int n);\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tint arr[] {5, 4, 3, 2, 1};\r\n\tint len = sizeof arr / sizeof arr[0];\r\n\tcout \u003c\u003c \"array's sum is \" \u003c\u003c sum_arr(arr, len);\r\n\treturn 0;\r\n}\r\n\r\nint sum_arr(int* arr, int n) {\r\n\tint total = 0;\r\n\tfor (int i = 0; i \u003c n; i ++) {\r\n\t\ttotal += *(arr + i);\r\n\t}\r\n\treturn total;\r\n}\r\n```\r\n\r\n## 二、函数与二维数组\r\n\r\n依旧传的是地址，由于之前解释过二维数组指针，所以此处不赘述，直接上代码，如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nint sum_arr(int (*arr)[4], int n);\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tint arr[2][4] {{4, 3, 2, 1}, {1, 2, 3, 4}};\r\n\tint len = sizeof arr / sizeof arr[0];\r\n\tcout \u003c\u003c \"array's sum is \" \u003c\u003c sum_arr(arr, len);\r\n\treturn 0;\r\n}\r\n\r\nint sum_arr(int(*arr)[4], int n) {\r\n\tint total = 0;\r\n\tfor (int i = 0; i \u003c n; i ++) {\r\n\t\tfor (int j = 0; j \u003c 4; j++) {\r\n\t\t\ttotal += *(*(arr + i) + j);\r\n\t\t}\r\n\t}\r\n\treturn total;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\narray's sum is 20\r\n```\r\n\r\n## 三、函数与指针\r\n\r\n上述函数依旧可以获取地址然后交给一个指针，这样就可以通过指针来引用该函数。\r\n\r\n### 3.1 函数指针的声明\r\n\r\n函数指针的声明同函数的声明一样，必须指定返回值类型和参数列表，，只不过把函数名变成了指向函数的指针，也就是`*XXX`的形式，如下声明一个函数和与函数同类型的指针，只不过是还没有指向该函数\r\n\r\n```\r\nint sum_arr(int (*arr)[4], int n);\r\n\r\nint (*p) (int(*arr)[4], int n)\r\n```\r\n\r\n可见，只不过是函数名换成了指针，通过获取函数的地址将其赋给指针就实现了指针向该函数的指向。\r\n\r\n### 3.2 获取函数地址并赋值给指针并调用函数\r\n\r\n函数名就代表函数的地址，注意仅仅是函数名，不包括参数列表，赋值如下\r\n\r\n```\r\nint (*p) (int(*arr)[4], int n) = sum_arr;\r\n```\r\n\r\n这样，指针p就指向了函数，也就可以通过指针p来调用函数。\r\n\r\n由于函数名就是地址，那么每次函数调用也就是通过函数地址来调用函数的，可以理解为该地址就是函数的入口地址，只需要将参数列表传入即可。那么现在指针p指向函数地址，也就是指针内存中存储的就是函数的入口地址，那么通过`*`取值就可以得到函数的地址，也就意味着，通过指针调用函数就是如下形式\r\n\r\n```\r\n(*p)(arr, len)\r\n```\r\n\r\n等同于\r\n\r\n```\r\nsum_arr(arr, len)\r\n```\r\n\r\n很明显，指针p的取值也就是指针p内存空间中存储的就是函数地址，也就是(*p)就是sum_arr。完整的示例如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nint sum_arr(int (*arr)[4], int n);\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tint arr[2][4]{ {4, 3, 2, 1}, {1, 2, 3, 4}};\r\n\tint len = sizeof arr / sizeof arr[0];\r\n\tint (*p) (int(*arr)[4], int n) = sum_arr;\r\n\tcout \u003c\u003c \"array's sum is \" \u003c\u003c (*p)(arr, len);\r\n\treturn 0;\r\n}\r\n\r\nint sum_arr(int(*arr)[4], int n) {\r\n\tint total = 0;\r\n\tfor (int i = 0; i \u003c n; i ++) {\r\n\t\tfor (int j = 0; j \u003c 4; j++) {\r\n\t\t\ttotal += *(*(arr + i) + j);\r\n\t\t}\r\n\t}\r\n\treturn total;\r\n}\r\n```\r\n\r\n### 3.3 auto关键字\r\n\r\n也可以使用C++11的新特性，auto关键字来自动推导类型，那么下述两条语句是等价的\r\n\r\n```\r\nint (*p) (int(*arr)[4], int n) = sum_arr;\r\nauto p2 = sum_arr;\r\n```\r\n\r\n也就是p2中存放的还是sum_arr的地址，自然而言，对p2取值就可以获取sum_arr的地址也就意味着可以调用函数sum_arr，如下依旧等价\r\n\r\n```\r\ncout \u003c\u003c \"array's sum is \" \u003c\u003c (*p)(arr, len);\r\ncout \u003c\u003c \"array's sum is \" \u003c\u003c (*p2)(arr, len);\r\n```\r\n\r\n可见，auto关键字在这里不过是让声明指向函数的指针变的简单而优雅了许多。\r\n\r\n### 3.4 typedef关键字\r\n\r\ntypedef关键字可以定义类型的别名，如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n#include \u003cstring\u003e\r\n\r\ntypedef struct s_h {\r\n\tint id;\r\n\tstd::string name;\r\n} stu;\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\ttypedef double dou;\r\n\tdou d = 100.0;\r\n\tstu student = { 1, \"Feily Zhang\" };\r\n\tcout \u003c\u003c \"d = \" \u003c\u003c d \u003c\u003c endl;\r\n\tcout \u003c\u003c \"student = \" \u003c\u003c student.id \u003c\u003c \"  \" \u003c\u003c student.name \u003c\u003c endl;\r\n\treturn 0;\r\n}\r\n```","cover":"/images/c++.jpg","link":"function-about-pointer.html","preview":"\u003cp\u003e指针在函数中的应用。\u003c/p\u003e\n","title":"函数关于指针"},{"content":"\r\n\r\n## 一、数组\r\n\r\nC++数组的定义必须指明数组长度，通用格式如下\r\n\r\n```\r\ntypeName arrayName[arraySize];\r\n```\r\n\r\n一维数组与二维数组的示例如下：\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nint main() {\r\n\tint arr[5];\r\n\tint arr_length = sizeof arr / sizeof arr[0];\r\n\tfor (int i = 0; i \u003c arr_length; i++) {\r\n\t\tarr[i] = i * i;\r\n\t}\r\n\tint index = 0;\r\n\tint* pArr = arr;\r\n\twhile (index != arr_length) {\r\n\t\tstd::cout \u003c\u003c *(pArr + index) \u003c\u003c \"\\t\";\r\n\t\t++index;\r\n\t}\r\n\tint arrt[5][4];\r\n\tint arr_row_len = sizeof arrt / sizeof arrt[0];\r\n\tint arr_col_len = sizeof arrt[0] / sizeof arrt[0][0];\r\n\tfor (int i = 0; i \u003c arr_row_len; i++) {\r\n\t\tfor (int j = 0; j \u003c arr_col_len; j++) {\r\n\t\t\tarrt[i][j] = i * j;\r\n\t\t}\r\n\t}\r\n\tstd::cout \u003c\u003c std::endl;\r\n\tint(*pArrt)[4];\r\n\tpArrt = arrt;\r\n\tint row_index = 0, col_index = 0;\r\n\tfor (int i = 0; i \u003c arr_row_len; i++) {\r\n\t\tfor (int j = 0; j \u003c arr_col_len; j++) {\r\n\t\t\tstd::cout \u003c\u003c *(*(pArrt + i) + j) \u003c\u003c \"\\t\";\r\n\t\t}\r\n\t\tstd::cout \u003c\u003c std::endl;\r\n\t}\r\n\tstd::cin.get();\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n0       1       4       9       16\r\n0       0       0       0\r\n0       1       2       3\r\n0       2       4       6\r\n0       3       6       9\r\n0       4       8       12\r\n```\r\n\r\n上述程序分别演示了一维数组和二维数组，并且数组的输入是采用常规的方式，数组的输出是采用指针的方式。\r\n\r\n一维数组的指针使用符合上文中的两个等式，如下\r\n\r\n```\r\narr[i] = *(ar + i);\r\n\u0026arr[i] = ar + i; \r\n```\r\n\r\n**而二维数组的指针则相对麻烦一点，解释如下**\r\n\r\n一维数组中声明指针的方式如下\r\n\r\n```\r\nint* pArr = arr;\r\n```\r\n\r\n此时指针pArr中存储的是数组的首元素的地址，通过指针对元素的访问是加上元素偏移实现的，而指针的长度则可以防止访问越界。二维数组的指针我们换个方式看一下\r\n\r\n仍然是基于上述程序，我们尝试输出一下pArrt\r\n\r\n```\r\nstd::cout \u003c\u003c pArrt;    // 0034FC2C\r\n```\r\n\r\n是一个地址，这很容易理解，毕竟指针存的就是地址，那么`*pArrt`以及`*(pArrt + 1)`呢，按照常理，如果pArrt是地址，那么pArrt + 1就是pArrt指针指向内存区的下一个内存区的地址，对二者取值必然是两个连续地址空间的值了，但是真的是这样吗？\r\n\r\n```\r\nstd::cout \u003c\u003c *pArrt \u003c\u003c \"\\t\" \u003c\u003c *(pArrt + 1);    // 004BFB20        004BFB30\r\n```\r\n\r\n还是一个地址，但是观察一下这两个地址值相差16个字节，在本机int型实现为4个字节，那么按理来说每个int型元素只会占用4个字节，也就是`*(pArrt + 1)`应该是004BFB24，但是为什么是004BFB30呢？中间的12个字节去哪了？\r\n\r\n不要忘了，我们二维数组的每列有4个int型元素，刚好16个字节，这样推论的话，就意味着`*pArrt`应该指的是二维数组第0行的首元素的地址，而`*(pArrt + 1)`指的就是二维数组第1行首元素的地址，因为中间12个字节刚好的第0行剩余三个元素的内存空间。那么相应的第i行的首元素的地址就是`*(pArrt + i)`。那么我们试一下第0行的值是否与上文程序输出一致\r\n\r\n\r\n\r\n```\r\nstd::cout \u003c\u003c *(*pArrt + 0) \u003c\u003c \"\\t\" \u003c\u003c *(*pArrt + 1) \u003c\u003c \"\\t\" \u003c\u003c *(*pArrt + 2) \u003c\u003c \"\\t\" \u003c\u003c *(*pArrt + 3) \u003c\u003c \"\\t\";    // 0       0       0       0\r\n```\r\n\r\n完全一致！\r\n\r\n那么我们再验证一下第0行的第四个元素的最后一个元素是否是第1行的首元素，如下\r\n\r\n```\r\nstd::cout \u003c\u003c *(pArrt + 0) \u003c\u003c \"\\t\" \u003c\u003c *(pArrt + 1) \u003c\u003c std::endl;\r\nfor (int i = 0; i \u003c 5; i++) {\r\n    std::cout \u003c\u003c *(pArrt + 0) + i \u003c\u003c \"\\t\";\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n002EF700        002EF710\r\n002EF700        002EF704        002EF708        002EF70C        002EF710\r\n```\r\n\r\n\u003e 注意：由于每次运行都会产生不一样的结果，所以地址是有变化的。\r\n\r\n观察一下输出结果的第一行和第二行的最后的地址，一模一样，这也就证明了`*(pArrt + 0)`(也就是`*(pArrt)`)存放的是第0行的首元素的地址，之后跟随的是第0行的剩余的三个元素，由于数组存储在连续地址空间，那么第1行的第一个元素必然紧接着第0行的最后一个元素，在上述代码中，也得到了证明。那么这里都得到了每个元素的地址，在取值一次不就得到了值了嘛！，对的\r\n\r\n\r\n```\r\nfor (int i = 0; i \u003c 5; i++) {\r\n    std::cout \u003c\u003c *(*(pArrt + 0) + i) \u003c\u003c \"\\t\";\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n0       0       0       0       0\r\n```\r\n\r\n没问题，综上，我们得出以下结论\r\n\r\n+ `*(pArrt + i)`代表的是二维数组第i行的首元素的**地址（注意，这里是地址，不是值）**\r\n+ `*(pArrt + i) + j`代表的就是二维数组第i行第j列的**地址（注意，这里是地址，不是值）**\r\n+ `*(*(pArrt + i) + j)`代表的就是二维数组第i行第j列的**值（现在是值了，因为通过`*`再取值了一次）**\r\n\r\n那么pArrt自然代表的就是`*pArrt`的地址，也就是地址的地址，即二维数组首行首元素的地址。\r\n\r\n**还有，二维数组的指针这样声明**\r\n\r\n```\r\nint(*pArrt)[4];\r\n```\r\n\r\n为什么？不能是`int * ar2[4]`吗？\r\n\r\n不行，因为`int * ar2[4]`代表的是组织了4个int型指针的数组，其本质是int型指针，而不是数组，数组只是将其组织了起来而已。而`int(*pArrt)[4]`则代表的是二维数组的一行，这一行由4个int型元素组成，其本质是数组，指针是指向该一维数组（就是二维数组的行）的首元素地址，即指向由4个int组成的数组的指针。\r\n\r\n## 二、结构体\r\n\r\nC++中结构体的定义如下所示\r\n\r\n```\r\nstruct s_h {\r\n\tint id;\r\n\tchar name[12];\r\n\tchar sex[4];\r\n};\r\n```\r\n\r\n结构体本身就是一种数据类型，因此上述定义算是一种数据类型的定义，那么声明该种数据类型的变量如下\r\n\r\n```\r\ns_h stu;\r\n```\r\n\r\n对其初始化的方式为\r\n\r\n```\r\nstu = { 0, \"Feily Zhang\", \"man\" };\r\n```\r\n\r\n当然也可以直接声明的时候就初始化\r\n\r\n```\r\ns_h stu = { 0, \"Feily Zhang\", \"man\" };\r\n```\r\n\r\n而C++11中支持将列表初始化用于结构，这种方式下等号是可选的，即\r\n\r\n```\r\ns_h stu { 0, \"Feily Zhang\", \"man\" };\r\n```\r\n\r\n当然，定义结构体的时候直接声明变量也是可以的，如下\r\n\r\n```\r\nstruct s_h {\r\n\tint id;\r\n\tchar name[12];\r\n\tchar sex[4];\r\n} stu;\r\n```\r\n\r\n在上述基础之上直接初始化也是可以的，如下\r\n\r\n```\r\nstruct s_h {\r\n\tint id;\r\n\tchar name[12];\r\n\tchar sex[4];\r\n} stu { 0, \"Feily Zhang\", \"man\" };\r\n```\r\n\r\n当然，也可以定义结构体数组，如下\r\n\r\n```\r\ns_h stu[3]{\r\n    {0, \"Feily Zhang\", \"man\"},\r\n    {1, \"Itsing Lin\", \"man\"},\r\n    {2, \"Me\", \"man\"}\r\n};\r\nfor (int i = 0; i \u003c 3; i++) {\r\n    std::cout \u003c\u003c stu[i].id \u003c\u003c \"\\t\" \u003c\u003c stu[i].name \u003c\u003c \"\\t\" \u003c\u003c stu[i].sex \u003c\u003c std::endl;\r\n}\r\n```\r\n\r\n**指针对结构体的操作如下**\r\n\r\n需要注意的是指针无法对结构体中的char数组赋值，char数组作为字符串来使用是可以定义的时候直接赋值的，但是单独无法赋值，只能一个一个字符赋值，也很容易理解，Java中数组也不可能直接赋值给数组名，解决办法之一是使用string替代char数组，如下\r\n\r\n```\r\n\r\nstruct s_h {\r\n\tint id;\r\n\tstd::string name;\r\n\tstd::string sex;\r\n};\r\n\r\nvoid say() {\r\n\tusing namespace std;\r\n\tstd::cout \u003c\u003c \"hello, world!\" \u003c\u003c endl;\r\n\ts_h* pt = new s_h;\r\n\tpt-\u003eid = 0;\r\n\tpt-\u003ename = \"Feily Zhang\";\r\n\tpt-\u003esex = \"man\";\r\n    std:cout \u003c\u003c pt-\u003eid \u003c\u003c \"\\t\" \u003c\u003c pt-\u003ename \u003c\u003c \"\\t\" \u003c\u003c pt-\u003esex;\r\n\tdelete pt;\r\n\tstd::cin.get();\r\n}\r\n```\r\n\r\n另一种解决办法就是使用`strcpy()`函数将字符串复制到char数组的地址上，如下\r\n\r\n```\r\nstruct s_h {\r\n\tint id;\r\n\tchar name[20];\r\n\tchar sex[4];\r\n};\r\n\r\nvoid say() {\r\n\tusing namespace std;\r\n\tstd::cout \u003c\u003c \"hello, world!\" \u003c\u003c endl;\r\n\ts_h* pt = new s_h;\r\n\tpt-\u003eid = 0;\r\n\tstrcpy(pt-\u003ename, \"Feily Zhang\");\r\n\tstrcpy(pt-\u003esex, \"man\");\r\n    std:cout \u003c\u003c pt-\u003eid \u003c\u003c \"\\t\" \u003c\u003c pt-\u003ename \u003c\u003c \"\\t\" \u003c\u003c pt-\u003esex;\r\n\tdelete pt;\r\n\tstd::cin.get();\r\n}\r\n```\r\n\r\n\r\n对于结构体数组仍然可以声明指针，此处不再赘述。\r\n\r\n## 三、共用体\r\n\r\n共用体中的诸数据成员共用一块数据空间。需要注意的是\r\n\r\n1. 共用体中不能使用构造函数，即string等是无法使用的；\r\n2. 不能对共用体变量名赋值，也不能在定义一个共用体变量名的时候对其赋值，也就意味着只能单独对内部成员赋值；\r\n3. 不能把共用体当做函数参数也不能作为返回值返回，但是可以使用指向共用体变量的指针；\r\n4. 共用体可以在结构体中定义，也可以定义共用体指针。\r\n\r\n```\r\nde \u003ciostream\u003e\r\n\r\nunion id {\r\n\tint id_num;\r\n\tint name_num;\r\n};\r\n\r\nint main() {\r\n\tid id1;\r\n\tid1.id_num = 4311;\r\n\tid1.name_num = 4312;\r\n\tid* pt = \u0026id1;\r\n\tstd::cout \u003c\u003c pt-\u003eid_num \u003c\u003c \"\\t\" \u003c\u003c id1.name_num;\r\n\tstd::cin.get();\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n4312    4312\r\n```\r\n\r\n可见，不同的数据成员的值是一样的，也就证明了数据成员使用一块内存空间。\r\n\r\n## 四、枚举\r\n\r\n枚举是一种创建符号常量的方式，这种方式可以替代const。其通用声明格式如下\r\n\r\n```\r\nenum enumName {};\r\n```\r\n\r\n其中`{}`中为该枚举类型的所有可能的取值范围，为符号常量，并且编译器会其该符号常量指定一个整数值，缺省状态下从0开始，依次递增，当然也可以通过`=`修改。示例如下\r\n\r\n```\r\n\u003ciostream\u003e\r\n \r\nenum spe {red, orange, yellow, green, blue};\r\n\r\nint main() {\r\n\tspe s1, s2, s3;\r\n\ts1 = spe(2);\r\n\ts2 = red;\r\n\ts3 = s1;\r\n\tspe* s4;\r\n\ts4 = \u0026s1;\r\n\tstd::cout \u003c\u003c (s1 == s2) \u003c\u003c \"\\t\" \u003c\u003c (s1 == s3) \u003c\u003c \"\\t\" \u003c\u003c *s4;\r\n\tstd::cin.get();\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n0       1       2\r\n```\r\n\r\n## 五、string类\r\n\r\n与Java中String类没什么区别，string对象的声明、初始化、赋值以及拼接操作如下所示\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n#include \u003cstring\u003e\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tstring s1 = \"hello, world\";\r\n\tcout \u003c\u003c s1 \u003c\u003c \"\\t\" \u003c\u003c s1.size() \u003c\u003c endl;\r\n\tstring s2 = s1;\r\n\ts2 += \", this is s2 not s1\";\r\n\tcout \u003c\u003c s2 \u003c\u003c \"\\t\" \u003c\u003c s2.size() \u003c\u003c endl;\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nhello, world    12\r\nhello, world, this is s2 not s1 31\r\n```\r\n\r\n在C++新增string类之前，想要完成对字符串（或者说对于C风格的字符串）的赋值工作，必须借助于C语言库函数来完成，比如`strcpy(char[], char[])`和`strcat(char[], char[])`，但是在新增string类之后就不必了，很容易通过面向对象的方式来实现。\r\n\r\n对比如下:\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n#include \u003cstring\u003e\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tchar c1[20];\r\n\tchar c2[20] {\"jaguar\"};\r\n\tstrcpy(c1, c2);\r\n\tcout \u003c\u003c \"now c1 is \" \u003c\u003c c1 \u003c\u003c \" and length is \" \u003c\u003c strlen(c1) \u003c\u003c endl;\r\n\tstrcat(strcat(c1, c2), \"c1 + c2\");\r\n\tcout \u003c\u003c \"now c1 is \" \u003c\u003c c1 \u003c\u003c \" and length is \" \u003c\u003c strlen(c1) \u003c\u003c endl;\r\n\tstring s1 = \"hello, world\";\r\n\tcout \u003c\u003c s1 \u003c\u003c \"\\t\" \u003c\u003c s1.size() \u003c\u003c endl;\r\n\tstring s2 = s1;\r\n\ts2 += \", this is s2 not s1\";\r\n\tcout \u003c\u003c s2 \u003c\u003c \"\\t\" \u003c\u003c s2.size() \u003c\u003c endl;\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nnow c1 is jaguar and length is 6\r\nnow c1 is jaguarjaguarc1 + c2 and length is 19\r\nhello, world    12\r\nhello, world, this is s2 not s1 31\r\n```\r\n\r\n利用C语言库函数的缺点在于不安全，如果目标字符数组的大小不够，那么必然会产生数据错误，但是string类具有自动调整大小的功能，更加的安全。\r\n\r\n## 六、模板类vector与array\r\n\r\n模板类vector类似于string，也是一种动态数组，可以在运行阶段设置vector对象的长度，也可以在末尾和中间插入数据。基本上，它是利用new创建动态数组的替代品（前文的`getName()`函数），实际上，vector类确实使用new和delete来管理内存。\r\n\r\n对于vector的使用，第一其包含在std命名空间中；第二，在声明时要指出数据类型。如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n#include \u003cstring\u003e\r\n#include \u003cvector\u003e\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tvector\u003cstring\u003e v1;\r\n\tv1.resize(2);\r\n\tv1[0] = \"Feily Zhang\";\r\n\tv1[1] = \"Itsing Lin\";\r\n\t/*\r\n\tv1.push_back(\"Feily Zhang\");\r\n\tv1.push_back(\"Itsing Lin\");*/\r\n\tfor (int i = 0; i \u003c v1.size(); i++) {\r\n\t\tcout \u003c\u003c v1[i] \u003c\u003c endl;\r\n\t}\r\n\r\n\tvector\u003cstring\u003e v2(2);\r\n\tv2[0] = \"Feily Zhang\";\r\n\tv2[1] = \"Itsing Lin\";\r\n\tfor (int i = 0; i \u003c v2.size(); i++) {\r\n\t\tcout \u003c\u003c v2[i] \u003c\u003c endl;\r\n\t}\r\n\treturn 0;\r\n}\r\n```\r\n\r\n有两种使用方式，第一种是直接指明长度，另一种是通过`.resize()`方法来指明长度，vector调整长度也是通过这个方法，如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n#include \u003cstring\u003e\r\n#include \u003cvector\u003e\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tvector\u003cstring\u003e v1;\r\n\tv1.resize(2);\r\n\tv1[0] = \"Feily Zhang\";\r\n\tv1[1] = \"Itsing Lin\";\r\n\t/*\r\n\tv1.push_back(\"Feily Zhang\");\r\n\tv1.push_back(\"Itsing Lin\");*/\r\n\tfor (int i = 0; i \u003c v1.size(); i++) {\r\n\t\tcout \u003c\u003c v1[i] \u003c\u003c endl;\r\n\t}\r\n\r\n\tvector\u003cstring\u003e v2(2);\r\n\tv2[0] = \"Feily Zhang\";\r\n\tv2[1] = \"Itsing Lin\";\r\n\tfor (int i = 0; i \u003c v2.size(); i++) {\r\n\t\tcout \u003c\u003c v2[i] \u003c\u003c endl;\r\n\t}\r\n\r\n\tv1.resize(4);\r\n\tfor (int i = 0; i \u003c v1.size(); i++) {\r\n\t\tcout \u003c\u003c i \u003c\u003c \" = \" \u003c\u003c v1[i] \u003c\u003c endl;\r\n\t}\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nFeily Zhang\r\nItsing Lin\r\nFeily Zhang\r\nItsing Lin\r\n0 = Feily Zhang\r\n1 = Itsing Lin\r\n2 =\r\n3 =\r\n```\r\n\r\n另外，也可以使用`.push_back()`方法来添加元素。\r\n\r\n\r\nvector的功能比数组强大，比如说可以动态扩容，但是付出的代价是效率稍低。如果需要的是固定长度的数组，使用数组无疑是最方便且高效的，但是却并不安全。C++11新增的模板类array，其对象长度固定，也使用栈（静态内存分配）而不是自由存储区，因此效率与数组相同，且更加安全.\r\n\r\narray同样位于std命名空间，使用时需要指明长度和数据类型，用法如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n#include \u003cstring\u003e\r\n#include \u003carray\u003e\r\n\r\nint main() {\r\n\tusing namespace std;\r\n\tarray\u003cstring, 2\u003e a1 {\"Feily Zhang\", \"Itsing Lin\"};\r\n\tfor (int i = 0; i \u003c a1.size(); i++) {\r\n\t\tcout \u003c\u003c i \u003c\u003c \" = \" \u003c\u003c a1[i] \u003c\u003c endl;\r\n\t}\r\n\tarray\u003cstring, 2\u003e a2;\r\n\ta2[0] = \"hello, world\";\r\n\ta2[1] = \"world, hello\";\r\n\tfor (int i = 0; i \u003c a2.size(); i++) {\r\n\t\tcout \u003c\u003c i \u003c\u003c \" = \" \u003c\u003c a2[i] \u003c\u003c endl;\r\n\t}\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n0 = Feily Zhang\r\n1 = Itsing Lin\r\n0 = hello, world\r\n1 = world, hello\r\n```","cover":"/images/c++.jpg","link":"cpp-custom-data-type.html","preview":"\u003cp\u003eC++自定义数据类型包括数组、结构体、共用体、枚举。写C/C++不用指针是没有灵魂的！\u003c/p\u003e\n","title":"C++自定义数据类型"},{"content":"\r\n\r\n## 一、整型\r\n\r\n|类型|位数|\r\n|---|---|\r\n|short|至少16位|\r\n|int|至少和short一样长|\r\n|long|至少32位，且至少与int一样长|\r\n|long long|至少64位，且至少与long一样长|\r\n\r\n可见以上描述只是规定了各类型的最小长度，在不同的计算机上有不同的实现。查看本机类型的长度可以使用`sizeof`运算符，其得到的结果的单位为字节。如下所示\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nvoid showLimits();\r\n\r\nint main() {\r\n\tshowLimits();\r\n\treturn 0;\r\n}\r\n\r\nvoid showLimits() {\r\n\tstd::cout \u003c\u003c \"sizeof(short) = \" \u003c\u003c sizeof(short) \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"sizeof(int) = \" \u003c\u003c sizeof(int) \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"sizeof(long) = \" \u003c\u003c sizeof(long) \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"sizeof(long long) = \" \u003c\u003c sizeof(long long) \u003c\u003c std::endl;\r\n\tstd::cin.get();\r\n}\r\n```\r\n\r\n本机输出为\r\n\r\n```\r\nsizeof(short) = 2\r\nsizeof(int) = 4\r\nsizeof(long) = 4\r\nsizeof(long long) = 8\r\n```\r\n\r\n也可以通过变量名来查看特定数据类型的长度，在这种情况下，`sizeof`运算符的括号可以忽略，如下\r\n\r\n```\r\ninclude \u003ciostream\u003e\r\n\r\nvoid showLimits();\r\n\r\nint main() {\r\n\tshowLimits();\r\n\treturn 0;\r\n}\r\n\r\nvoid showLimits() {\r\n\tshort s = 1;\r\n\tint i = 2;\r\n\tlong l = 3;\r\n\tlong long ll = 4;\r\n\tstd::cout \u003c\u003c \"sizeof s  = \" \u003c\u003c sizeof s \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"sizeof i = \" \u003c\u003c sizeof i \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"sizeof l = \" \u003c\u003c sizeof l \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"sizeof ll = \" \u003c\u003c sizeof ll \u003c\u003c std::endl;\r\n\tstd::cin.get();\r\n}\r\n```\r\n\r\n其次，头文件`climits`中包含了关于整型的限制信息，`climits`中的符号常量如下表所示\r\n\r\n|符号常量|表示|\r\n|-----|-----|\r\n|CHAR_BIT|char的位数|\r\n|CHAR_MAX|char的最大值|\r\n|CHAR_MIN|char的最小值|\r\n|SCHAR_MAX|signed char的最大值|\r\n|SCHAR_MIN|signed char的最小值|\r\n|UCHAR_MAX|unsigned char的最大值|\r\n|SHRT_MAX|short的最大值|\r\n|SHRT_MIN|short的最小值|\r\n|USHRT_MAX|unsigned short的最大值|\r\n|INT_MAX|int的最大值|\r\n|INT_MIN|int的最小值|\r\n|UNIT_MAX|unsigned int的最大值|\r\n|LONG_MAX|long的最大值|\r\n|LONG_MIN|long的最小值|\r\n|ULONG_MAX|unsigned long的最大值|\r\n|LLONG_MAX|long long的最大值|\r\n|LLONG_MIN|long long的最小值|\r\n|ULLONG_MAX|unsigned long的最大值|\r\n\r\n部分示例程序如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n#include \u003cclimits\u003e\r\n\r\nvoid showClimits();\r\n\r\nint main() {\r\n\tshowClimits();\r\n\treturn 0;\r\n}\r\n\r\nvoid showClimits() {\r\n\tstd::cout \u003c\u003c \"SHRT_MAX = \" \u003c\u003c SHRT_MAX \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"SHRT_MIN = \" \u003c\u003c SHRT_MIN \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"INT_MAX = \" \u003c\u003c INT_MAX \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"INT_MIN = \" \u003c\u003c INT_MIN \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"LONG_MAX = \" \u003c\u003c LONG_MAX \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"LONG_MIN = \" \u003c\u003c LONG_MIN \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"LLONG_MAX = \" \u003c\u003c LLONG_MAX \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c \"LLONG_MIN = \" \u003c\u003c LLONG_MIN \u003c\u003c std::endl;\r\n\tstd::cin.get();\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nSHRT_MAX = 32767\r\nSHRT_MIN = -32768\r\nINT_MAX = 2147483647\r\nINT_MIN = -2147483648\r\nLONG_MAX = 2147483647\r\nLONG_MIN = -2147483648\r\nLLONG_MAX = 9223372036854775807\r\nLLONG_MIN = -9223372036854775808\r\n```\r\n\r\n对于无符号数而言，可以增大相应数据类型能够表示的最大值，这是通过牺牲掉负数实现的。对于有符号数和无符号数而言，一旦超出它所能表示的最大范围，就会发生溢出，具体溢出行为如下所示\r\n\r\n\r\n## 二、浮点型\r\n\r\n浮点数有两种表示方法，分别是标准小数点表示法和E表示法。E表示法适合表示非常大的数和非常小的数。浮点数类型如下\r\n\r\n|类型|位数|\r\n|-----|-----|\r\n|float|至少32位|\r\n|double|至少48位，且不少于float|\r\n|long double|至少和double一样多|\r\n\r\nC++中浮点数的默认类型为double，如果希望存储float类型，那么为小数加上f或F后缀，对于long double类型，需要加上l或L后缀。\r\n\r\n浮点数的优点在于可以表示整数之间的值；表示的范围比较大；但是运算速度慢于整数，且精度会降低。\r\n\r\n## 三、字符型\r\n\r\nchar用于处理字符，但也可以将它用作比short更短的整型，因为其底层存储的依旧是字符的编码，所以由于char是一种整型，那么也可以进行加法运算，这样就代表的是以原始编码为基址，以加数为偏移的字符编码。但是程序仍然会输出字符而不是编码这是由于cout与cin会完成转换工作，要查看其编码，可以将char强制转换为整型即可。char占8位。示例程序如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nint main() {\r\n\tchar c = 'M';\r\n\tstd::cout \u003c\u003c \"c is \" \u003c\u003c c \u003c\u003c \" and c's code is \" \u003c\u003c (int)c \u003c\u003c std::endl;\r\n\tc += 1;\r\n\tstd::cout \u003c\u003c \"now c is \" \u003c\u003c c \u003c\u003c \" and c's code is \" \u003c\u003c (int)c \u003c\u003c std::endl;\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nc is M and c's code is 77\r\nnow c is N and c's code is 78\r\n```\r\n\r\nchar存储的是ANSI字符，那么对于字符数超过256个的字符集而言，就显得无能为力。\r\n\r\n`wchar_t`表示的是宽字符，存储的是Unicode字符编码，用法为`wchar_t c = L'P'`,即要加上L前缀，占16位。\r\n\r\nC++11新增了两种类型，为`char16_t`和`char32_t`，均为无符号类型，前者长16位，后者长12位，前者字面量要加上前缀小写u，后者要加上前缀大写U。\r\n\r\n## 四、布尔型\r\n\r\n这种很简单，关键字为`bool`。\r\n\r\n## 五、空类型\r\n\r\n关键字`void`定义的类型，不能用于普通变量的声明和操作，只能用于指针型变量，函数返回值和函数参数。\r\n\r\n## 六、指针类型\r\n\r\n指针是一种类型，该类型指向特定数据类型内存区的地址，即指针类型存放的是某一内存区的地址。\r\n\r\n### 6.1 指针的声明\r\n\r\n`typeName * pointerName`\r\n\r\n指针的类型是什么，就代表该类型的指针指向的是什么类型的内存区。\r\n\r\n### 6.2 指针的赋值\r\n\r\n给指针赋值，方法有以下几种，分别是\r\n\r\n+ 对于预定义类型而言，直接利用取址运算符\u0026即可拿到特定类型的内存区地址，然后给指针变量即可；\r\n+ 对于自定义类型而言，以数组为例，由于数组名代表的是数组的首元素的地址，所以直接将数组名赋给指针变量即可；\r\n+ 上述两种情况是自动分配内存的且内存区具有代表该内存区的变量名，也可以使用new运算符为指针赋予特定类型内存区的匿名地址，要显式的通过`delete`来释放空间。\r\n\r\n示例如下\r\n\r\n```\r\nint nights = 1001;\r\nint * pt = \u0026nights;    // 第一种方法, 或者如下一行\r\npt = \u0026nights;\r\ndouble wage[3] = {10000.0, 20000.0, 30000.0};\r\ndouble * ptW = wage;    // 第二种方法，或者如下一行\r\ndouble * ptN = \u0026wage[0];    // 可见，指针要的只是数组首元素的地址\r\nint * ps = new int;    // 第三种方法，创建int型的连续内存区域并将地址返回给指针\r\nint * psome = new int[10];    // 第三种方法，创建int型的连续内存区域的数组，并将数组首元素的地址返回给指针\r\ndelete ps;    // 第三种方法，释放内存\r\ndelete [] psome;    // 第三种方法，释放内存\r\n```\r\n\r\n### 6.3 对指针解除引用\r\n\r\n对指针解除引用意味着获取指针所指向内存区域的值。方法是通过*取值运算符，如下\r\n\r\n```\r\ncout \u003c\u003c *pointerName\r\n```\r\n\r\n另外，指针中对数组的访问仍然可以使用数组下标的方式，即以下等式恒成立\r\n\r\n```\r\narr[i] = *(ar + i);    // 数组访问方式中第i个元素的值为arr[i], 指针访问方式中第i个元素的地址为ar + i，那么值就是*(ar + i)\r\n\u0026arr[i] = ar + i;    // 数组访问方式中第i的元素的地址为\u0026arr[i],指针访问方式中第i个元素的地址为ar + i。\r\n```\r\n\r\n### 6.4 区分指针和指针所指向的值\r\n\r\n如果pt是指向int的指针，那么`*pt`不是指向int的指针，而是代表int型内存区域的值，也就是说效力等同于int型内存区域的变量名。只有pt才是指针，才代表的是某类型的地址，加上取值运算符`*`就成为了该地址的值。 示例如下\r\n\r\n```\r\nint * pt = new int;    // 开辟int大小的内存区域，并将地址给pt指针\r\n*pt = 5；    // pt代表的值地址，那么*pt代表的就是值，这句代码就是将5存入pt地址处\r\n```\r\n\r\n### 6.5 指针算术\r\n\r\nC++允许指针和整数相加，加1代表指向连续内存区域的下一个地址空间，减法也是同样的道理，所以可以通过`*(ar + i)`的形式访问数组，等同于`arr[i]`。\r\n\r\n### 6.6 数组的动态联编和静态联编\r\n\r\n使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置，如\r\n\r\n```\r\nint tacos[10];\r\n```\r\n\r\n使用`new`运算符创建数组时，将采用动态联编，即将在运行时为数组分配空间，其长度也将在运行时设置。这种情况下，应该通过`delete []`运算符显式释放内存。\r\n\r\n### 6.7 指针和字符串\r\n\r\n一般来说（比如以上），如果给cout提供的是指针，那么将打印地址，但是如果指针的类型为`char *`,那么cout打印指针指向的字符串。如果非要显式字符串的地址，那么需要将其强制转型为(int *)。如下所示\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nint main() {\r\n\tconst char* pt = \"wren\";\r\n\tstd::cout \u003c\u003c pt \u003c\u003c std::endl;\r\n\tstd::cout \u003c\u003c (int *)pt \u003c\u003c std::endl;\r\n\treturn 0;\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nwren\r\n002F9FCC\r\n```\r\n\r\n由于字符串字面值是常量，所以被声明为`const`。\r\n\r\n对于字符串的复制，不能简单粗暴的直接将字符串赋给指针，因为这样指针指向的依旧是以前的字符串，对指针的操作仍然会反映到字符串上，可行的办法就是通过`strcpy()`函数来实现，该函数接收两个参数，一个是目标地址，另一个是源地址。\r\n\r\n## 七、自动存储、静态存储和动态存储\r\n\r\n根据用于内存分配的方法，C++有三种管理数据内存的方式：自动存储、静态存储、动态存储。\r\n\r\n### 7.1 自动存储\r\n\r\n在函数内部定义的常规变量使用自动存储空间，被称为自动变量，这就意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。也就是说，自动变量是一个局部变量，其作用于仅为包含它的代码块。\r\n\r\n自动变量通常存储在栈中，也就意味着执行代码块时，其中的变量将依次加载到栈中，而在离开代码块时，将按照相反的顺序释放这些变量。在程序执行过程中，栈将不断的增大或者缩小。\r\n\r\n### 7.2 静态存储\r\n\r\n静态存储是整个程序执行期间都存在的存储方式。使变量称为静态的方式有两种，分别是：\r\n\r\n+ 一种是在函数外面定义它；\r\n+ 另一种是在声明变量时使用关键字`static`修饰。\r\n\r\n自动存储和静态存储的关键在于：这些方法严格地限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也可能只是在特定的函数被执行时存在（自动变量）。\r\n\r\n### 7.3 动态存储\r\n\r\n`new`和`delete`运算符提供了一种比自动变量和静态变量更为灵活的方法，它们管理一个内存池，这在C++中被称为自由存储空间(free store)或堆(heap)。`new`和`delete`运算符让你能够在一个函数中分配内存，在另一个函数中释放内存，因此，数据的生命周期不完全手程序或者函数的生存时间限制。示例如下\r\n\r\n```\r\n#include \u003ciostream\u003e\r\n\r\nchar* getName();\r\n\r\nint main() {\r\n\tchar* p = getName();\r\n\tstd::cout \u003c\u003c std::endl\u003c\u003c \"Your name is \" \u003c\u003c p \u003c\u003c \" and memory address is \" \u003c\u003c (int *)p;\r\n\tstd::cin.get();\r\n\tdelete[] p;\r\n\treturn 0;\r\n}\r\n\r\nchar* getName() {\r\n\tchar temp[80];\r\n\tstd::cout \u003c\u003c \"Enter your name: \";\r\n\tstd::cin \u003e\u003e temp;\r\n\tchar* pn = new char[strlen(temp) + 1];\r\n\tstrcpy(pn, temp);\r\n\treturn pn;\r\n}\r\n```\r\n\r\n运行结果为\r\n\r\n```\r\nEnter your name: Feily Zhang\r\n\r\nYour name is Feily and memory address is 00B2D3D8\r\n```","cover":"/images/c++.jpg","link":"predefined-data-types-in-cpp.html","preview":"\u003cp\u003eC++中的预定义数据类型包括整型、浮点型、字符型、布尔型、空类型、指针类型, 自动存储、静态存储和动态存储。\u003c/p\u003e\n","title":"C++中的预定义数据类型"},{"content":"\r\n\r\n![Java并发编程的艺术总结](/images/article/Art-of-java-concurrent-programming.jpg)","cover":"/images/article/Art-of-java-concurrent-programming.jpg","link":"art-of-java-concurrent-programming.html","preview":"\u003cp\u003e并发带来的挑战、Java并发机制的底层实现原理、Java并发容器与框架。\u003c/p\u003e\n","title":"《Java并发编程的艺术》笔记(手写扫描版)"},{"content":"\r\n\r\n# 一、数据结构\r\n\r\n## 一、简单动态字符串（SDS）\r\n\r\nRedis没有直接使用C语言传统的字符串表示（即以空字符`\\0`结尾的字符数组），而是直接自己构建了一种称为简单动态字符串的抽象类型，并作为Redis中的默认字符串表示。\r\n\r\n当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如客户端执行如下命令\r\n\r\n```\r\nredis\u003e SET msg \"hello, world\"\r\nOK\r\n```\r\n\r\n那么Redis就会在底层创建一个新的键值对，包含：\r\n\r\n+ 键值对的键是一个字符串对象，对象的底层实现是一个保存着字符串“msg”的SDS;\r\n+ 键值对的值也是一个字符串对象，对象的底层实现是一个保存着字符串“hello, world”的SDS。\r\n\r\n#### 1.1 SDS的结构（或实现）\r\n\r\nSDS通过一个结构体来实现，每个`sds.h/sdshdr`结构表示一个SDS值，如下\r\n\r\n```\r\nstruct sdshdr {\r\n    int len;\r\n    int free;\r\n    char buf[];\r\n}\r\n```\r\n\r\n各属性解释如下：\r\n\r\n+ `len`：记录buf数组中已经使用的字节的数量；\r\n+ `free`：记录buf数组中未使用的字节数量；\r\n+ `buf[]`：字节**数组**，用于保存字符串。\r\n\r\n由于SDS遵循了C语言字符串以`\\0`结尾的惯例，那么buf数组的实际长度就是` len + free + 1`个字节，加一是因为`\\0`占一个字节。更直观的看，一个存放了字符串`Redis`的SDS结构如下\r\n\r\n![SDS结构](/images/article/redis-sds.png)\r\n\r\n#### 1.2 SDS与C字符串的区别\r\n\r\n1. **常数复杂度获取字符串长度**：由于SDS结构内维护了一个`len`属性，因此可以直接获取字符串长度；但是C字符串则要从头到尾遍历才可以获得字符串长度；获取字符串长度的时间复杂度从O(N)降低到了0(1);\r\n2. **杜绝缓冲区溢出**：C字符串不记录自身长度，在执行字符串拼接操作时它假定用户已经分配好了足够的空间，但是当这个假设不成立时，拼接字符串后形成的新字符串就会溢出到当前字符串之外的空间；而SDS对字符串进行修改（拼接是修改的一种）时，则会检查`free`属性的值是否能够容纳要拼接的字符串，如果能够容纳则直接拼接，如果不够则先扩容再拼接；\r\n3. **减少修改字符串时带来的内存重分配次数**：在拼接操作时，如果`free`属性指示的剩余字节空间不够，那么要先进行内存重分配操作然后再执行拼接操作；在缩短字符串时，也要通过内存重分配来释放不用的那一部分空间；对应这两种情况，分别有**两种内存重分配策略**：\r\n    1. 空间预分配：针对字符串增长操作时剩余空间可能不够的情况，SDS采用空间预分配策略来保证：当SDS的API对一个SDS进行修改并且需要对SDS空间进行拓展的时候，程序不仅会为SDS分配修改所必需的空间，还会为SDS分配额外的未使用空间，交由`free`属性指示，具体的额外分配的未使用空间由以下公式决定：\r\n        + 如果对SDS进行修改后，SDS的长度（即`len`属性）小于1MB，那么程序分配与`len`属性同样大小的未使用空间。也就是说如果当前`len`属性为13byte，那么空间预分配后SDS的buf数组的实际长度就是`13byte + 13byte + 1byte`（额外的一个字节用于保存空字符）；\r\n        + 如果对SDS进行修改后，SDS的长度大于等于1MB，那么程序会分配1MB的未使用空间。也就是说如果当前`len`属性值为30MB，那么空间预分配后SDS的buf数组的实际长度就是`30MB + 1MB + 1byte`（额外的一个字节用于保存空字符）。\r\n    2. 惰性空间释放：针对字符串的缩短操作：当SDS的一个API对其进行缩短操作时，程序不立即使用内存重分配来回收缩短后多出来的字节，而是使用`free`属性将这些字节记录起来，以备未来使用。\r\n4. **二进制安全**：C字符串中的字符必须符合某种编码（比如ASCII码），并且除了字符串的末尾之外，字符串里面不能包含空字符（即`\\0`），但是SDS的buf属性保存的实际上是二进制数据，所以可以保存任意格式的数据，因为SDS是用`len`属性的值而不是`\\0`来判断字符串结尾的，之所以保留字符串末尾的`\\0`是因为这样做可以兼容一部分C语言字符串函数；\r\n5. **兼容部分C字符串函数**：SDS遵循C字符串以空字符结尾的惯例，可以重用部分C字符串函数。\r\n\r\n## 二、链表\r\n\r\n链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活地调整链表的长度。\r\n\r\n在Redis中，当一个列表键包含了数量比较多的元素或者列表中包含的元素都是比较长的字符串时，Redis就会使用链表作为列表键的底层实现。\r\n\r\n#### 2.1 链表与链表节点的实现\r\n\r\n每个链表由一个节点构成，使用`adlist.h/listNode`结构来表示：\r\n\r\n```\r\ntypedef struct listNode {\r\n    struct listNode *prev;\r\n    struct listNode *next;\r\n    void *value;\r\n} listNode;\r\n```\r\n\r\n各属性解释如下：\r\n\r\n+ `*prev`：指针，指向链表中当前节点的上一个节点；\r\n+ `*next`：指针，指向链表中当前节点的下一个节点；\r\n+ `*value`：节点的实际数据。\r\n\r\n多个节点可以连接成一个链表，可以交由list结构来维护，使用`adlist.h/list`结构来表示，如下\r\n\r\n```\r\ntypedef struct list {\r\n    listNode *head;\r\n    listNode *tail;\r\n    unsigned long len;\r\n    void *(*dup) (void *ptr);\r\n    void (*free) (void *ptr);\r\n    int (*match) (void *ptr, void *key);\r\n} list;\r\n```\r\n\r\n各属性解释如下：\r\n\r\n+ `*head`：链表的头结点；\r\n+ `*tail`：链表的尾结点；\r\n+ `len`：链表的节点数目；\r\n+ `*dup`：该函数对链表进行操作，用于复制链表节点所保存的值；\r\n+ `*free`：该函数对链表进行操作，用于释放链表节点所保存的值；\r\n+ `*match`：该函数对链表进行操作，用于对比链表节点所保存的值和另一个输入值是否相等。\r\n\r\n#### 2.2 Redis链表的特性\r\n\r\n+ 双端：链表节点带有prev和next指针；\r\n+ 无环：表头节点的prev指针和表尾节点的next指针都指向NULL，对链表的访问以NULL为终点；\r\n+ 带表头指针和表尾指针：获取链表头部节点与尾部节点的时间复杂度都是O(1)；\r\n+ 带链表长度计数器，获取链表长度的时间复杂度为O(1)；\r\n+ 多态：链表节点使用`void*`指针来保存节点值，并且可以通过list结构的`dup``free``match`三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。\r\n\r\n## 三、字典\r\n\r\nRedis数据库采用字典作为底层实现，对数据库的增删查改均是建立在对字典的操作之上。\r\n\r\n除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。\r\n\r\nRedis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。\r\n\r\n#### 3.1 哈希表节点与哈希表的实现\r\n\r\n哈希表的节点使用`dictEntry`结构表示，每个`dictEntry`结构都保存着一个键值对：\r\n\r\n```\r\ntypedef struct dictEntry {\r\n    // 键\r\n    void *key;\r\n    // 值\r\n    union {\r\n        void *val;\r\n        unit64_tu64;\r\n        int64_ts64;\r\n    } v;\r\n    // 指向下个哈希表节点，形成链表，是处理哈希表节点冲突的一种方式\r\n    struct dictEntry *next;\r\n} dictEntry;\r\n```\r\n\r\n而哈希表则是由`dict.h/dictht`结构定义：\r\n\r\n```\r\ntypedef struct dictht {\r\n    // 哈希表数组\r\n    dictEntry **table;\r\n    // 哈希表大小\r\n    unsigned long size;\r\n    // 哈希表大小掩码，用于计算索引值\r\n    // 总是等于 size - 1\r\n    // 相当于Java哈希表中的除留取余法计算哈希地址时的除数\r\n    unsigned long sizemask;\r\n    // 该哈希表已有节点的数量\r\n    unsigned long used;\r\n} dictht;\r\n```\r\n\r\n总之，Redis中哈希表的实现与Java中哈希表的实现并无差别，只是实现语言不同而已。\r\n\r\n#### 3.2 字典的实现\r\n\r\n哈希表作为字典的底层实现，其实质上就是将哈希表通过数组组织在一起，其由`dict.h/dict`结构表示：\r\n\r\n```\r\ntypedef struct dict {\r\n    // 类型特定函数\r\n    // 是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，\r\n    // Redis会为用途不同的字典设置不同的类型特定函数\r\n    dictType *type;\r\n    // 私有数据\r\n    // 保存了需要传给那些类型特定函数的可选参数\r\n    void *privdata;\r\n    // 包含两个项的数组，每个项都是一个dictht哈希表\r\n    // 一般情况下，只用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用；\r\n    dictht ht[2];\r\n    // 记录了rehash目前的进度，如果目前没有在进行rehash，那么值为-1\r\n    int trehashidx;\r\n} dict;\r\n```\r\n\r\n#### 3.3 哈希算法、键冲突与rehash\r\n\r\n当字典被用作数据库的底层实现或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。\r\n\r\nRedis的哈希表采用链地址法来解决键冲突。\r\n\r\n随着操作的不断进行，哈希表保存的键值对会逐渐地增多或减少，为了让哈希表的负载因子(load factor)维持在一个合理的范围，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。扩展和收缩的工作可以通过rehash(重新散列)操作来完成。\r\n\r\n\r\n## 四、跳跃表\r\n\r\n跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。\r\n\r\n跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来处理节点。在大部分情况下，跳跃表的效率可以和平衡树媲美，并且因为跳跃表的实现比平衡树更为简单，所以有不少程序都使用跳跃表来代替平衡树。\r\n\r\nRedis使用跳跃表作为有序集合的底层实现之一，如果一个有序集合包含的元素比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合的底层实现。\r\n\r\n#### 4.1 跳跃表节点与跳跃表的实现\r\n\r\n跳跃表的节点实现由`redis.h/zskiplistNode`结构来定义：\r\n\r\n```\r\ntypedef struct zskiplistNode {\r\n    struct zskiplistLevel {\r\n        struct zskiplistNode *forward;\r\n        unsigned int span;\r\n    } level[];\r\n    struct zskiplistNode *backward;\r\n    double score;\r\n    robj *obj;\r\n} zskiplistNode;\r\n```","cover":"/images/redis.jpg","link":"design-and-implementation-of-redis.html","preview":"\u003cp\u003e数据结构与对象、单机数据库的实现。\u003c/p\u003e\n","title":"Redis设计与实现"},{"content":"\r\n\r\n首先编辑以下文件\r\n\r\n```\r\n[root@izuf622r98ikh3c0432hejz ~]# vi /etc/my.cnf\r\n```\r\n\r\n在打开的文件中的`[mysqld]`中末尾另起一行，并追加\r\n\r\n```\r\nskip-grant-tables\r\n```\r\n\r\n然后`:wq!`保存！\r\n\r\n接下来重启MySQL服务\r\n\r\n```\r\nservice mysqld restart\r\n```\r\n\r\n然后进入MySQL控制台，直接回车\r\n\r\n```\r\nmysql -uroot -p\r\n```\r\n\r\n执行以下命令\r\n\r\n```\r\nmysql\u003e update mysql.user set authentication_string=password('your password') where User=\"root\" and Host=\"localhost\";\r\n```\r\n\r\n然后刷新系统授权表\r\n\r\n```\r\nmysql\u003e flush privileges;\r\n```\r\n\r\n再执行如下命令并退出MySQL控制台\r\n\r\n```\r\nmysql\u003e grant all on *.* to 'root'@'localhost' identified by 'your password' with grant option;\r\nmysql\u003e exit;\r\n```\r\n\r\n再次修改如下文件，删除之前添加的内容\r\n\r\n```\r\n[root@izuf622r98ikh3c0432hejz ~]# vi /etc/my.cnf\r\n```\r\n\r\n然后保存再次重启MySQL服务\r\n\r\n```\r\nservice mysqld restart\r\n```","cover":"/images/mysql-logo.png","link":"mysql-forget-root-password-solution.html","preview":"\u003cp\u003eLinux下MySQL root用户找回密码。\u003c/p\u003e\n","title":"MySQL忘记root密码解决办法"},{"content":"\r\n\r\n## 一、控制器请求地址映射类\r\n\r\nSpring MVC中通过`@Controller`注解来说明当前类是一个控制器类，在此基础之上通过`@RequestMapping`注解来说明请求路径。\r\n\r\nSpring MVC`@RequestMapping(org.springframework.web.bind.annotation.RequestMapping`注释类实现控制器方法请求地址、请求方式、请求数据类型和响应数据类型等信息的映射，是控制器编程最常见的注释类，语法为\r\n\r\n```\r\n@RequestMapping(属性 = '值', 属性 = '值', ...)\r\n```\r\n\r\n该注释类的常用属性名称、取值和功能如下所述：\r\n\r\n+ `value = String[]`：指明控制器方法请求地址，类型是`String[]`，因此可以指定多个地址(`@RequestMapping(value = {\"/tomain\", \"/tohome\"})`),如果只映射一个地址时可以不用`{}`符号，如果没有其它属性，那么可以忽略属性名直接写路径(`@RequestMapping(\"tomain\")`)；\r\n+ `path = String[]`：与`value`含义相同，语法相同，用于确定控制器方法的请求地址；\r\n+ `method = RequestMethod[]`：用于确定请求方式，可以指定多个方式(`@RequestMapping(value = \"/add\", method = {RequestMethod.POST, RequestMethod.GET)`,也可以是一个地址(`@RequestMapping(value = \"/hello\", method = RequestMethod.GET)`);\r\n+ `params = String[]`：用于指定URI中附带的参数名，示例为`@RequestMapping(value = \"/add\", method = RequestMethod.GET, params = {\"id\", \"name\", \"pswd\"})`;\r\n+ `consumes = String[]`：用于确定请求的数据类型，可以是一种(`@RequestMapping(value = \"/add\", method = RequestMethod.GET, consumes = \"text/plain\")`或者(`@RequestMapping(value = \"/add\", method = RequestMethod.GET, consumes = \"application/json\")`))，也可以是多种(`@RequestMapping(value = \"/add\", method = RequestMethod.GET, consumes = {\"text/plain\", \"application/*\"})`);\r\n+ `produces = String[]`：用于确定返回的数据类型，可以是一种(`@RequestMapping(value = \"/add\", method = RequestMethod.GET, produces = \"text/plain\")`或者(`@RequestMapping(value = \"/add\", method = RequestMethod.GET, consumes = \"application/json; charset = UTF-8\")`))也可以是多种(`@RequestMapping(value = \"/add\", method = RequestMethod.GET, produces = {\"text/plain\", \"application/*\"})`);\r\n+ `header = String[]`：用于指定请求头信息，当请求满足时才受理，例如`@RequestMapping(value = \"/add\", method = RequestMethod.GET, header = \"content-type=text/*\")`。\r\n\r\n## 二、控制器方法的常用参数\r\n\r\n+ 使用`@RequestParam`注释的请求参数：以细粒度方式提取请求路径中的查询字符串，语法格式为`@RequestParam(属性 = \"值\", 属性 = \"值\")`,可取的属性如下\r\n  1. `name = \"参数名\"‘：指定参数的名称，如果省略，则参数变量名就是参数名；\r\n  2. `required = true | false`：指定参数是否是必需的，如果为`true`，则请求中必须有此参数，否则方法会抛出异常，默认为`true`；\r\n  3. `defauValue = \"值\"`：如果参数不是必需的，当没有此参数时，控制方法中定义接收参数的值就是此属性设置的值，一般与`required = false`搭配使用；\r\n  4. `value = \"参数名\"`：该属性时`name`属性的别名，与`name`属性一样用于指定参数名，不是用来指定参数的值。\r\n+ `@PathVariable`注释的参数：用于提取REST API风格的URL地址中的参数，使用方式为先`@RequestMapping(value = \"department/add/code/{code}/name/{name}\")`然后在方法参数中`@PathVariable(value = \"code\") String code, @PathVariable(value = \"name\") String name)`;\r\n+ `@RequestHeader`注释的参数：用于提取请求头的值，使用方式为在控制器方法参数中`@RequestHeader(\"Accept-Encoding\") String encoding, @RequestHeader(\"Keep-Alive\") long keepLive`；\r\n+ `@RequestBody`注释的参数：用于接收前段Post的JSON数据，直接装配到Model实体中，用法为`@RequestBody Model m`;\r\n+ `@RequestPart`注释的参数：用于取得请求中包含的文件，用于文件上传编程；\r\n+ `CookieValue`注释的参数：用于提取Cookie值，用法为`@CookieValue(value = \"userid\", required = true) String userid`；\r\n+ `javax.servlet.ServletRequest`：用于使用原始的JavaEE的请求对象；\r\n+ `javax.servlet.http.HttpServletRequest`：用于使用HTTP请求的请求对象，可以实现一些Spring MVC无法完成的任务，例如获取客户端的IP地址；\r\n+ `javax.servlet.ServletResponse`：用于取得原始的Java Web响应对象，使用比较少；\r\n+ `javax.servlet.http.HttpServletResponse`：可实现专门的响应处理编程。由于Spring MVC控制器可以生成所有类型的相应处理，所以此类型参数使用较少；\r\n+ `javax.servlet.http.HttpSession`：可用于保存会话信息，如用户的登录信息等；\r\n+ 其他...\r\n\r\n## 三、控制器方法的常用返回类型\r\n\r\n+ String：返回字符串对象，通常表示View的逻辑名称，例如`return \"department/add\";`，地址的后缀会通过Spring MVC的配置文件补充；\r\n+ 业务Model类：与`@ResponseBody`注解配合，直接`return model`即可；\r\n+ Void：无返回类型；\r\n\r\n特别注意`@ResponseBody`注解，当在此基础上返回类型是String，那么就是返回一段字符串，当是Model时，返回的就是JSON数据，也可以是List容器，那么就是JSON数组。","cover":"/images/springmvc.jpg","link":"details-of-spring-mvc-controller-using.html","preview":"\u003cp\u003eSpring MVC控制器使用详情，包括控制器请求地址映射类、控制器方法参数、控制器方法返回类型。\u003c/p\u003e\n","title":"Spring MVC控制器使用详情"},{"content":"\r\n\r\n注意，一定要将`library`引用的jar包放到`web-inf/lib`下，前者都很熟悉，后者放置的办法是`右键项目 -\u003e Properties -\u003e Deployment Assembly -\u003e Add -\u003e Java Build Path Entries -\u003e 全选 -\u003e Finish -\u003e Apply -\u003eApply and Close`，否则会报错`java.lang.ClassNotFoundException: org.springframework.web. servlet.DispatcherServlet`。\r\n\r\n接下来，首先定义`web-inf/web.xml`文件，分别是定义`servlet-name`及对应的`servlet-class`，以及该`servlet-name`定义的的映射了`url`与`controller`对应关系的Spring MVC配置文件。然后通过`servlet-name`与`url-pattern`来指明所有的请求路径均由`servlet-name`指明的servlet来处理，是怎么处理的呢？就是请求先到`web.xml`文件，然后文件指明了请求由Spring MVC的配置文件来处理，于是`DispatcherServlet`读取Spring MVC的配置文件，并扫描`Controller`包，根据`RequestMapping`配置的路径来分派处理该请求的Controller。配置示例如下\r\n\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cweb-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" id=\"WebApp_ID\" version=\"3.0\"\u003e\r\n  \u003cdisplay-name\u003eSpringMVC\u003c/display-name\u003e\r\n  \u003cwelcome-file-list\u003e\r\n    \u003cwelcome-file\u003eindex.html\u003c/welcome-file\u003e\r\n    \u003cwelcome-file\u003eindex.htm\u003c/welcome-file\u003e\r\n    \u003cwelcome-file\u003eindex.jsp\u003c/welcome-file\u003e\r\n    \u003cwelcome-file\u003edefault.html\u003c/welcome-file\u003e\r\n    \u003cwelcome-file\u003edefault.htm\u003c/welcome-file\u003e\r\n    \u003cwelcome-file\u003edefault.jsp\u003c/welcome-file\u003e\r\n  \u003c/welcome-file-list\u003e\r\n  \r\n  \u003c!-- 从这里开始 --\u003e\r\n  \u003cservlet\u003e\r\n    \u003cservlet-name\u003eDispatcherServlet\u003c/servlet-name\u003e\r\n    \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e\r\n    \u003cinit-param\u003e\r\n      \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e\r\n      \u003cparam-value\u003eclasspath:springmvc.xml\u003c/param-value\u003e\r\n    \u003c/init-param\u003e\r\n    \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e\r\n  \u003c/servlet\u003e\r\n  \u003cservlet-mapping\u003e\r\n    \u003cservlet-name\u003eDispatcherServlet\u003c/servlet-name\u003e\r\n    \u003curl-pattern\u003e/\u003c/url-pattern\u003e\r\n  \u003c/servlet-mapping\u003e\r\n\u003c/web-app\u003e\r\n```\r\n\r\n接下来必然是配置Spring MVC的配置文件，该文件位于根目录下，即`src/springmvc.xml`,该文件主要是开启Spring MVC注解的配置以及扫描路径，主要是\r\n\r\n```\r\n\u003c!-- 不同于Spring的\u003ccontext:annotationconfig/\u003e标签，功能可以理解为是一样的 --\u003e\r\n\u003cbean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"/\u003e\r\n\u003ccontext:component-scan base-package=\"tech.feily.springmvc.controller\"/\u003e\r\n```\r\n\r\n上述配置开启了Spring MVC的注解，这样`DispatcherServlet`就知道根据配置的扫描路径的包找到url对应的controller。然后还有配置视图解析的相关内容，如下\r\n\r\n```\r\n\u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e\r\n  \u003cproperty name=\"prefix\" value=\"/admin\"/\u003e\r\n  \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e\r\n\u003c/bean\u003e\r\n```\r\n\r\n至此，简单完整的springmvc配置文件整体如下\r\n\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:tx=\"http://www.springframework.org/schema/tx\"\r\n    xsi:schemaLocation=\"\r\n        http://www.springframework.org/schema/tx\r\n        http://www.springframework.org/schema/tx/spring-tx-4.0.xsd\r\n        http://www.springframework.org/schema/beans\r\n        http://www.springframework.org/schema/beans/spring-beans-4.0.xsd\r\n        http://www.springframework.org/schema/mvc\r\n        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd     \r\n        http://www.springframework.org/schema/context\r\n        http://www.springframework.org/schema/context/spring-context-4.0.xsd\"\u003e\r\n    \u003cbean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"/\u003e\r\n    \u003ccontext:component-scan base-package=\"tech.feily.springmvc.controller\"/\u003e\r\n    \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u003e\r\n        \u003cproperty name=\"prefix\" value=\"/admin\"/\u003e\r\n        \u003cproperty name=\"suffix\" value=\".jsp\"/\u003e\r\n    \u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n\r\n接下来便是定义控制器了，如下\r\n\r\n```\r\npackage tech.feily.springmvc.controller;\r\n\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RequestMethod;\r\nimport org.springframework.web.bind.annotation.ResponseBody;\r\n\r\n@Controller\r\npublic class ControllerClass {\r\n\r\n\t@RequestMapping(value = \"/hello\", method = RequestMethod.GET)\r\n\tpublic @ResponseBody String hello() {\r\n\t\treturn \"hello, world\";\r\n\t}\r\n}\r\n```\r\n\r\n然后运行，测试结果，如下\r\n\r\n```\r\nC:\\Users\\Administrator\r\nλ curl localhost:8080/SpringMVC/hello\r\nhello, world\r\n```\r\n\r\n搞定！","cover":"/images/springmvc.jpg","link":"guidelines-for-the-use-of-spring-mvc-controllers.html","preview":"\u003cp\u003eSpring MVC控制器使用全流程简单示例。\u003c/p\u003e\n","title":"Spring MVC控制器使用指南"},{"content":"\r\n\r\n被织入的类为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\npublic class SayHello {\r\n\r\n\tpublic void sayHello() {\r\n\t\tSystem.out.println(\"Hello, world!\");\r\n\t}\r\n}\r\n```\r\n\r\n前置、方法返回前、环绕实现类分别为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.Date;\r\n\r\nimport org.springframework.aop.MethodBeforeAdvice;\r\n\r\npublic class BeforeAdvice implements MethodBeforeAdvice {\r\n\r\n\t@Override\r\n\tpublic void before(Method arg0, Object[] arg1, Object arg2) throws Throwable {\r\n\t\tSystem.out.println(\"Hello, current time isb \" + new Date());\r\n\t}\r\n\r\n}\r\n\r\n\r\npackage spring.feily.tech;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.Date;\r\n\r\npublic class AfterReturningAdvice implements org.springframework.aop.AfterReturningAdvice {\r\n\r\n\t@Override\r\n\tpublic void afterReturning(Object arg0, Method arg1, Object[] arg2, Object arg3) throws Throwable {\r\n\t\tSystem.out.println(\"Hello, current time is \" + new Date());\r\n\t}\r\n\r\n}\r\n\r\npackage spring.feily.tech;\r\n\r\nimport java.util.Date;\r\n\r\nimport org.aopalliance.intercept.MethodInvocation;\r\n\r\npublic class MethodInterceptor implements org.aopalliance.intercept.MethodInterceptor {\r\n\r\n\t@Override\r\n\tpublic Object invoke(MethodInvocation arg0) throws Throwable {\r\n\t\tDate startTime = new Date();\r\n\t\tObject result = arg0.proceed();\r\n\t\tDate endTime = new Date();\r\n\t\tLong runtime = endTime.getTime() - startTime.getTime();\r\n\t\tSystem.out.println(\"Method ： \" + arg0.getMethod() + \" running time is \" + runtime + \"ms.\");\r\n\t\treturn result;\r\n\t}\r\n\r\n}\r\n```\r\n\r\nxml配置文件为\r\n\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\" \r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"             \r\n    xsi:schemaLocation=\"                                               \r\n            http://www.springframework.org/schema/beans \r\n            http://www.springframework.org/schema/beans/spring-beans.xsd    \r\n            http://www.springframework.org/schema/context     \r\n            http://www.springframework.org/schema/context/spring-context.xsd    \r\n            http://www.springframework.org/schema/mvc    \r\n            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \r\n            http://www.springframework.org/schema/tx   \r\n            http://www.springframework.org/schema/tx/spring-tx.xsd  \r\n            http://www.springframework.org/schema/aop  \r\n            http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e\r\n            \r\n  \u003cbean id=\"sayHello\" class=\"spring.feily.tech.SayHello\"/\u003e\r\n  \r\n  \u003cbean id=\"beforeAdvice\" class=\"spring.feily.tech.BeforeAdvice\"/\u003e\r\n  \u003cbean id=\"afterReturnningAdvice\" class=\"spring.feily.tech.AfterReturningAdvice\"/\u003e\r\n  \u003cbean id=\"methodInterceptor\" class=\"spring.feily.tech.MethodInterceptor\"/\u003e\r\n  \r\n  \u003caop:config\u003e\r\n    \u003caop:pointcut id=\"pointCut\" expression=\"execution(* spring.feily.tech.SayHello.*(..))\" /\u003e\r\n    \u003caop:advisor advice-ref=\"beforeAdvice\" pointcut-ref=\"pointCut\"/\u003e\r\n    \u003caop:advisor advice-ref=\"afterReturnningAdvice\" pointcut-ref=\"pointCut\"/\u003e\r\n    \u003caop:advisor advice-ref=\"methodInterceptor\" pointcut-ref=\"pointCut\"/\u003e\r\n  \u003c/aop:config\u003e\r\n\u003c/beans\u003e\r\n```\r\n\r\n测试主文件为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class AOPMain {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tApplicationContext ac = new ClassPathXmlApplicationContext(\"context.xml\");\r\n\t\tSayHello sayHello = ac.getBean(\"sayHello\", SayHello.class);\r\n\t\tsayHello.sayHello();\r\n\r\n\t}\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n七月 13, 2019 6:58:25 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh\r\n信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@3d71d552: startup date [Sat Jul 13 18:58:25 CST 2019]; root of context hierarchy\r\n七月 13, 2019 6:58:25 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\r\n信息: Loading XML bean definitions from class path resource [context.xml]\r\nHello, current time isb Sat Jul 13 18:58:26 CST 2019\r\nHello, world!\r\nMethod ： public void spring.feily.tech.SayHello.sayHello() running time is 13ms.\r\nHello, current time is Sat Jul 13 18:58:26 CST 2019\r\n```","cover":"/images/Spring-Framework.jpg","link":"xml-implementation-of-spring-aop.html","preview":"\u003cp\u003eSpring AOP的XML实现方式代码示例。\u003c/p\u003e\n","title":"Spring AOP的XML实现方式"},{"content":"\r\n\r\n## 一、属性方式DI的实现\r\n\r\n#### 1.1 xml方式实现DI注入\r\n\r\nSpring在XML配置形式中，使用嵌入到`\u003cbean\u003e`的子标记`\u003cproperty\u003e`实现属性set方式的注入，其配置语法如下\r\n\r\n```\r\n\u003cbean id=\"id\" class=\"Bean全称\"\u003e\r\n  \u003cproperty name=\"Bean需要注入的属性名\" 属性名=\"注入的值或者对象\" /\u003e\r\n\u003c/bean\u003e\r\n```\r\n\r\n其中属性名的取值如下\r\n\r\n+ 取值为`value`：这种情况下name属性对应的值得类型为简单类型的值或String类型的值；\r\n+ 取值为`ref`：对象类型的注入，值为配置的Bean的id；\r\n+ 空值注入：示例为`\u003cproperty name=\"comment\"\u003e\u003cnull/\u003e\u003c/property\u003e`;\r\n+ 集合类型的注入：要注入数组或list集合，使用`\u003clist\u003e`标签，内部使用`\u003cvalue\u003e`标签对将值包含进来；要注入set集合，使用`\u003cset\u003e`标签，内部使用`\u003cvalue\u003e`标签对将值包含进来；要注入map集合，使用`\u003cmap\u003e`标签，内部为`\u003centry key=\"keyName\"\u003e\u003cvalue\u003ekeyValue\u003c/value\u003e\u003c/entry\u003e`；property集合使用\u003cproperty\u003e标签，内部为`\u003cprops\u003e\u003cprop key=\"keyName\"\u003ekeyValue\u003c/prop\u003e\u003c/props\u003e`。**值得注意的是如果注入的是对象就不能使用`\u003cvalue\u003e`标签，要使用`\u003crel bean=\"beanid\"/\u003e`标签。**\r\n\r\n相应的Bean实体中必须针对每个属性编写set方法。\r\n\r\n示例代码如下\r\n\r\n要注入的实体类为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\npublic class User {\r\n\r\n\tprivate String name;\r\n\tprivate int age;\r\n\tprivate String hobby;\r\n\tprivate List\u003cUser\u003e boyFriends;\r\n\tprivate Set\u003cUser\u003e girlFriends;\r\n\t\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\t\r\n\tpublic void setAge(int age) {\r\n\t\tthis.age = age;\r\n\t}\r\n\t\r\n\tpublic void setHobby(String hobby) {\r\n\t\tthis.hobby = hobby;\r\n\t}\r\n\t\r\n\tpublic void setBoyFriends(List\u003cUser\u003e boyFriends) {\r\n\t\tthis.boyFriends = boyFriends;\r\n\t}\r\n\t\r\n\tpublic void setGirlFriends(Set\u003cUser\u003e grilFriends) {\r\n\t\tthis.girlFriends = grilFriends;\r\n\t}\r\n\t\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\t\r\n\tpublic int getAge() {\r\n\t\treturn age;\r\n\t}\r\n\t\r\n\tpublic String getHobby() {\r\n\t\treturn hobby;\r\n\t}\r\n\t\r\n\tpublic List\u003cUser\u003e getBoyFriends() {\r\n\t\treturn boyFriends;\r\n\t}\r\n\t\r\n\tpublic Set\u003cUser\u003e getGirlFriends() {\r\n\t\treturn girlFriends;\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n注入的配置文件为\r\n\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n    http://www.springframework.org/schema/context\r\n    http://www.springframework.org/schema/context/spring-context.xsd\"\u003e\r\n  \u003cbean id=\"boy1\" class=\"spring.feily.tech.User\"\u003e\r\n    \u003cproperty name=\"name\" value=\"Boy1\"/\u003e\r\n    \u003cproperty name=\"age\" value=\"22\"/\u003e\r\n    \u003cproperty name=\"hobby\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"boyFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"girlFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n  \u003c/bean\u003e\r\n  \u003cbean id=\"boy2\" class=\"spring.feily.tech.User\"\u003e\r\n    \u003cproperty name=\"name\" value=\"Boy2\"/\u003e\r\n    \u003cproperty name=\"age\" value=\"22\"/\u003e\r\n    \u003cproperty name=\"hobby\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"boyFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"girlFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n  \u003c/bean\u003e\r\n  \u003cbean id=\"girl1\" class=\"spring.feily.tech.User\"\u003e\r\n    \u003cproperty name=\"name\" value=\"girl1\"/\u003e\r\n    \u003cproperty name=\"age\" value=\"22\"/\u003e\r\n    \u003cproperty name=\"hobby\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"boyFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"girlFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n  \u003c/bean\u003e\r\n  \u003cbean id=\"girl2\" class=\"spring.feily.tech.User\"\u003e\r\n    \u003cproperty name=\"name\" value=\"girl2\"/\u003e\r\n    \u003cproperty name=\"age\" value=\"22\"/\u003e\r\n    \u003cproperty name=\"hobby\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"boyFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"girlFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n  \u003c/bean\u003e\r\n  \u003cbean id=\"user\" class=\"spring.feily.tech.User\"\u003e\r\n    \u003cproperty name=\"name\" value=\"Feily Zhang\"/\u003e\r\n    \u003cproperty name=\"age\" value=\"21\"/\u003e\r\n    \u003cproperty name=\"hobby\" value=\"Running, coding, sing song\"/\u003e\r\n    \u003cproperty name=\"boyFriends\"\u003e\r\n      \u003clist\u003e\r\n        \u003cref bean=\"boy1\"/\u003e\r\n        \u003cref bean=\"boy2\"/\u003e\r\n      \u003c/list\u003e\r\n    \u003c/property\u003e\r\n    \u003cproperty name=\"girlFriends\"\u003e\r\n      \u003cset\u003e\r\n        \u003cref bean=\"girl1\"/\u003e\r\n        \u003cref bean=\"girl2\"/\u003e\r\n      \u003c/set\u003e\r\n    \u003c/property\u003e\r\n  \u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n\r\n测试用的主文件为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport java.util.List;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringBeanMain {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tApplicationContext ac = new ClassPathXmlApplicationContext(\"context.xml\");\r\n\t\tUser user = ac.getBean(\"user\", User.class);\r\n\t\t\r\n\t\tSystem.out.println(\"name : \" + user.getName());\r\n\t\tSystem.out.println(\"age : \" + user.getAge());\r\n\t\tSystem.out.println(\"hobby : \" + user.getHobby());\r\n\t\t\r\n\t\tSystem.out.println(\"BoyFriends : \");\r\n\t\tList\u003cUser\u003e userBoyFriends = user.getBoyFriends();\r\n\t\tfor (User u : userBoyFriends) {\r\n\t\t\tSystem.out.println(\"\\tname : \" + u.getName());\r\n\t\t\tSystem.out.println(\"\\tage : \" + u.getAge());\r\n\t\t\tSystem.out.println(\"\\thobby : \" + u.getHobby());\r\n\t\t\tSystem.out.println(\"\\tboyFriends : \" + u.getBoyFriends());\r\n\t\t\tSystem.out.println(\"\\tgirlFriends : \" + u.getGirlFriends());\r\n\t\t\tSystem.out.println(\"\\t----------\");\r\n\t\t}\r\n\t\t\r\n\t\tSystem.out.println(\"GirlFriends : \");\r\n\t\tList\u003cUser\u003e userGirlFriends = user.getBoyFriends();\r\n\t\tfor (User u : userGirlFriends) {\r\n\t\t\tSystem.out.println(\"\\tname : \" + u.getName());\r\n\t\t\tSystem.out.println(\"\\tage : \" + u.getAge());\r\n\t\t\tSystem.out.println(\"\\thobby : \" + u.getHobby());\r\n\t\t\tSystem.out.println(\"\\tboyFriends : \" + u.getBoyFriends());\r\n\t\t\tSystem.out.println(\"\\tgirlFriends : \" + u.getGirlFriends());\r\n\t\t\tSystem.out.println(\"\\t----------\");\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n输出为\r\n\r\n```\r\n七月 13, 2019 4:41:52 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh\r\n信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@b1a58a3: startup date [Sat Jul 13 16:41:52 CST 2019]; root of context hierarchy\r\n七月 13, 2019 4:41:52 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\r\n信息: Loading XML bean definitions from class path resource [context.xml]\r\nname : Feily Zhang\r\nage : 21\r\nhobby : Running, coding, sing song\r\nBoyFriends : \r\n\tname : Boy1\r\n\tage : 22\r\n\thobby : null\r\n\tboyFriends : null\r\n\tgirlFriends : null\r\n\t----------\r\n\tname : Boy2\r\n\tage : 22\r\n\thobby : null\r\n\tboyFriends : null\r\n\tgirlFriends : null\r\n\t----------\r\nGirlFriends : \r\n\tname : Boy1\r\n\tage : 22\r\n\thobby : null\r\n\tboyFriends : null\r\n\tgirlFriends : null\r\n\t----------\r\n\tname : Boy2\r\n\tage : 22\r\n\thobby : null\r\n\tboyFriends : null\r\n\tgirlFriends : null\r\n\t----------\r\n```\r\n\r\n#### 1.2 注解方式实现DI注入\r\n\r\n+ `@Autowired`注解：该注解依靠注册Bean的类型进行自动装配，如果再此基础之上需要根据注册Bean的id注入那么再配合`@Qualifier(\"beanid\")`注解实现。该注解的可选参数为`(required = true)`表示进行强制注入；\r\n+ `@Resource(name = \"beanid)`注解：根据注册bean的id进行装配。\r\n\r\n由于`@Resource`注解无法实现自动注入，必须指示其标识名，因此实际编程中使用最多的是`@Autowired`注解。\r\n\r\n注解实现装配的方式为首先在xml配置文件中声明使用`@Autowired`注解进行注入，内容为\r\n\r\n```\r\n\u003cbean class=\"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\"/\u003e\r\n```\r\n\r\n然后被注入的类接口与实现为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\npublic interface SpringBean {\r\n\r\n\tpublic abstract void sayHello();\r\n\t\r\n}\r\n\r\n\r\npackage spring.feily.tech;\r\n\r\npublic class SpringBeanImpl implements SpringBean {\r\n\r\n\t@Override\r\n\tpublic void sayHello() {\r\n\t\tSystem.out.println(\"hello, world\");\r\n\t}\r\n}\r\n```\r\n\r\n注入的类为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\npublic class ReSayHello {\r\n\r\n\tprivate SpringBean springBean = null;\r\n\t\r\n\t@Autowired(required = true)\r\n\tpublic void setSpringBean(SpringBean springBean) {\r\n\t\tthis.springBean = springBean;\r\n\t}\r\n\t\r\n\tpublic SpringBean getSpringBean() {\r\n\t\treturn springBean;\r\n\t}\r\n}\r\n```\r\n\r\n需要在xml文件中注册(或者使用注解或配置类方式注册Bean)\r\n\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n    http://www.springframework.org/schema/context\r\n    http://www.springframework.org/schema/context/spring-context.xsd\"\u003e\r\n  \u003cbean class=\"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\"/\u003e\r\n  \u003cbean id=\"springBean\" class=\"spring.feily.tech.SpringBeanImpl\"\u003e\u003c/bean\u003e\r\n  \u003cbean id=\"reSayHello\" class=\"spring.feily.tech.ReSayHello\"\u003e\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n\r\n主文件为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringBeanMain {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tApplicationContext ac = new ClassPathXmlApplicationContext(\"context.xml\");\r\n\t\tReSayHello say  =ac.getBean(\"reSayHello\", ReSayHello.class);\r\n\t\tsay.getSpringBean().sayHello();\r\n\t}\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n七月 13, 2019 5:19:30 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh\r\n信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@b1a58a3: startup date [Sat Jul 13 17:19:30 CST 2019]; root of context hierarchy\r\n七月 13, 2019 5:19:30 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\r\n信息: Loading XML bean definitions from class path resource [context.xml]\r\nhello, world\r\n```\r\n\r\n## 二、构造方法方式依赖注入的实现\r\n\r\n#### 2.1 构造方法依赖注入的XML方式配置\r\n\r\n使用如下标签来实现：\r\n\r\n```\r\n\u003cbean id=\"user\" class=\"spring.feily.tech.User\"\u003e\r\n  \u003cconstructor-arg index=\"0\" value=\"Feily Zhang\"/\u003e\r\n  \u003cconstructor-arg index=\"1\" value=\"21\"/\u003e\r\n  \u003cconstructor-arg index=\"2\" value=\"Running, coding, sing song\"/\u003e\r\n  \u003cconstructor-arg index=\"3\"\u003e\r\n    \u003clist\u003e\r\n      \u003cref bean=\"boy1\"/\u003e\r\n      \u003cref bean=\"boy2\"/\u003e\r\n    \u003c/list\u003e\r\n  \u003c/constructor-arg\u003e\r\n  \u003cconstructor-arg index=\"4\"\u003e\r\n    \u003cset\u003e\r\n      \u003cref bean=\"girl1\"/\u003e\r\n      \u003cref bean=\"girl2\"/\u003e\r\n    \u003c/set\u003e\r\n  \u003c/constructor-arg\u003e\r\n\u003c/bean\u003e\r\n```\r\n\r\n依旧可以注入对象、简单类型和String以及集合。\r\n\r\n需要注意的是，使用构造方法注入，在目标类中一定要有一个默认构造方法，否则会如下报错\r\n\r\n```\r\nNo default constructor found; nested exception is java.lang.NoSuchMethodException: spring.feily.tech.User.\u003cinit\u003e()\r\n```\r\n\r\n以下示例，基于构造方法XML方式注入与属性的XML方式注入\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport java.util.List;\r\nimport java.util.Set;\r\n\r\npublic class User {\r\n\r\n\tprivate String name;\r\n\tprivate int age;\r\n\tprivate String hobby;\r\n\tprivate List\u003cUser\u003e boyFriends;\r\n\tprivate Set\u003cUser\u003e girlFriends;\r\n\t\r\n    /*\r\n     * 以下构造方法是为了构造方法的XML注入;\r\n     */\r\n\tpublic User() {\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic User(String name, int age, String hobby, List\u003cUser\u003e boyFriends, Set\u003cUser\u003e girlFriends) {\r\n\t\tthis.name = name;\r\n\t\tthis.age = age;\r\n\t\tthis.hobby = hobby;\r\n\t\tthis.boyFriends = boyFriends;\r\n\t\tthis.girlFriends = girlFriends;\r\n\t}\r\n\t\r\n    /*\r\n     * 以下set、get方法是为了属性的xml注入或者注解注入\r\n     */\r\n\tpublic void setName(String name) {\r\n\t\tthis.name = name;\r\n\t}\r\n\t\r\n\tpublic void setAge(int age) {\r\n\t\tthis.age = age;\r\n\t}\r\n\t\r\n\tpublic void setHobby(String hobby) {\r\n\t\tthis.hobby = hobby;\r\n\t}\r\n\t\r\n\tpublic void setBoyFriends(List\u003cUser\u003e boyFriends) {\r\n\t\tthis.boyFriends = boyFriends;\r\n\t}\r\n\t\r\n\tpublic void setGirlFriends(Set\u003cUser\u003e grilFriends) {\r\n\t\tthis.girlFriends = grilFriends;\r\n\t}\r\n\t\r\n\tpublic String getName() {\r\n\t\treturn name;\r\n\t}\r\n\t\r\n\tpublic int getAge() {\r\n\t\treturn age;\r\n\t}\r\n\t\r\n\tpublic String getHobby() {\r\n\t\treturn hobby;\r\n\t}\r\n\t\r\n\tpublic List\u003cUser\u003e getBoyFriends() {\r\n\t\treturn boyFriends;\r\n\t}\r\n\t\r\n\tpublic Set\u003cUser\u003e getGirlFriends() {\r\n\t\treturn girlFriends;\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\nxml文件为\r\n\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n    http://www.springframework.org/schema/context\r\n    http://www.springframework.org/schema/context/spring-context.xsd\"\u003e\r\n  \u003c!-- 以下是属性的XML方式注入--\u003e\r\n  \u003cbean id=\"boy1\" class=\"spring.feily.tech.User\"\u003e\r\n    \u003cproperty name=\"name\" value=\"Boy1\"/\u003e\r\n    \u003cproperty name=\"age\" value=\"22\"/\u003e\r\n    \u003cproperty name=\"hobby\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"boyFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"girlFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n  \u003c/bean\u003e\r\n  \u003cbean id=\"boy2\" class=\"spring.feily.tech.User\"\u003e\r\n    \u003cproperty name=\"name\" value=\"Boy2\"/\u003e\r\n    \u003cproperty name=\"age\" value=\"22\"/\u003e\r\n    \u003cproperty name=\"hobby\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"boyFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"girlFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n  \u003c/bean\u003e\r\n  \u003cbean id=\"girl1\" class=\"spring.feily.tech.User\"\u003e\r\n    \u003cproperty name=\"name\" value=\"girl1\"/\u003e\r\n    \u003cproperty name=\"age\" value=\"22\"/\u003e\r\n    \u003cproperty name=\"hobby\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"boyFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"girlFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n  \u003c/bean\u003e\r\n  \u003cbean id=\"girl2\" class=\"spring.feily.tech.User\"\u003e\r\n    \u003cproperty name=\"name\" value=\"girl2\"/\u003e\r\n    \u003cproperty name=\"age\" value=\"22\"/\u003e\r\n    \u003cproperty name=\"hobby\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"boyFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n    \u003cproperty name=\"girlFriends\"\u003e\u003cnull/\u003e\u003c/property\u003e\r\n  \u003c/bean\u003e\r\n  \u003c!-- 以下是构造方法的XML方式注入--\u003e\r\n  \u003cbean id=\"user\" class=\"spring.feily.tech.User\"\u003e\r\n    \u003cconstructor-arg index=\"0\" value=\"Feily Zhang\"/\u003e\r\n    \u003cconstructor-arg index=\"1\" value=\"21\"/\u003e\r\n    \u003cconstructor-arg index=\"2\" value=\"Running, coding, sing song\"/\u003e\r\n    \u003cconstructor-arg index=\"3\"\u003e\r\n        \u003clist\u003e\r\n          \u003cref bean=\"boy1\"/\u003e\r\n          \u003cref bean=\"boy2\"/\u003e\r\n        \u003c/list\u003e\r\n    \u003c/constructor-arg\u003e\r\n    \u003cconstructor-arg index=\"4\"\u003e\r\n        \u003cset\u003e\r\n          \u003cref bean=\"girl1\"/\u003e\r\n          \u003cref bean=\"girl2\"/\u003e\r\n        \u003c/set\u003e\r\n    \u003c/constructor-arg\u003e\r\n  \u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n\r\n主文件不变，等同于本文第一节的主文件，即\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport java.util.List;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringBeanMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(\"context.xml\");\r\n        User user = ac.getBean(\"user\", User.class);\r\n        \r\n        System.out.println(\"name : \" + user.getName());\r\n        System.out.println(\"age : \" + user.getAge());\r\n        System.out.println(\"hobby : \" + user.getHobby());\r\n        \r\n        System.out.println(\"BoyFriends : \");\r\n        List\u003cUser\u003e userBoyFriends = user.getBoyFriends();\r\n        for (User u : userBoyFriends) {\r\n            System.out.println(\"\\tname : \" + u.getName());\r\n            System.out.println(\"\\tage : \" + u.getAge());\r\n            System.out.println(\"\\thobby : \" + u.getHobby());\r\n            System.out.println(\"\\tboyFriends : \" + u.getBoyFriends());\r\n            System.out.println(\"\\tgirlFriends : \" + u.getGirlFriends());\r\n            System.out.println(\"\\t----------\");\r\n        }\r\n        \r\n        System.out.println(\"GirlFriends : \");\r\n        List\u003cUser\u003e userGirlFriends = user.getBoyFriends();\r\n        for (User u : userGirlFriends) {\r\n            System.out.println(\"\\tname : \" + u.getName());\r\n            System.out.println(\"\\tage : \" + u.getAge());\r\n            System.out.println(\"\\thobby : \" + u.getHobby());\r\n            System.out.println(\"\\tboyFriends : \" + u.getBoyFriends());\r\n            System.out.println(\"\\tgirlFriends : \" + u.getGirlFriends());\r\n            System.out.println(\"\\t----------\");\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n七月 13, 2019 5:42:33 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh\r\n信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@b1a58a3: startup date [Sat Jul 13 17:42:33 CST 2019]; root of context hierarchy\r\n七月 13, 2019 5:42:33 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\r\n信息: Loading XML bean definitions from class path resource [context.xml]\r\nname : Feily Zhang\r\nage : 21\r\nhobby : Running, coding, sing song\r\nBoyFriends : \r\n\tname : Boy1\r\n\tage : 22\r\n\thobby : null\r\n\tboyFriends : null\r\n\tgirlFriends : null\r\n\t----------\r\n\tname : Boy2\r\n\tage : 22\r\n\thobby : null\r\n\tboyFriends : null\r\n\tgirlFriends : null\r\n\t----------\r\nGirlFriends : \r\n\tname : Boy1\r\n\tage : 22\r\n\thobby : null\r\n\tboyFriends : null\r\n\tgirlFriends : null\r\n\t----------\r\n\tname : Boy2\r\n\tage : 22\r\n\thobby : null\r\n\tboyFriends : null\r\n\tgirlFriends : null\r\n\t----------\r\n```\r\n\r\n#### 2.2 构造方法的依赖注入的注解实现\r\n\r\n直接使用注解`@Autowired`修饰目标类即可，这种方式可以不用定义默认构造方法，如下\r\n\r\n目标类为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\npublic class ReSayHello {\r\n\r\n\tprivate SpringBean springBean = null;\r\n\r\n\t@Autowired\r\n    public ReSayHello(SpringBean springBean) {\r\n    \tthis.springBean = springBean;\r\n    }\r\n\t\r\n\tpublic SpringBean getSpringBean() {\r\n\t\treturn springBean;\r\n\t}\r\n}\r\n```\r\n\r\n注入的类为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\npublic interface SpringBean {\r\n\r\n\tpublic abstract void sayHello();\r\n\t\r\n}\r\n\r\npackage spring.feily.tech;\r\n\r\npublic class SpringBeanImpl implements SpringBean {\r\n\r\n\t@Override\r\n\tpublic void sayHello() {\r\n\t\tSystem.out.println(\"hello, world\");\r\n\t}\r\n}\r\n```\r\n\r\nxml文件为\r\n\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n    http://www.springframework.org/schema/context\r\n    http://www.springframework.org/schema/context/spring-context.xsd\"\u003e\r\n  \u003cbean class=\"org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor\"/\u003e\r\n  \u003cbean id=\"springBean\" class=\"spring.feily.tech.SpringBeanImpl\"\u003e\u003c/bean\u003e\r\n  \u003cbean id=\"reSayHello\" class=\"spring.feily.tech.ReSayHello\"\u003e\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n\r\n主文件为\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringBeanMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext ac = new ClassPathXmlApplicationContext(\"context.xml\");\r\n        ReSayHello say  =ac.getBean(\"reSayHello\", ReSayHello.class);\r\n        say.getSpringBean().sayHello();\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n七月 13, 2019 5:55:04 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh\r\n信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@b1a58a3: startup date [Sat Jul 13 17:55:04 CST 2019]; root of context hierarchy\r\n七月 13, 2019 5:55:04 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\r\n信息: Loading XML bean definitions from class path resource [context.xml]\r\nhello, world\r\n```","cover":"/images/Spring-Framework.jpg","link":"implementation-of-spring- dependency-injection.html","preview":"\u003cp\u003e依赖注入简单说就是为类的属性赋值。\u003c/p\u003e\n","title":"Spring依赖注入的实现方式"},{"content":"\r\n\r\n## 一、Spring IoC容器概述\r\n\r\nSpring通过IoC(控制反转)来管理对象间的依赖关系。Spring的IoC容器是一个轻量级容器，没有侵入性，不需要依赖容器的API，也不需要实现一些特殊的接口。\r\n\r\nSpring IoC容器是Spring框架的核心，容器将创建配置的所有对象，将他们通过注入的方式连接在一起，最后销毁所创建的对象，Spring对象管理对象的整个生命周期。在Spring容器中使用依赖注入(DI)来管理组成应用程序的类对象。这些对象被称为Spring Beans。\r\n\r\nSpring提供了实现`BeanFactory`和`ApplicationContext`两种不同接口类型的IoC容器。\r\n\r\n## 二、BeanFactory容器\r\n\r\n该容器是简化的IoC容器，提供了最简单的对象管理和依赖注入的基本支持，但是无法支持Spring的许多插件，例如AOP功能、Web应用等。\r\n\r\n该容器方法签名如下：\r\n\r\n+ `\u003cT\u003e T getBean(String name, Class\u003cT\u003e requiredType) throws BeansException`：根据配置的name和id以及Bean类型取得配置的Bean对象，由于使用的类型参数直接取得的类对象，所以不需要强制转型；\r\n+ `Object getBean(String name) throws BeansException`：此方法是根据name或id获取Bean对象，由于没有指定类型，所以需要进行强制类型转换；\r\n+ `\u003cT\u003e T getBean(Class\u003cT\u003e requiredType) throws BeansException`：该方法只接受一个bean4de类型参数，会取得满足此类型的第一个bean对象。通常情况下，每个Bean类型只注册一个Bean对象，所以可以通过此种方式来取得Bean对象。\r\n\r\n该容器接口的实现类为`XmlBeanFactory`，其构造方法语法为`XmlBeanFactory(Resource resource)`。\r\n\r\n该构造方法接收一个`Resource`类型的对象，该对象表示一个资源文件，Resource接口的实现类如下：\r\n\r\n+ `org.springframework.core.io.ClassPathResource`：该实现类用于读取类路径下的资源文件的资源实现类；\r\n+ `org.springframework.core.io.FileSystemResource`：该实现类用于读取操作系统物理路径下的XML配置文件。\r\n\r\n示例代码如下：\r\n\r\n先是Bean接口\r\n```\r\npackage spring.feily.tech;\r\n\r\npublic interface SpringBean {\r\n\r\n\tpublic abstract void sayHello();\r\n\t\r\n}\r\n```\r\n\r\n再是Bean实现\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.stereotype.Component;\r\n\r\npublic class SpringBeanImpl implements SpringBean {\r\n\r\n\t@Override\r\n\tpublic void sayHello() {\r\n\t\tSystem.out.println(\"hello, world\");\r\n\t}\r\n}\r\n```\r\n\r\n配置文件如下\r\n\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n    http://www.springframework.org/schema/context\r\n    http://www.springframework.org/schema/context/spring-context.xsd\"\u003e\r\n  \u003cbean id=\"springBean\" class=\"spring.feily.tech.SpringBeanImpl\"\u003e\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n\r\n主文件如下，测试BeanFactory取得对象的三种方法\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.beans.factory.BeanFactory;\r\nimport org.springframework.beans.factory.xml.XmlBeanFactory;\r\nimport org.springframework.core.io.ClassPathResource;\r\n\r\npublic class SpringBeanMain {\r\n\r\n\t@SuppressWarnings(\"deprecation\")\r\n\tpublic static void main(String[] args) {\r\n\t\tBeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(\"context.xml\"));\r\n\t\tSpringBean sb = (SpringBean) beanFactory.getBean(\"springBean\");\r\n\t\tsb.sayHello();\r\n\t\tSpringBean sb1 = beanFactory.getBean(SpringBeanImpl.class);\r\n\t\tsb1.sayHello();\r\n\t\tSpringBean sb2 = beanFactory.getBean(\"springBean\", SpringBeanImpl.class);\r\n\t\tsb2.sayHello();\r\n\t}\r\n\r\n}\r\n```\r\n\r\n运行结果为\r\n\r\n```\r\n七月 13, 2019 3:15:48 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\r\n信息: Loading XML bean definitions from class path resource [context.xml]\r\nhello, world\r\nhello, world\r\nhello, world\r\n```\r\n\r\n## 三、ApplicationContext容器\r\n\r\n`ApplicationContext`接口除了继承了`BeanFactory`接口，还继承了`ApplicationEventPublisher`、`EnvironmentCapable`、`HierarchicalBeanFactory`、`ListableBeanFactory`、`MessageSource`、`ResourceLoader`、`ResourcePatternResolver`等与Spring容器相关的环境和事件接口，实现了更高级的适合于企业级应用的Spring IoC容器。\r\n\r\n`ApplicationContext`具备所有`BeanFactory`的方法，还包含其他父接口的方法。\r\n\r\n`ApplicationContext`的常用实现类如下：\r\n\r\n实现类名称 | 使用场合\r\n:-: | :-:\r\n`ClassPathXmlApplicationContext` | 通用\r\n`FileSystemXmlApplicationContext` | 通用\r\n`AnnotationConfigApplicationContext` | 通用\r\n\r\n这里演示`ClassPathXmlApplicationContext`和`AnnotationConfigApplicationContext`实现类的使用方法，如下\r\n\r\n`ClassPathXmlApplicationContext`基于上述代码，只修改主文件，如下\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringBeanMain {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"context.xml\");\r\n\t\tSpringBean sb = applicationContext.getBean(\"springBean\", SpringBeanImpl.class);\r\n\t\tsb.sayHello();\r\n\t}\r\n\r\n}\r\n```\r\n\r\n`AnnotationConfigApplicationContext`实现类的代码如下\r\n\r\n首先修改`SpringBean`的实现类`SpringBeanImpl`为注解配置方式\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"springBean\")\r\npublic class SpringBeanImpl implements SpringBean {\r\n\r\n\t@Override\r\n\tpublic void sayHello() {\r\n\t\tSystem.out.println(\"hello, world\");\r\n\t}\r\n}\r\n```\r\n\r\n此处不需要xml文件，采用配置类方式，配置类为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.context.annotation.ComponentScan;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\n@ComponentScan(basePackages = \"spring.feily.tech\")\r\npublic class SpringConfigurator {\r\n\r\n}\r\n```\r\n\r\n主文件为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\r\n\r\npublic class SpringBeanMain {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tApplicationContext applicationContext = new AnnotationConfigApplicationContext(tech.feily.spring.SpringConfigurator.class);\r\n\t\tSpringBean sb = applicationContext.getBean(\"springBean\", SpringBeanImpl.class);\r\n\t\tsb.sayHello();\r\n\t}\r\n\r\n}\r\n```\r\n\r\n## 四、BeanFactory与ApplicationContext对比\r\n\r\n+ BeanFactory为轻量级IoC容器，但是无法支持Spring的许多插件，ApplicationContext则相反；\r\n+ ApplicationContext容器是一个勤奋型的容器，当创建ApplicationContext类型的IoC容器后，该容器就会自动创建所有注册的Bean的实例对象，而BeanFactory容器则是一个懒惰型的IoC容器，它在创建BeanFactory的IoC容器后，不会立即创建注册的Bean对象，而是调用getBean方法后才会创建请求的Bean的实例对象。","cover":"/images/Spring-Framework.jpg","link":"interface-and-implementation-class-of-spring-ioc-container.html","preview":"\u003cp\u003eSpring通过IoC(控制反转)来管理对象间的依赖关系。Spring的IoC容器是一个轻量级容器，没有侵入性，不需要依赖容器的API，也不需要实现一些特殊的接口。\u003c/p\u003e\n","title":"Spring IoC容器的接口与实现类"},{"content":"\r\n\r\n## 一、数据库范式\r\n\r\n+ 函数依赖：一张表中，两个字段值的一一对应关系称为函数依赖；\r\n+ 第一范式：如果一张表内同类字段不重复出现，则该表就满足第一范式的要求；\r\n+ 第二范式：在满足第一范式的基础上，如果每个“非关键字”字段仅仅函数依赖于主键，那么该表就满足第二范式的要求；\r\n+ 第三范式：在满足第二范式的基础上，并且不存在“非关键字”字段函数依赖于任何其他“非关键字”字段，那么该表就满足第三范式的要求。\r\n\r\n## 二、关系数据库的设计\r\n\r\n+ 为每个实体建立一张数据表；\r\n+ 为每张表定义一个主键；\r\n+ 增加外键表示一对多关系；\r\n+ 而特殊的一对一关系可以通过表示一对多关系的外键增加唯一性约束来实现；\r\n+ 建立新表表示多对多关系，即将两张表的主键分别作为没有添加唯一性约束的外键关联在另一张新表中；\r\n+ 为字段选择合适的数据类型；\r\n+ 定义约束条件：主键约束、外键约束、唯一约束、非空约束、检查约束、默认值约束；\r\n+ 使用规范化减少数据冗余，即满足三大范式。\r\n\r\n## 三、简单查询\r\n\r\n基本的查询语法格式如下\r\n\r\n```\r\nselect [* | distinct | distinctrow | col_name...] [from table_name] [where condition] [group by col_name] [having condition] [order by col_name [asc | desc]] [limit [offset,] row_count];\r\n```\r\n\r\n+ `[* | distinct | distinctrow | col_name...]`：*代表表中的全部字段；distinct和distinctrow代表的是同一意思，就是去除查询结果中相同的行；col_name代表查询的字段名，多个字段用逗号隔开；\r\n+ `[where condition]`：代表查询的条件，可以使用运算符进行连接；\r\n+ `[group by col_name]`：代表分组的条件，对查询的结果进行分组；\r\n+ `[having condition]`：在分组查询中使用的条件语句，并且只能在分组查询中使用；\r\n\r\n#### 3.1 where条件运算符\r\n\r\n+ `and`：并且关系；\r\n+ `or`：或者关系；\r\n+ `like`：模糊查询，`_`代表一个字符，`%`代表0到多个字符；\r\n+ `in`操作符：表示在某一范围之内，使用方式为`where 字段 in(..., ...)`, in中也可以是一个查询语句，如`where 字段 in(select * from ...)`;\r\n+ `not in()`操作符：与in相反；\r\n\r\n## 四、复杂查询\r\n\r\n#### 4.1 分组查询\r\n\r\n分组查询通过`select`语句的`group by`子句来完成，通过分组查询可以很容易完成查询中的统计操作，与普通查询不同，分组查询的条件是通过`having`来指定的而不是`where`。\r\n\r\n需要注意的是，当在一个查询中使用group by子句时，它的select子句后面只能是聚合函数或者是group by之后的列名，否则查询后的结果没有任何意义，示例如下(按subject字段查询studentinfo表中subject字段的记录数)\r\n\r\n```\r\nselect subject, count(*) from studentinfo group by subject;\r\n```\r\n\r\n也可以对多列进行分组查询。\r\n\r\n#### 4.2 多表查询\r\n\r\n##### 4.2.1 等值连接\r\n\r\n等值连接就是讲多个表之间的相同字段作为条件查询数据，然后将对应的字段值查询出来。通常情况下，多个表之间的相同字段指的是表与表之间的主外键，这样就可以将一对多关系直接全部查询出来，示例如下\r\n\r\n```\r\nselect newstudentinfo.name, subjectinfo.subjectname from newstudentinfo, subjectinfo where newstudentinfo.subjectid=subjectinfo.id;\r\n```\r\n\r\n当然可以通过where连接多个条件来查询多个表的满足条件的记录，如下示例：\r\n\r\n```\r\nselect newstudentinfo.name, subjectinfo.subjectname, teacherinfo.teachername from newstudentinfo, subjectinfo, teacherinfo where newstudentinfo.subjectid=subjectinfo.id and newstudentinfo.teacherid=teacherinfo.id;\r\n```\r\n\r\n##### 4.2.2 笛卡尔积\r\n\r\n查询内容是所有查询的数据表中所有列的和以及行的乘积，对实际应用没有太大意义。\r\n\r\n##### 4.2.3 外连接\r\n\r\n等值连接的查询结果全部是符合条件的行组成的，如果想得到查询结果之外的行应该怎么办？答案是使用外连接查询来完成，外连接分为左外连接和右外连接。\r\n\r\n左外连接的查询结果是，除了返回表中符合条件的记录外还要加上左表中剩下的全部记录，右外连接的查询结果是，除了返回表中符合条件的记录外还要加上右表中剩下的全部记录。具体的语法如下所示：\r\n\r\n```\r\nselect col... from tableA left outer join(right outer join) tableB on condition;\r\n```\r\n\r\n##### 4.2.4 内连接\r\n\r\n内连接与外连接不同，内连接不分左右并且使用内连接查询的结果都是符合条件的结果。与上面的等值连接是很相似的，语法如下\r\n\r\n```\r\nselect col... from tableA inner join tableB on condition;\r\n```\r\n\r\n内连接与等值连接相比，内连接的好处就是可以更好地明确数据表的连接方式，同时，使用`on`作为连接条件也能更好地清楚地知道使用的是多表连接。\r\n\r\n#### 4.3 合并查询结果\r\n\r\n合并查询结果就是讲两张表的查询结果垂直合并在一起，前提是两张表查询字段的数据类型必须一致，语法格式如下\r\n\r\n```\r\nselect col... from table_name union select col... from table_name;\r\n```\r\n\r\n还可以对查询的结果进行排序，如下\r\n\r\n```\r\n(select col... from table_name) union (select col... from table_name) order by col_name;\r\n```\r\n\r\n还可以限制组合查询结果的行数\r\n\r\n```\r\n(select col... from table_name) union (select col... from table_name) limit 行数;\r\n```","cover":"/images/mysql-logo.png","link":"design-of-relational-database.html","preview":"\u003cp\u003e函数依赖与数据库三大范式、关系数据库的设计、简单查询、复杂查询。\u003c/p\u003e\n","title":"数据库范式与关系数据库设计以及简单查询和复杂查询"},{"content":"\r\n\r\n## 一、乐观锁与悲观锁\r\n\r\n#### 1.1 乐观锁与使用版本号实现乐观锁\r\n\r\n乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则对用户返回错误信息，让用户决定如何去处理。 实现方式为`版本号`和`时间戳`。\r\n\r\n使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。 \r\n\r\n```\r\n// 1.查询出商品信息 \r\nselect status, version from t_goods where id=#{id};\r\n\r\n// 2.根据商品信息生成订单 \r\n\r\n// 3.修改商品status为2 \r\nupdate t_goods set status=2,version=version+1 where id=#{id} and version=#{version};\r\n```\r\n\r\n可以看出第三条SQL语句的where条件是`version=#{version}`，也就是version字段没有发生变化的时候才执行更新操作，version字段没有变化就意味着在读取version与修改version期间没有事务修改数据，那么version也就不会发生变化，也就可以执行更新操作。\r\n\r\n#### 1.2 悲观锁\r\n\r\n悲观锁指的是外界对数据修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制。具体包括行锁、表锁等。\r\n\r\n## 二、MyISAM的表级锁\r\n\r\nMySQL的MyISAM存储引擎只支持表级锁，有两种模式：表共享读锁（table read lock）和表独占写锁（table write lock）。锁模式的兼容性如下\r\n\r\n | None | 读锁 | 写锁\r\n:-: | :-: | :-: | :-: |\r\n读锁 | 兼容 | 兼容 | 冲突\r\n写锁 | 兼容 | 冲突 | 冲突\r\n\r\n**也就是说对于MyISAM表的读操作不会因为不同进程访问资源而发生阻塞，而对于MyISAM表的写操作会阻塞其他用户对同一表的读和写操作。**\r\n\r\n读锁和写锁的加锁方式以及解锁方式分别为：\r\n\r\n```\r\nlock table table_name read;\r\n\r\nlock table table_name write;\r\n\r\nunlock tables;\r\n```\r\n\r\n在读锁加锁期间，不管是当前session还是其他session都是可以读取数据的，但是加锁的session不可以更新数据，因为加的是读锁，其余的session的更新操作会被阻塞等待直到读锁释放才会更新成功。\r\n\r\n在写锁加锁期间，只有当前session可以执行查询或更新操作，因为写锁与读锁以及写锁不兼容，其余session的查询与更新操作会被阻塞等待直到拥有锁的session释放锁为止。\r\n\r\n可以通过如下命令获取MyISAM表级锁的争用情况：\r\n\r\n```\r\nshow status like 'table%';\r\n```\r\n\r\n该命令显示的具体参数含义如下：\r\n\r\n+ `Table_locks_immediate`：产生表级锁定的次数；\r\n+ `Table_locks_waited`：出现的比较锁定争用而发生等待的次数；\r\n\r\n如果`Table_locaks_waited`的值比较高,那么说明存在比较严重的表级锁争用情况。MyISAM在读操作占主导的情况下是高效的，可一旦出现大量读写操作并发，与InnoDB相比，MyISAM的执行效率就会直线下降。\r\n\r\nMyISAM存储引擎有个系统变量，`concurrent_insert`，专门用以控制其并发插入的行为，其值分别是0、1、2。解释如下：\r\n\r\n+ 当值为0时，不允许并发插入；\r\n+ 当值为1时，如果表中没有被删除的行，MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录；\r\n+ 当值为2时，无论表中有没有被删除的行，都允许在表尾并发插入记录。\r\n\r\n## 三、InnoDB行级锁\r\n\r\nInnoDB支持行级锁，支持事务处理。在处理数据量上InnoDB支持海量数据，并且在具有良好的索引的基础上，InnoDB的查询速度要比MyISAM快。\r\n\r\n#### 3.1 注意：事务与并发的区别\r\n\r\n**事务通常包含一系列更新操作，这些更新操作是一个不可分割的逻辑工作单元。要么全部成功，要么全部失败。一个session或进程或线程的某个操作如果包含一系列不可分割的逻辑单元那么就是一个事务，而并发指的是有可能包含事务操作的多进程/线程同时对某一资源进行操作，所以，在多进程/线程并发中，保持某进程/线程事务的完整性是安全且高效并发的基础。也就是说，在多进程/线程并发操作某一资源时，某个进程/线程的对资源一系列更新操作的抽象（也就是事务）安全（即事务安全）必须得到保证，不然就会产生数据错误。包含以下几种：**\r\n\r\n+ 丢失更新：一个事务读取数据并提交修改，覆盖了从上次读取之后其他事务提交的修改（不是基于最新的数据进行修改）；\r\n+ 读脏数据：一个事务读到另外一个事务还没有提交的数据；\r\n+ 不可重复读：一个事务两次读取一条记录之间有其他事务修改了改记录，导致两次读取的结果不一样；\r\n+ 幻读：一个事务两次读取多条记录之间有其他事务进行了添加或删除的操作，导致两次读取记录的数量不一致。\r\n\r\n因此为了避免数据错误，必须保证并发事务的安全性。可以通过数据库隔离级别来实现不同程度上的安全隔离。如下\r\n\r\n纵向为`隔离级别`、横向为`读数据一致性及允许并发的副作用` | 读数据一致性 | 脏读 | 不可重复读 | 幻读\r\n:-: | :-: | :-: | :-: | :-:\r\n未提交读 | 最低级别，只能保证不读取物理上损坏的数据 | 是 | 是 | 是\r\n已提交读 | 语句级 | 否 | 是 | 是\r\n可重复读 | 事务级 | 否 | 否 | 是\r\n可序列化 | 最高级别，事务级 | 否 | 否 | 否\r\n\r\n**可见，事务的隔离级别越严格，并发的副作用就小，但付出的代价越大。**\r\n\r\n**事务与并发总结：事务安全是在并发中出现的，没有并发就不会产生事务安全。MyISAM不支持事务即不支持一系列不可分割的更新操作组成的逻辑工作单元，所以就不会产生事务安全问题。但是InnoDB支持事务操作，那么就会存在上述事务安全问题。为了解决上述事务安全问题，必须首先关闭MySQL自动提交（因为自动提交会使得每一条更新语句被执行从而数据被持久化），然后执行一系列更新语句组成的逻辑工作单元后再显式提交事务（`commit`），出问题还可以回滚（`rollback`）。也可以不关闭自动提交，直接显式开启事务（`start transaction`）即可也是同样的效果。这是一个session/进程/线程对自己事务的处理方式从而保证自己的一系列操作是完整的，但是高并发环境下，进程/线程之间各自事务的安全性保证则要通过事务的隔离级别来实现。同样的，并发操作必须加锁。即线程/进程的原子事务的子操作必须加锁保证对某一条记录的修改是独占的，进程/线程之间的事务安全通过隔离级别来保证。**\r\n\r\n#### 3.2 InnoDB行级锁模式、事务下共享锁与排它锁的使用流程\r\n\r\n锁模式 | 共享锁（S） | 排它锁（X） | 意向共享锁（IS） | 意向排它锁（IX）\r\n:-: | :-: | :-: | :-: | :-:\r\n共享锁（S） | 兼容 | 冲突 | 兼容 | 冲突\r\n排它锁（X） | 冲突 | 冲突 | 冲突 | 冲突\r\n意向共享锁（IS） | 兼容 | 冲突 | 兼容 | 兼容\r\n意向排它锁（IX） | 冲突 | 冲突 | 兼容 | 兼容\r\n\r\n各个锁的含义如下：\r\n\r\n+ 共享锁（S）：允许一个事务读一行数据时，阻止其他的事务读取相同数据的排它锁；\r\n+ 排它锁（X）：允许获得排它锁的事务更新数据，阻止其他事务取得相同数据的共享锁和排它锁；\r\n+ 意向共享锁（IS）：事务打算给数据行加行共享锁。事务在给一个数据行加共享锁前必须先取得该表的IS锁；\r\n+ 意向排它锁（IX）：事务打算给数据行加行排它锁，事务在给一个数据行加排它锁前必须先取得该表的IX锁。\r\n\r\n如果一个事务请求的锁模式与当前的锁模式兼容，InnoDB就将请求的锁授予该事务，如果两者不兼容，那么该事务就要等待锁释放。\r\n\r\n意向锁是InnoDB存储引擎自动加的，对于普通的SELECT语句，InnoDB不会加任何锁，对于INSERT、UPDATE、DELETE语句，InnoDB会自动给涉及的数据加排它锁，InnoDB可以通过如下语句添加共享锁（S）与排它锁（X）：\r\n\r\n```\r\nSQL语句 LOCK IN SHARE MODE;\r\n\r\nSQL语句 FOR UPDATE；\r\n```\r\n\r\n使用InnoDB共享锁与排它锁必须满足以下几个条件：\r\n\r\n1. 设置autocommit的值是OFF或；\r\n2. 表的数据引擎是支持事务的，比如InnoDB数据引擎；\r\n3. 如果不管autocommit，手段在事务里执行操作，这个时候要使用begin或者start transaction开启事务；\r\n4. 不要在锁定事务规定的时间外使用共享锁和排它锁。\r\n\r\n之所以有上述四个条件是因为InnoDB是支持事务的，而InnoDB又是自动提交的，这和事务一次性提交不符，所以先要关闭事务自动提交，或者直接使用start transaction开启事务，执行完事务中的SQL语句后再提交(commit)。\r\n\r\n以上条件也是InnoDB存储引擎在支持事务的情况下的获取共享锁或排它锁实现数据操纵的流程。\r\n\r\n**需要注意的是，InnoDB行级锁是通过给索引上的索引项加锁来实现的，InnoDB行级锁只有通过索引条件检索数据，才使用行级锁，否则使用表级锁。**\r\n\r\n#### 3.3 InnoDB在不同隔离级别下加锁的差异\r\n\r\n在不同隔离级别下，InnoDB处理SQL语句时所采用的一致性和需要的锁是不同的。\r\n\r\n对于SQL语句而言，隔离级别越高，InnoDB存储引擎给记录添加的锁就越严格，产生锁冲突的可能性就越高（因为高隔离级别是保证了某一个事务的整体完整性，因此其余事务就会产生锁等待），对并发的性能影响就越大。因此，应该尽量使用较低的隔离级别，以降低并发中的锁争用的几率。\r\n\r\n对于一些需要使用较高隔离级别的情况，可以通过如下操作更换隔离级别：\r\n\r\n```\r\nset session transaction isolation level repeatable read;\r\n\r\nset session transaction isolation level serializable;\r\n```\r\n\r\n#### 3.4 间隙锁（Net-Key锁）\r\n\r\n在更新InnoDB存储引擎表中的某个区间数据时，将会锁定这个区间的所有记录，即使这个区间中的某条记录不存在，该条记录也会被锁住，这个时候，如果另外一个session往这个表中添加一条记录时，此时必须等到上一个事务释放锁资源。\r\n\r\nInnoDB使用间隙锁的目的，一方面是为了防止幻读，如果没有加间隙锁，如果其他事务添加某个区间的某条记录，那么就会发生幻读；另一方面，是为了满足其恢复和赋值的需求。","cover":"/images/mysql-logo.png","link":"mysql-locking-mechanism.html","preview":"\u003cp\u003e乐观锁与悲观锁、MyISAM的表级锁、InnoDB行级锁。\u003c/p\u003e\n","title":"MySQL锁定机制"},{"content":"\r\n\r\n## 一、MySQL查询缓存\r\n\r\nMySQL查询缓存机制简单说就是会缓存SQL语句和查询的结果，如果运行相同的SQL语句，服务器会直接从缓存中取到结果，而不需要再去解析和执行SQL语句。查询缓存会返回最新的数据而不是过期数据，当数据被修改后，在查询缓存中的任何相关数据均被清除。对于频繁更新的表，查询缓存是不合适的，对于一些不经常改变数据且有大量相同SQL查询的表，查询缓存会提高很大的性能。\r\n\r\n查看系统查询缓存是否可用，命令为：\r\n\r\n```\r\nshow variables like 'have_query_cache';\r\n```\r\n\r\n查看查询缓存是否开启，命令为：\r\n\r\n```\r\nselect @@query_cache_type;\r\n```\r\n\r\n开启查询缓存，命令为：\r\n\r\n```\r\nset session query_cache_type=ON;\r\n```\r\n\r\n关闭查询缓存，命令为：\r\n\r\n```\r\nset session query_cache_type=OFF;\r\n```\r\n\r\n查询数据库分配给查询缓存的内存大小，命令为：\r\n\r\n```\r\nselect @@global.query_cache_size;\r\n```\r\n\r\n设置查询缓存大小，命令为：\r\n\r\n```\r\nset @@global.query_cache_size=1000000;\r\n```\r\n\r\n该参数如果需要永久修改，需要修改`/etc/my.cnf`配置文件，添加该参数的选项，如下\r\n\r\n```\r\n[mysqld]\r\nport = 3306\r\nquery_cache_size = 1000000\r\n...\r\n```\r\n\r\n如果查询结果很大，那么就有可能无法缓存，需要设置`query_cache_limit`参数的值，该参数用来设置查询缓存的最大值，默认是1MB，查询与修改的命令如下：\r\n\r\n```\r\nselect @@global.query_cache_limit;\r\nset @@global.query_cache_limit=2000000;\r\n```\r\n\r\n如果需要永久修改，仍然需要修改`/etc/my.cnf`配置文件，添加该参数的选项，如下\r\n\r\n```\r\n[mysqld]\r\nport = 3306\r\nquery_cache_size = 1000000\r\nquery_cache_limit = 2000000\r\n...\r\n```\r\n\r\n可以使用如下命令查看查询缓存相关的参数：\r\n\r\n```\r\nshow variables like '%query_cache%';\r\n```\r\n\r\n可以通过以下命令查看查询缓存命中的累计次数：\r\n\r\n```\r\nshow status like 'Qcache_hits';\r\n```\r\n\r\n监控和维护查询缓存的命令如下：\r\n\r\n+ `flush query cache`：该命令用于整理查询缓存，以便更好地利用查询缓存的内存，这个命令不会从缓存中移除任何数据；\r\n+ `reset query cache`：该命令用于移除查询缓存中的所有查询结果；\r\n+ `show status like 'Qcache%'`：该命令可以监视查询缓存的使用状况，可以计算出缓存的命中率。\r\n\r\n## 二、合并表与分区表\r\n\r\n#### 2.1 合并表\r\n\r\n合并表是通过之前的merge存储引擎将两个MyISAN表合并起来。\r\n\r\nMySQL合并表对性能有一定影响：\r\n\r\n+ 合并表看上去是一个表，事实上是逐个打开各个子表，这样的情况下，可能会因为缓存过多的表而导致超过MySQL缓存的最大设置；\r\n+ 创建合并表的CREATE语句不会检查子表是否兼容，如果创建了一个有效地合并表后对某个表进行了修改，那么合并表也会发生错误。\r\n\r\n#### 2.2 分区表\r\n\r\n表分区就是讲一张大表，根据条件分割成若干小表。查看当前数据库是否支持分区的命令如下：\r\n\r\n```\r\nshow variables like '%partition%`；\r\n```\r\n\r\n+ range分区：使用values less than操作符来进行定义，把连续且不相互重叠的字段分配给分区，命令如下\r\n\r\n```\r\ncreate table table_name(\r\n  field...\r\n) partition by range(field)(\r\n  partition p1 values less than(1000),\r\n  partition p2 values less than(2000),\r\n  partition p3 values less than(3000)[,\r\n  partition p4 values less than maxvalue]\r\n);\r\n```\r\n\r\n+ list分区：该分区对应字段的值是一个集合而不是一个范围，如下\r\n\r\n```\r\ncreate table table_name(\r\n  field...\r\n) partition by list(field)(\r\n  partition p1 values in(10, 20),\r\n  partition p2 values in(30),\r\n  partition p3 values in(40)\r\n);\r\n```\r\n\r\n+ hash分区；\r\n+ 线性hash分区；\r\n+ key分区；\r\n+ 复合分区。\r\n\r\n## 三、事务控制\r\n\r\n事务通常包含一系列更新操作，这些更新操作是一个不可分割的逻辑工作单元。要么全部成功，要么全部失败。默认情况下，MySQL事务是自动提交的，如果需要通过明确的COMMIT和ROLLBACK再提交和回滚事务，就需要通过明确的事务控制来开始事务。MySQL的默认开启的事务在一定程度上影响性能，比如1000条数据提交会提交事务1000次，事实上手动开启事务只需要一次提交即可。通过如下方式关闭事务自动提交功能\r\n\r\n```\r\nset @@autocommit=0;\r\n```\r\n\r\n查看自动提交功能是否关闭：\r\n\r\n```\r\nshow variables like \"autocommit\";\r\n```\r\n\r\n开启事务的命令为：\r\n\r\n```\r\nstart transaction;\r\n```\r\n\r\n提交事务的命令为：\r\n\r\n```\r\ncommit;\r\n```\r\n\r\n回滚事务的命令为：\r\n\r\n```\r\nrollback;\r\n```\r\n\r\n如果在表的锁定期间，使用`start transaction`命令开启一个新的事务，会造成一个隐含的`unlock tables`被执行，该操作存在一定的隐患。\r\n\r\n另外，事务的ACID特性如下：\r\n\r\n+ 原子性（Atomicity）：事务具有原子不可分割的特性，要么一起执行，要么都不执行；\r\n+ 一致性（Consistency）：在事务开始和事务结束时，数据都保持一致状态；\r\n+ 隔离性（Isolation）：在事务开始和结束过程中，事务保持着一定的隔离特性，保证事务在不受外部并发数据操作的影响；\r\n+ 持久性（Durability）：事务完成后，数据将会被持久化到数据库中。","cover":"/images/mysql-logo.png","link":"advanced-features-of-mysql.html","preview":"\u003cp\u003eMySQL查询缓存、合并表与分区表、事务控制。\u003c/p\u003e\n","title":"MySQL的高级特性"},{"content":"\r\n\r\n## 一、地址重定位、存储保护与存储共享\r\n\r\n#### 1.1 逻辑地址与物理地址、地址重定位\r\n\r\n+ 逻辑地址：是与程序在内存中的物理位置无关的访问地址。在执行对内存的访问之前，必须把逻辑地址转化为物理地址；\r\n+ 相对地址：是逻辑地址的一个特例，是相对于已知点的存储单元；\r\n+ 物理地址：是程序运行时中央处理器实际访问的内存单元地址；\r\n\r\n地址重定位或地址变换：在执行程序时，将其中的逻辑地址变为物理地址的过程。分为两种，如下：\r\n\r\n+ 静态重定位：是指在程序装入内存时一次性将程序中所有的逻辑地址全部转化为物理地址，然后程序开始执行。优点是无须硬件支持易于实现，缺点是不允许程序在内存中移动位置，这就给内存碎片的合并带来挑战；\r\n+ 动态重定位：地址转换工作穿插在指令执行过程中，每执行一条指令，CPU对指令中涉及的逻辑地址进行转换。优点是允许程序在内存中移动位置，缺点是必须借助硬件地址转换机构来实现。其地址转换公式为：物理地址 = 逻辑地址 + 内存始址。\r\n\r\n#### 1.2 存储保护\r\n\r\n目的是访问访问地址越界和控制正确存取。每道程序的地址空间限定了自己的合法访问范围，若无特别许可，则一个进程也不能访问其他进程的数据区。越界保护依赖于硬件设施，常用的有界地址与存储键。\r\n\r\n进程访问分配给自己的主存区时，要对访问权限进行检查，从而确保数据的安全性与完整性，防止有意或无意的误操作而破坏主存信息，这就是信息存取保护。\r\n\r\n#### 1.3 存储共享\r\n\r\n当多个进程执行一个程序，或者多个进程合作完成同一个任务需要访问相同的数据结构时，内存管理系统都要提供存储共享机制，以对内存共享区域进行受控访问。\r\n\r\n## 二、连续存储管理（分区存储管理）\r\n\r\n连续存储管理对每个进程分配一个连续的存储区域，连续存储管理分为固定分区存储管理和可变分区存储管理。\r\n\r\n#### 2.1 固定分区存储管理\r\n\r\n固定分区存储管理将内存空间划分为若干个位置和大小固定的连续区域，每一个连续区域称为一个分区，各分区大小可以相同，也可以不同。该存储管理方案存在以下缺点：\r\n\r\n+ 分区数目和大小在系统启动阶段就已经确定，限制了系统中活动进程的数目，也限制了当前分区方案下可运行的最大进程；\r\n+ 当分区长度大于其中进程长度时，造成存储空间浪费。由于进程所在分区大于进程大小而造成的分区内部浪费部分称为内部碎片。\r\n\r\n固定分区存储管理通过内存分配表完成对存储的管理，各项分别为分区号、起始地址、长度以及占用标志，进程申请内存时需要在该表上进行登记然后在运行时或者装入内存前需要进程地址重定位。\r\n\r\n该种存储管理模式下，作业的排队策略为：\r\n\r\n+ 将每个进程分配到能够容纳它的最小分区中；\r\n+ 把每个分区的集合看作一种共享资源，设置一个队列，无空闲分区可用的所有进程排成一个队列，每当需要装入进程到内存中时，选择可以容纳该进程的最小可用分区，如果所有分区均被占据，则进行交换。\r\n\r\n#### 2.2 可变分区存储管理\r\n\r\n相对于固定分区存储管理而言，可变分区存储管理指的是分区的位置和大小是动态的。缺点是随着时间的推移，内存中会产生许多小到难以利用的分区，称之为外部碎片。克服外部碎片的技术是压缩：操作系统移动进程，将空闲分区连成一片。但是压缩非常耗时，浪费处理器时间，而且系统需要具备动态重定位能力。\r\n\r\n可变分区存储管理通过分区表来管理内存，分区表分为已分配分区表与空闲分区表。作业的装入与撤销过程如下\r\n\r\n+ 装入新作业时，从空闲分区表中找出足够容纳它的空闲区，将该区一分为二，一部分用来装入作业称为已分配区，并将其大小和起始地址登记在已分配分区表中；另一部分作为空闲分区，修改空闲分区表中原分区的大小和起始地址；\r\n+ 作业运行完撤离时，将作业所在分区作为空闲区登记在空闲分区表中，并考虑该空闲分区与相邻分区的合并问题，同时从已分配表中删除该区对应的表项。\r\n\r\n可变分区的分配算法如下：\r\n\r\n+ 最先适应分配算法：从链首顺序查找，找到第一个满足要求的分区即可开始分配；\r\n+ 下次适应分配算法：每次不从链首顺序查找，而是上次找到的空闲分区的下一个空闲分区开始查找；\r\n+ 最优适应分配算法：每次从链首查找，直到找到一个能够满足要求的最小分区为止；\r\n+ 最坏适应分配算法：扫描整个空闲分区表或空闲分区链，总是挑选一个最大的空闲分区分割给作业使用；\r\n+ 快速适应分配算法：为那些经常用到的长度的空闲区设立单独的空闲分区链表。\r\n\r\n可变分区存储管理可以采用静态或动态重定位实施地址变换。静态重定位时，由加载程序检查地址是否越界；动态地址重定位需要硬件支持。\r\n\r\n## 三、分页存储管理\r\n\r\n允许每个进程占用多个位置不相邻的物理内存区，避免了内存块的合并和内存作业的移动。\r\n\r\n该种存储管理方案下，将全部内存划分为长度相等的若干份，每一份称为一个物理块或者页框。作业也自动被系统划分为与每个物理块相等的若干份，每一份称为一页。\r\n\r\n分页存储管理通过页表来管理内存，当进程装入内存时，进程的每一页会与内存中的每一个物理块相对应，从而可以整理出一个页表，页表每个进程唯一。分页存储管理采用动态重定位。当CPU访问内存时将访存逻辑地址（该逻辑地址由页号与页内偏移组成）的页号根据重定位寄存器载入的页表转化为对应的物理块号，然后加上页内偏移，从而实现访问主存。\r\n\r\n页表放在内存中降低了程序执行速度，CPU每执行一个指令/数据，就需要两次访问内存，第一次访问内存取得物理块号以形成物理地址，第二次根据物理地址存取指令/数据，速度降低了一半。为了提高速度，在存储管理部件中增设了一个专用的高速缓冲存储器，用来存放最近访问过的部分页表项，称之为快表。\r\n\r\n## 四、分段存储管理\r\n\r\n以程序段为单位进行内存分配，以段表来进行地址映射，由于程序段的大小不一，那么不能通过分页式存储管理的页表结构来映射地址，段表的结构如下（示例）\r\n\r\n段号 | 长度 | 段起始地址\r\n:-: |:-: |:-: \r\n0 | k | 3200\r\n1 | p | 1500\r\n2 | l | 6000\r\n3 | n | 8000\r\n4 | s | 5000\r\n\r\n当CPU访存时，根据程序段号从段表中找到对应的段起始地址，然后加上段内偏移形成物理地址。长度起到了越界保护的作用。\r\n\r\n## 五、虚拟内存管理——请求分页存储管理\r\n\r\n在进程开始运行之前，不是装入全部的页面，而是装入一个或几个页面，当进程运行过程中，访问的页面不存在时，再装入所需页面；若内存空间已满，而又需要装入新的页面，则根据某种算法淘汰某个页面，以便装入新的页面。因此，请求分页系统的页表机制需要记住页面是否在内存中，若不在内存中，则需记住位于外存的位置。\r\n\r\n请求分页的内存管理由外页表和内页表组成，外页表是页面与磁盘物理地址的对应表，由操作系统管理，进程启动前，系统为其建立外页表，并把进程程序页面装入外存，该表按进程也好的程序排列。为节省主存，外页表可以放在磁盘中，当发生缺页中断时再调入内存，结构如下\r\n\r\n页号 | 外存地址\r\n:-: | :-: \r\n\r\n可见，缺哪一页可以直接根据对应的外存地址调入主存。\r\n\r\n而内页表的结构如下\r\n\r\n页号 | 物理块号 | 驻留标志位 | 引用位 | 修改位 | 访问权限位\r\n:-: | :-: | :-: | :-: | :-: | :-: \r\n\r\n+ 驻留标志位：指示页面是否在内存中；\r\n+ 引用位：指示页面最近是否被访问过，以便页面淘汰；\r\n+ 修改位：指示页面是否最近被修改过，以决定页面调出内存时是否写回外存；\r\n+ 访问权限位：规定页面的访问权限。\r\n\r\n**可见，内页表是外存具体页面与主存页面的对应关系，访问外存的地址在当前页存在的情况下需要通过内页表映射物理块号然后根据页内偏移访存，而其余字段是对该页的控制，当当前页不存在时，则根据外页表查找对应的磁盘位置，然后调入。**\r\n\r\n页面替换算法包括如下几种：\r\n\r\n+ 最佳页面淘汰算法：所淘汰的页是以后不再访问或距离现在最长时间后再访问的页；\r\n+ 先进先出页面淘汰算法；\r\n+ 最近最久使用页面淘汰算法；\r\n+ 第二次机会页面淘汰算法；\r\n+ 时钟页面替换算法。\r\n\r\n\u003e 参考《操作系统原理与Linux实践教程》 / 申丰山 王黎明 编著","cover":"/images/os.jpg","link":"principle-basis-of-operating-system-another.html","preview":"\u003cp\u003e地址重定位、存储保护与存储共享、连续存储管理（分区存储管理）、分页存储管理、分段存储管理、虚拟内存管理——请求分页存储管理。\u003c/p\u003e\n","title":"计算机操作系统原理总结(二)——存储管理"},{"content":"\r\n\r\n## 一、传输层功能、TCP与UDP\r\n\r\n#### 1.1 传输层功能\r\n\r\n+ 传输层寻址；\r\n+ 传输连接建立；\r\n+ 数据传输；\r\n+ 传输连接释放；\r\n+ 流量控制；\r\n+ 拥塞控制；\r\n+ 多路复用和解复用；\r\n+ 崩溃恢复。\r\n\r\n#### 1.2 TCP协议\r\n\r\n##### 1.2.1 TCP协议的主要特性\r\n\r\n1. 面向连接的传输协议：即应用程序在使用TCP之前，必须先建立TCP连接，在传输数据完毕后，必须释放已建立的TCP传输连接；\r\n2. 仅支持单播传输：即只能进行点对点的数据传输，不支持多播和广播传输方式；\r\n3. 提供可靠的交付服务：即TCP连接传送的数据可以无差错、不丢失、不重复，且按时序到达对端；\r\n4. 传输单位为数据段：仍采用了传统的“数据段”作为传输单元；\r\n5. 仅一种TPDU格式；\r\n6. 支持全双工传输：允许通信双方的应用程序在任何时候都能发送数据，因为TCP的两端都设有发送和缓存，用来临时存放双向通信的数据；\r\n7. TCP连接是基于字节流的，而非报文流；\r\n8. 每次发送的TCP数据段大小和数据段数都是可变的。\r\n\r\n##### 1.2.2 TCP数据段格式\r\n\r\n![TCP数据段格式](/images/article/tcp.jpg)\r\n\r\n+ 序号：在一个TCP连接中，传输的数据字节流中的每一个数据字节都要按顺序进行编号；比如一个数据段的“序号”字段值是101.而该数据段中共有100字节，那么表明本数据段的最后一个字节的编号是200。那么下一次发送时，数据的序号字段值应该是201而不是102；\r\n+ 确认号：指期望接收到对方下一个数据段中“数据”部分的第一个字节序号。这里的确认号就是上文的201；\r\n+ 数据偏移：指数据段中“数据部分”距离TCP数据段起始处的字节偏移量；\r\n+ URG：紧急指针控制位，置为1表明有紧急数据；\r\n+ ACK：确认控制位，指示TCP数据段中的“确认号”字段是否有效，仅当该位为1时，才表示“确认号”字段有效，否则表示无效；\r\n+ PSH：推控制位，指示是否需要立即把收到的该数据段提交给应用进程；\r\n+ RST：重置控制位，用于重置、释放一个已经混乱的传输连接，然后重新建立新的传输连接；\r\n+ SYN：同步控制位，用来在传输连接建立时同步传输连接信号，置为1时表示这是一个连接请求或连接确认报文。当SYN=1,而ACK=0时，表示这是一个连接请求数据段，如果对方同意建立连接，则会返回一个SYN=1,ACK=1的确认；\r\n+ FIN：最后控制位，用于释放一个传输连接，当置为1时，表示数据已全部传输完成，发送端没有数据传输了，要求释放当前连接，但是接收端仍然可以继续接收还没有接收完的数据，在正常传输中，应该置为0；\r\n+ 窗口大小：指示发送此TCP数据段的主机上用来存储传入数据段的窗口大小，即发送者当前还可以接收的最大字节数；\r\n+ 检验和：对数据段头、数据以及伪头部这三部分进行检验；\r\n+ 紧急指针：仅当前面的URH控制位置为1时才有意义，它指出本数据段中最为紧急数据的字节数。\r\n\r\n##### 1.2.3 TCP三次握手与四次挥手\r\n\r\n![TCP三次握手](/images/article/tcpthree.jpg)\r\n\r\n![TCP四次挥手](/images/article/tcpfour.jpg)\r\n\r\n#### 1.3 UDP协议\r\n\r\n##### 1.3.1 UDP协议的特点\r\n\r\n+ 无连接性：在发送数据前不需要建立连接，当然在数据发送结束后无须释放连接；\r\n+ 不可靠性：适用于一些短消息类的数据传输；\r\n+ 以报文为边界：直接对应用层提交的报文进行封装、传输，但是不拆分，也不合并；\r\n+ 无流量控制与拥塞控制功能：因为这类数据的连续性比数据的完整性更重要，允许数据在传输过程中有部分丢失；\r\n+ 支持各种交互通信方式：可以是一对一、一对多、多对多的方式。\r\n\r\n###### 1.3.2 UDP数据报头部格式\r\n\r\n![UDP数据报头部格式](/images/article/udp.jpg)\r\n\r\n#### 1.4 TCP与UDP的区别\r\n\r\n1. TCP面向连接,而UDP是无连接的;\r\n2. TCP提供可靠的服务，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付；\r\n3. TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）\r\n4. 每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信；\r\n5. TCP首部开销20字节;UDP的首部开销小，只有8个字节；\r\n6. TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。\r\n\r\n## 二、应用层HTPP协议、DNS协议\r\n\r\n#### 2.1 HTTP协议的主要特点\r\n\r\n+ 客户端 / 服务器（C / S）模式；\r\n+ 无连接：指的是进行Web应用前无须建立专门的HTTP应用层会话连接，直接利用传输层建立好的TCP传输连接即可；\r\n+ 高可靠性：虽然HTTP协议本身是不可靠的无连接协议，但它使用了可靠的TCP传输层协议；\r\n+ 无状态：指的是Web服务器不会记住这个客户端曾经访问过这个页面；\r\n+ 简单快速：客户端访问服务器，只需要传送请求方法和路径即可；\r\n\r\n#### 2.2 HTTP请求与响应报文格式\r\n\r\n请求报文格式如下\r\n\r\n```\r\nGET /bundle/index.js HTTP/1.1\r\nHost: localhost:8000\r\nConnection: keep-alive\r\nUser-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\r\nAccept: */*\r\nReferer: http://localhost:8000/\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9\r\nIf-Modified-Since: Fri, 05 Jul 2019 12:23:24 GMT\r\n```\r\n\r\n响应报文格式如下\r\n\r\n```\r\nHTTP/1.1 304 Not Modified\r\nLast-Modified: Fri, 05 Jul 2019 12:23:24 GMT\r\nDate: Fri, 05 Jul 2019 12:26:56 GMT\r\n```\r\n\r\n#### 2.3 DNS协议递归解析的基本流程\r\n\r\n1. 客户端向本机配置的本地名称服务器发出DNS域名查询请求；\r\n2. 本地名称服务器收到请求后，先查询本地的缓存，如果有该域名的记录项，则本地名称服务器直接把查询的结果返回给客户端；如果本地缓存中没有该域名的记录，则本地名称服务器再以DNS客户端的角色发送与前面一样的DNS域名查询请求给根名称服务器；\r\n3. 根名称服务器收到DNS请求后，把查询到的所请求的DNS域名中顶级域名所对应的的顶级名称服务器地址返回给本地名称服务器；\r\n4. 本地名称服务器根据根名称服务器返回的顶级名称服务器地址，向对应的顶级名称服务器发送与前面一样的DNS域名查询请求；\r\n5. 对应的顶级名称服务器在收到DNS查询请求后，也是先查询自己的缓存，如果有所请求的DNS域名的记录项，则先把对应的记录项返回给本地名称服务器地址，然后再由本地名称服务器返回给DNS客户端，否则向本地名称服务器返回所请求的DNS域名中的二级域名所对应的的二级名称服务器地址；\r\n\r\n然后，本地名称服务器继续按照前面介绍的方法一次次地向三级、四级名称服务器查询，直到最终的对应域名所在区域的权威名称服务器返回最终的记录给本地名称服务器，再由本地名称服务器返回给DNS客户，同时本地名称服务器会缓存本次查询得到的记录项。","cover":"/images/computernetworks.jpg","link":"deep-understanding-of-computer-networks-another.html","preview":"\u003cp\u003e传输层功能、TCP与UDP、应用层HTPP协议、DNS协议。\u003c/p\u003e\n","title":"深入理解计算机网络（二）"},{"content":"\r\n\r\n## 一、OSI/RM七层体系结构\r\n\r\n![OSI/RM七层体系结构](/images/article/osi.jpg)\r\n\r\n## 二、TCP/IP协议四层体系结构\r\n\r\n![TCP/IP协议四层体系结构](/images/article/tcpip.jpg)\r\n\r\n## 三、MAC子层功能、帧格式、ARP协议\r\n\r\n#### 3.1 MAC子层功能\r\n\r\n+ MAC帧的封装与拆卸；\r\n+ 实现和维护各种MAC协议；\r\n+ 比特流差错检测；\r\n+ MAC寻址。\r\n\r\nMAC帧分为以下三种：\r\n\r\n+ 单播帧：目的MAC地址是一个单播MAC地址的帧；\r\n+ 广播帧：目的MAC地址是一个广播MAC地址的帧；\r\n+ 多播帧：目的MAC地址是一个多播MAC地址的帧。\r\n\r\n#### 3.2 MAC帧格式\r\n\r\n![MAC帧格式](/images/article/macframe.jpg)\r\n\r\n#### 3.3 ARP协议\r\n\r\nARP协议（Address Resolution Protocol, 地址解析协议）是将IP地址解析为以太网MAC地址（或物理地址）的协议。在局域网中，当主机或其他网络设备有数据要发送给另一个主机或设备时，它必须知道对方的网络层地址（即IP地址）。但是仅仅有IP地址是不够的，因为IP数据报文必须封装为帧才能通过物理网络发送，因此发送站还必须有接收站的物理地址，所以需要一个从IP地址到物理地址的映射。ARP就是实现这个功能的协议。\r\n\r\nARP的报文格式如下\r\n\r\n![ARP的报文格式](/images/article/arp.jpg)\r\n\r\nARP地址解析原理：\r\n\r\n+ 同一网段中两主机的ARP地址解析的全过程：\r\n    1. 主机A首先查看自己的ARP表（该表是一个IP地址与MAC地址的映射表），确定其中是否包含主机B的IP地址和对应的MAC地址。如果找到了对应IP的MAC地址，则主机A直接利用ARP表中的MAC地址对IP数据包进行封装，并将数据包发送给主机B；\r\n    2. 如果主机A在ARP表中找不到对应的MAC地址，则先缓存该数据报文，然后以广播方式（目的MAC地址为广播MAC地址——FFFFFF，同网段的任意节点均可收到）发送一个ARP请求报文；\r\n    3. 主机B发现ARP请求报文中的IP地址与自己的一致，就将ARP请求报文中的发送端的IP地址和MAC地址存入自己的ARP表中，然后以单播方式向主机A发送一个ARP响应报文，应答报文就包含了自己的MAC地址；\r\n    4. 主机A接收到了主机B的应答报文，将主机B的MAC地址存入自己的ARP表中以用于后续报文的转发，同时将原来缓存的IP数据包再次修改（即填上对方的MAC地址）然后发送出去。\r\n+ 不同网段中两主机的ARP地址解析的全过程：\r\n    1. 如果主机A不知道网关（主机A所在网的网关）的MAC地址（即主机A的ARP表中没有网关对应的MAC地址表项），则主机A先在本网段中发出一个ARP请求广播，ARP请求报文中的目的IP地址为网关IP地址，代表想获得网关的MAC地址，**如果主机A已经知道网关的MAC地址，则略过此步**；\r\n    2. 网关收到ARP广播包后同样会向主机A发回一个ARP应答包。当主机A从收到的应答报文中获得网关的MAC地址后，在主机A向主机B发送原报文的目的MAC地址字段上填上网关的MAC地址后发给网关；\r\n    3. 如果网关的ARP表中已有主机B对应的MAC地址，则网关直接将来自主机A的报文中的目的MAC地址字段填上主机B的MAC地址后转发给主机B；\r\n    4. 如果网关ARP映射表中没有主机B的MAC地址，网关会再次向主机B所在网段发送ARP广播请求，此时目的IP地址为主机B的IP地址，当网关从收到来自主机B的应答报文中获得主机B的MAC地址后，就可以将由主机A发来的报文重新在目的MAC地址字段填上主机B的MAC地址后发送给主机B。\r\n\t\r\n可见，数据包的转发是一场接力赛。\r\n\r\n## 四、网络层功能、IP数据报格式、IP地址、子网掩码与子网划分\r\n\r\n#### 4.1 网络层的功能\r\n\r\n+ 屏蔽网络差异，提供透明传输；\r\n+ 为网络间通信提供路由选择；\r\n+ 数据包封装和解封装；\r\n+ 拥塞控制\r\n\r\n#### 4.2 IP数据报格式\r\n\r\n![IP数据报格式](/images/article/ip.jpg)\r\n\r\n#### 4.3 IP地址、子网掩码与子网划分\r\n\r\nIPv4使用32位（4字节）地址，因此整个地址空间中有2\u003csup\u003e32\u003c/sup\u003e个地址，也就是近43亿个地址，不过其中一些地址是为特殊用途保留的，实际上可在广域网上使用的、路由的公网IP就不多了。IPv4地址被分为5类，如下\r\n\r\n+ A类IPv4地址：网络ID最高位固定为`0`，后面的7位可变。也就意味着A类网络数目为128个（2\u003csup\u003e7\u003c/sup\u003e）,但实际上可用的只有126个，因为网络ID为0（保留地址）和127（本地环路测试地址）的A类网络不可用；那么32位IP地址还剩下24位，所以每个A类网络中可用的主机ID数为2\u003csup\u003e24\u003c/sup\u003e个，但是主机ID全为0和全为1的地址为广播地址，不能分配使用，所以可用地址数为2\u003csup\u003e24\u003c/sup\u003e-2个。可见，A类网络可以构建的网络数目最少，但每个网络中拥有的主机数最多，适用于大型企业和运营商。\r\n+ B类IPv4地址：网络ID占用最高的前两个字节，最高字节的前两位固定为`10`，后面的14位可变，即B类网络数目为2\u003csup\u003e14\u003c/sup\u003e个；B类IP地址中主机ID为16位，所以每个网络拥有的IPv4地址数为2\u003csup\u003e16\u003c/sup\u003e个，同样主机ID全为1和0的不能分配使用，因此最终的可用地址数为2\u003csup\u003e16\u003c/sup\u003e-2个；\r\n+ C类IPv4地址：网络ID占用最高的前三个字节，最高三位固定为`110`，后面的21位可变，即C类网络数目为2\u003csup\u003e21\u003c/sup\u003e个，C类IP地址中主机ID仅剩一个字节，所以可用的主机ID数仅有2\u003csup\u003e8\u003c/sup\u003e个，同样全为0的地址为网络地址，全为1的地址为广播地址不能使用，所以仅有2\u003csup\u003e8\u003c/sup\u003e-2个可以使用；\r\n+ D类IPv4地址：为组播地址，用于IPv4的组播通信中，前四位固定为`1110`，剩余28位可变；\r\n+ E类IPv4地址：属于IANA保留地址，不分配给用户使用，前5位分别为`11110`，剩余27位可变。\r\n\r\n子网掩码是为了满足IPv4地址分配的层次特点而提出的，也是提高IP地址资源利用率的一种手段，\u003cspan style=\"color:red\"\u003e**可以通过与ID地址做逻辑与运算得到IP地址的网络部分（由于每个网络会被划分为若干个子网，这样仅通过IP地址无法确定网络号是多少，但是通过IP地址与子网掩码做逻辑与运算就可以得到网络号，从而进行数据报传输。需要注意的是，子网划分中向主机号借位仅仅是为了同一网络下子网的划分并不会改变网络号，缺点就是网络号不容易辨认，）**\u003c/span\u003e。与IPv4地址相同，子网掩码也由1和0组成，且长度也是32位，也可以分为网络ID与主机ID两部分，各自的长度与IP地址网络ID与主机ID的长度相对应。只不过子网掩码中网络IP部分全是1，主机IP部分全为0.\r\n\r\n+ A类IP地址的子网掩码：固定为`255.0.0.0`，因为子网掩码网络ID部分全部为1，主机ID部分为0，而A类地址中网络ID部分就是最高的那个字节；\r\n+ B类IP地址的子网掩码：固定为`255.255.0.0`，因为子网掩码网络ID部分全部为1，主机ID部分为0，而B类地址中网络ID部分就是最高的前两个字节；\r\n+ C类IP地址的子网掩码：固定为`255.255.255.0`，因为子网掩码网络ID部分全部为1，主机ID部分为0，而B类地址中网络ID部分就是最高的前三个字节；\r\n\r\n同时子网掩码也是一种解决IPv4地址不足的手段。子网掩码划分的本质是通过向主机ID部分借位实现网络子网划分，借一位在当前网络中产生两个子网，相应地主机ID缩减一个bit位，借两位产生4个子网，以此类推。子网号的位数越多，那么当前网络下划分的子网越多，同样每个子网的主机数越少。","cover":"/images/computernetworks.jpg","link":"deep-understanding-of-computer-networks.html","preview":"\u003cp\u003eOSI/RM七层体系结构、TCP/IP协议四层体系结构、MAC子层功能、帧格式、ARP协议、网络层功能、IP数据报格式、IP地址、子网掩码与子网划分。\u003c/p\u003e\n","title":"深入理解计算机网络（一）"},{"content":"\r\n\r\n## 一、进程的定义、特征、模型\r\n\r\n#### 1.1 进程的概念\r\n\r\n进程是一个可并发执行的、具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配与保护的基本单位。\r\n\r\n#### 1.2 进程的属性：\r\n\r\n+ 结构性：进程包含了数据集合和运行于其上的程序，每个进程至少包含三个组成要素：数据块、程序块、进程控制块（PCB）；\r\n+ 共享性：同一程序运行于不同数据集合上构成不同的进程；\r\n+ 动态性：进程由创建而产生、被调度而执行、被撤销而消亡；\r\n+ 独立性：进程是操作系统中资源分配与保护的基本单位，也是系统调度的独立单位；\r\n+ 制约性：并发进程之间存在着制约关系，进程在执行的关键点上需要相互等待、互通消息；\r\n+ 并发性：在单处理器环境下，各个进程轮流占用处理器。\r\n\r\n#### 1.3 进程的三态模型：\r\n\r\n![进程三态模型](/images/article/jinchengsantai.jpg)\r\n\r\n+ 就绪态：进程具备运行条件，等待系统分配处理器以便运行；\r\n+ 运行态：进程占用处理器正在运行；\r\n+ 阻塞态：进程不具备运行条件,正在等待某个事件完成。\r\n\r\n#### 1.4 进程的五态模型：\r\n\r\n在进程三态模型的基础上，引入新建态与终止态：\r\n\r\n![进程五态模型](/images/article/jinchengwutai.jpg)\r\n\r\n+ 新建态：创建一个进程，正在等待操作系统完成创建进程的必要操作；\r\n+ 终止态：进程已经终止，不再参与处理器竞争。\r\n\r\n## 二、进程控制块（PCB）的作用、信息及组织方式\r\n\r\n#### 2.1 PCB的作用\r\n\r\n操作系统依靠PCB感知进程的存在，PCB是进程存在的唯一标志；\r\n\r\n#### 2.2 PCB的信息\r\n\r\n+ 描述信息：进程标识符、用户名或用户标识符、家族关系；\r\n+ 控制信息：当前状态、优先级、程序开始地址、各种计时信息、通信信息；\r\n+ 资源管理信息；\r\n+ CPU现场保护机构。\r\n\r\n#### 2.3 组织方式\r\n\r\n+ 链接队列方式：就绪、运行、阻塞队列，排队原则与调度策略有关；\r\n+ 索引表方式：就绪、运行、阻塞索引表。\r\n\r\n## 三、进程的控制\r\n\r\n进程的控制是典型的事件驱动，即进程的创建、撤销及阻塞或被唤醒是由特定事件触发的。\r\n\r\n## 四、进程对临界资源访问的互斥性与进程间的同步\r\n\r\n#### 4.1 临界资源的定义\r\n\r\n并发进程可以共享进程中的各种资源，但是系统中某些资源具有一次仅允许一个进程使用的特点，这样的资源被称为临界资源。\r\n\r\n#### 4.2 临界资源的访问\r\n\r\n对于系统中的临界资源，应保证进程的互斥访问，方法就是进行进程间的同步，同步应该遵循以下原则：独立平等、空闲让进、互斥进入、让权等待、有限等待。\r\n\r\n#### 4.3 进程间同步的三种方法\r\n\r\n+ 加锁/开锁原语；\r\n+ 信号量与P、V原语\r\n+ 管程\r\n\r\n在操作系统中利用信号量来表征一种资源或状态，通过对信号量值的改变来表征进程对资源的使用状况，或判断信号量的值来控制进程的状态。**信号量按取值分为以下两种**：\r\n\r\n+ 二元信号量：仅允许取值为0或1，主要用于解决***进程互斥***问题；\r\n+ 一般信号量：初值常常为可用资源数，可以大于1，多用来进行***进程同步***。\r\n\r\n对**信号量S定义**如下：\r\n\r\n1. S是一个整型变量且初值非负；\r\n2. 对信号量仅能实施P(S)、V(S)操作，也只有这两种操作才能改变S的值；\r\n3. 每个信号量都对应一个等待队列，队列中的进程处于等待状态。\r\n\r\n**P原语的操作定义**如下：\r\n\r\n1. S减一；\r\n2. 若S减一后仍大于等于零，则进程继续执行；\r\n3. 若S减一后小于零，则该进程被阻塞进入该信号的等待队列中，然后转进程调度。\r\n\r\n**V原语的操作定义**如下：\r\n\r\n1. S加1；\r\n2. 若S加一后结果大于零，则进程继续执行；\r\n3. 若S加一后结果小于等于零，则从该信号量的等待队列中唤醒一个等待进程，然后再返回原进程继续执行或转进程调度。\r\n\r\n**\u003cu\u003e综上，对信号量以及P、V操作的伪代码描述如下：\u003c/u\u003e**\r\n\r\n```\r\ntypedef struct semaphore {\r\n    int value;    // 信号量值\r\n    struct pcb *list;    // 信号量队列指针\r\n} semaphore;\r\n\r\nvoid P(semaphore \u0026s) {\r\n    s.value--;    // 执行一次P操作，代表索取一个资源，代表资源的信号量值减一\r\n    if (s.value \u003c 0 ) W(s.list);    // 如果value值减一后小于0那么说明暂时没有该类资源可供使用，该进程进入阻塞队列\r\n}\r\n\r\nvoid V(semaphore \u0026s) {\r\n    s.value++;    // 执行一次V操作，代表释放一个资源，信号量value值加一\r\n    if (s.value \u003c= 0) R(s.list);\t   // 如果value值\u003c=0，那么说明有进程因无法获取资源而阻塞，所以去阻塞队列唤醒一个\r\n}\r\n```\r\n\r\n需要注意的是**P、V操作具有严格的不可分割性**，有两层含义：\r\n\r\n+ 信号量是系统中的公共变量，对某一信号量的操作必须是互斥的；\r\n+ P、V操作是一对操作，若有对信号量S的P操作，那么必须也有对信号量S的V操作，反之亦然。\r\n\r\n那么，**\u003cu\u003e利用信号量实现互斥的方法\u003c/u\u003e**为：为临界区资源设一个信号量`mutex`，初值为`1`，将临界区置于`P(mutex)`和`V(mutex)`之间，`P(mutex)`和`V(mutex)`一定要成对出现在同一个进程中。伪代码描述为\r\n\r\n```\r\nsemaphore mutex;\r\nmutex = 1;\r\ncobegin\r\nprocess Pi() {\r\n    P(mutex);\r\n\t{对临界区的具体操作};\r\n\tV(mutex);\r\n}\r\ncoend\r\n```\r\n\r\n以上互斥为二元信号量，可以看出等同于显式锁的加锁与释放，即某进程在对共享变量进行操作时，需要执行P操作(等同于加锁)，操作完毕时需要执行V操作(等同于释放锁)。那么对于**\u003cu\u003e代表可用资源数目的一般信号量应该如何描述\u003c/u\u003e**呢？\r\n\r\n代表可用资源数目的一般信号量的P、V操作一般分散在各个进程中，以生产者-消费者为例，生产者每执行一次生产操作，对于代表缓冲区商品数目个数的信号量full来说就需要执行一次V操作，代表生产的可用资源数目加一，相对应地，对于代表商品缓冲区空缓冲区的个数的信号量empty来说，就需要执行一次P操作，含义为每生产一次空缓冲区数目减一。相对应的，消费者进程则是对full信号量执行P操作代表消费一次缓冲区数目减少一个，empty信号量执行V操作，代表消费一次，缓冲区空闲多一个。\r\n\r\n**\u003cp style=\"color:red\"\u003e总而言之，多进程环境下对于临界区的操作必须使用互斥信号量进行同步（参见伪代码描述），而对于代表可用资源数目的一般信号量，则由多进程相互配合完成。\u003c/p\u003e**\r\n\r\n**\u003cu\u003e拓展阅读：\u003c/u\u003e**\u003cp style=\"border:1px dotted black\"\u003e**P、V操作的物理意义**：在共享同一类资源的具有相互合作关系的进程之间，信号量的初值用来表示系统中同类资源的可用数目。因此当信号量S等于0时，表示没有空闲的该类资源可用；S \u003c 0时，其绝对值表示因请求该类资源而被阻塞的进程数，每执行一次P操作意味着请求分配一个单位的某类资源，因此描述为S = S - 1；若S \u003c 0表示已无该类资源可供分配，因此把该进程加入到与S相关的等待队列中。进程使用完某类资源后必须执行一次V操作，意味着释放一个单位的该类资源，因此描述为S = S + 1；若S \u003c= 0表示已有进程在等待该类资源，因此唤醒等待队列中的第一个或优先级最高的进程，允许其使用该类资源。\u003c/p\u003e\r\n\r\n## 五、利用信号量实现同步示例\r\n\r\n#### 5.1 哲学家进餐问题\r\n\r\n问题描述：有5个哲学家围坐在一张圆桌旁，桌面中央有一盘通心面，每个人面前有一只空盘子，每两个人之间放一把叉子。每个哲学家思考、饥饿、吃面。为了吃面，每个哲学家必须获得两把叉子，且每人只能从自己左边或右边取叉子，如图所示\r\n\r\n![哲学家进餐及引起思索](/images/article/zhexuejiajincan.jpg)\r\n\r\n解决方案：\r\n\r\n1. 至多允许4位哲学家同时去拿左边的叉子，保证至少有一位哲学家能够进餐；\r\n2. 规定奇数号哲学家先拿其左边的叉子，再拿其右边的叉子；偶数号哲学家先拿其右边的叉子，再拿其左边的叉子；\r\n3. 仅当哲学家的左右两把叉子均可使用时，才允许他进餐，否则一把叉子也不取。\r\n\r\n#### 5.2 生产者-消费者问题\r\n\r\n问题描述：指存在数据供给与需求的两类进程。实现生产者-消费者问题的数据结构设计如下：\r\n\r\n1. 含有n个缓冲区的公用缓冲池；\r\n2. 互斥信号量mutex：实现诸进程对缓冲池的互斥使用，一次仅允许一个进程读或写公用缓冲池，初值为1；\r\n3. 资源信号量empty：记录空缓冲区的个数，初值为n；\r\n4. 资源信号量full：记录满缓冲区的个数，初值为0.\r\n\r\n算法描述如下\r\n\r\n```\r\nitem B[k];\r\nsemaphore empty;\r\nempty = k;    // 可以使用的空缓冲区数目\r\nsemaphore full;\r\nfull = 0;    // 缓冲区内可以使用的产品数\r\nsemaphore mutex;\r\nmutex = 1;    // 互斥信号量\r\nint in = 0;    // 写缓冲区指针\r\nint out = 0;    // 读缓冲区指针\r\n\r\ncobegin\r\nprocess producer_i () {    // 生产者进程\r\n    while (true) {\r\n        produce();    // 先生产\r\n        P(empty);    // 由于生产了一个，那么可用缓冲区数目减一，对应P操作\r\n        P(mutex);    // 对临界区的操作必须互斥，执行mutex的P操作\r\n        append to B[in];\r\n        in = (in + 1) % k;\r\n        V(mutex);    // 执行mutex的V操作\r\n        V(full);    // 生产完毕，可使用产品数加一，对应V操作\r\n    }\r\n}\r\n\r\nprocess producer_i () {    // 消费者进程\r\n    while (true) {\r\n        P(full);    // 因为是消费，所以可用产品数减一，对应full的P操作\r\n        P(mutex);    // 临界区互斥操作，执行mutex的P操作\r\n        take() from B[out];\r\n        out = (out + 1) % k;\r\n        V(mutex);    // 执行mutex的V操作\r\n        V(empty);    // 因为消费了，所以空缓冲区数目加一，对应empty的V操作\r\n\t\tconsume();    // 消费\r\n    }\r\n}\r\ncoend\r\n```\r\n\r\n可见，每个进程中对互斥信号量mutex的操作是成对出现的，而对于一般信号量的操作是进程间成对出现的，代表资源的获取与释放（特指在生产者-消费者中）。\r\n\r\n#### 5.3 读者-写者问题\r\n\r\n问题描述：若干读者（Reader）进程和写者（Writer）进程共享一个数据文件，允许多个Reader进程同时读一个共享对象，但不允许一个Writer进程与其他Reader进程或者Writer进程同时访问共享对象。也就是说：\r\n\r\n1. 允许多个读者同时进行操作；\r\n2. 只允许一个写者执行写操作；\r\n3. 任一写者在完成写操作之前不允许其他读者或者写者访问共享文件；\r\n4. 写者执行写操作前，应让已有的写者和读者全部退出。\r\n\r\n算法分析如下：\r\n\r\n1. 互斥信号量writeblock：用于Reader与Writer、Writer与Writer之间的互斥，初值为1；\r\n2. readcount：登记正在读的进程的数目，初值为0；\r\n3. 互斥信号量mutex：用于Reader与Reader互斥访问整型量readcount，初值为1；\r\n\r\nreadcount情况分析：\r\n\r\n1. 如果readcount为0，则可能有也可能没有写者在写；\r\n2. 如果读者数目readcount不为0，则不会有写者在写，请求读的读者可以进行读操作；\r\n3. 如果读者数目readcount为0，又没有写者在写，则请求写的写者才可以进行写操作。\r\n\r\n算法描述如下：\r\n\r\n```\r\nint readcount = 0;\r\nsemaphore writeblock, mutex;\r\nwriteblock = 1;\r\nmutex = 1;\r\ncobegin\r\nprocess reader_i() {\r\n    P(mutex);    // 互斥操作，开始\r\n    readcount++;    // 由于是读操作，所以读进程数量加一\r\n    if (readcount == 1) P(writeblock);    // 如果读进程数量为1，即不为1，那么说明不会有写者在写，所以没必要加信号量，即下一步执行互斥信号量的V操作\r\n    V(mutex);    // 执行mutex的V操作\r\n    {具体读文件操作};    // 然后进行具体的读操作\r\n    P(mutex);    // 对共享变量readcount操作需要加信号量，因为每次读进程操作都会修改这个值，上面的代码也是同理\r\n    readcount--;    // 文件读完之后读进程数量减一\r\n    if(readcount == 0) V(writeblock);    // 如果减一后值为0，且当前进程是读者进程说明没有写者在写，所以执行writeblock的V操作，释放一个写者进程进行写操作\r\n    V(mutex);    // 互斥信号量成对出现，所以必须执行V操作\r\n}\r\n\r\n// 由于读操作没有涉及共享变量readcount，所以不用为共享变量readcount加信号量\r\nprocess writer_j() {\r\n    P(writeblock);    // 写进程执行写操作，需要向信号量申请，即执行P操作（信号量writeblock代表资源数目，不管是互斥信号量还是一般信号量都可以理解为资源数目）\r\n    {具体写文件操作};    // 申请到了，执行具体的写操作\r\n    V(writeblock);    // 写完后释放占用的资源，供其余进程申请\r\n}\r\ncoend\r\n```\r\n\r\n#### 5.4 睡眠理发师问题\r\n\r\n问题描述：理发店有一位理发师、一把理发椅和n把椅子供顾客等候理发休息。如果没有顾客，理发师便在理发椅上睡觉。某位顾客到来时，该顾客必须叫醒理发师。如果理发师正在理发时又有顾客到来，则如果有空椅子可坐，顾客就坐下来等待，否则离开。\r\n\r\n算法描述如下：\r\n\r\n```\r\nint waiting = 0;    // 等待的顾客数目，为共享变量\r\nint CHAIRS = N;    // 为顾客准备的椅子数目\r\nsemaphore customers, barbers, mutex;\r\ncustomers = 0, barbers = 0, mutex = 1;\r\ncobegin\r\nprocess barber() {\r\n    while (true) {\r\n        P(customers);    // 申请顾客（相当于加锁），如果没有顾客即申请不到，那么就阻塞即睡眠，不会再往下执行\r\n        P(mutex);    // 理发师要对共享变量操作，所以必须申请保护\r\n        waiting--;    // 理发一位，减一\r\n        V(barbers);    // 已经理发完了，所以解除理发师资源的占用，也就是可以为下一个理发了\r\n        V(mutex);    // 对共享变量的操作完毕，释放信号量占用\r\n        cut_hair();\r\n    }\r\n}\r\n\r\nprocess customer_i() {\r\n    P(mutex);    // 因为涉及对共享变量waiting的操作，所以需要申请资源，以便临界区保护\r\n    if (waiting \u003c CHAIRS) {    // 如果椅子没有坐满，那么就继续执行\r\n        waiting++;    // 等待的人数目加一\r\n        V(customers);    // 对代表顾客资源数目的信号量加一，代表多了一个顾客\r\n        V(mutex);    // 对临界区资源操作完毕，可以释放信号量\r\n        P(barbers);    // 顾客申请理发师，即执行P操作，如果申请不到则坐下来（阻塞），否则就理发\r\n        get_haircut();\r\n    } else V(mutex);    // 如果椅子满了，什么也不做（离开）\r\n}\r\ncoend\r\n```\r\n\r\n## 六、进程通信\r\n\r\n+ 共享变量\r\n+ 共享内存\r\n+ 消息传递通信机制\r\n+ 套接字通信机制：不同主机的进程实现通信的方式；\r\n+ 管道：是连接进程的一个共享文件，允许进程以先进先出的方式写入和读出数据，并对读写操作进行同步。\r\n\r\n## 七、死锁\r\n\r\n#### 7.1 死锁产生的必要条件\r\n\r\n1. 互斥条件：进程互斥使用资源，一旦某个资源被占用，则要使用该资源的进程必须等待；\r\n2. 占有和等待条件：进程申请新资源得不到满足而等待时，不释放已占用资源；\r\n3. 不剥夺条件：一个进程不能抢占其他进程占有的资源；\r\n4. 循环等待条件：存在一组进程循环等待资源的现象。\r\n\r\n#### 7.2 死锁防止\r\n\r\n只需要破坏上述条件即可，如下\r\n\r\n1. 破坏互斥条件：破坏互斥条件使资源可同时访问而不是互斥使用，对于进程同步来说，该条件不能破坏反而要加以保证；\r\n2. 破坏占有和等待条件：通过静态分配可以实现。静态分配指的是一个进程必须在执行前申请它所需要的全部资源，并且直到它需要的资源都得到满足后才开始执行；\r\n3. 破坏不剥夺条件：当进程在申请资源未得到的情况下，主动释放资源，然后去等待；\r\n4. 破坏循环等待条件：采用层次分配策略可以实现。层次分配策略指的是将资源分成多个层次，当进程得到某一层的某个资源后，它只能申请较高层次的资源。当进程要释放某层次的资源时，必须先释放占有的较高层次的资源。当进程得到某一层的一个资源后，它想申请该层的另一个资源时，必须先释放该层中的已占有资源。\r\n\r\n#### 7.3 银行家算法的基本思想\r\n\r\n1. 每个客户必须预先说明自己要求的最大资金量；\r\n2. 每个客户每次提出部分资金量申请和获得分配；\r\n3. 如果银行满足了客户对资金的最大需求量，则客户在资金运作后一定可以很快归还资金。。\r\n\r\n采用银行家算法思想考虑死锁问题时，操作系统对应银行家，操作系统管理的资源对应周转资金，进程对应要求贷款的客户。\r\n\r\n银行家算法的缺点是，很难在运行前知道其所需的最大资源量，而且算法要求系统中的进程必须是无关的，相互间没有同步要求，进程的个数和分配的资源数目应该是固定的。这些要求事先难以满足，因此该算法缺乏实用价值。\r\n\r\n#### 7.4 死锁的检测与解除\r\n\r\n解决死锁问题的一个途径是死锁的检测与解除，这种方法对资源的分配不加任何限制，也不采取死锁避免措施（即不采取上述四个破坏条件），但系统定时运行一个“死锁检测程序”，判断系统内是否出现死锁，如果出现，则采取措施解除它。\r\n\r\n死锁的解除方法如下\r\n\r\n1. 立即结束所有进程的执行，并重启操作系统；\r\n2. 剥夺陷于死锁的进程占用的资源，但不撤销它，直到死锁解除；\r\n3. 撤销陷于死锁的所有进程，解除死锁以继续运行；\r\n4. 逐个撤销陷于死锁的进程，回收其资源，直至死锁解除；\r\n5. 根据系统保存的检查点，使所有进程回退，直到足以解除死锁；\r\n6. 当检测到死锁时，如果存在某些未卷入死锁的进程，而这些进程随着建立一些新的抑制进程能执行到结束，则它们可能释放足够的资源来解除死锁。\r\n\r\n\u003e 参考《操作系统原理与Linux实践教程》 / 申丰山 王黎明 编著","cover":"/images/os.jpg","link":"principle-basis-of-operating-system.html","preview":"\u003cp\u003e进程的定义、特征、模型；进程控制块（PCB）的作用、信息及组织方式；进程的控制；进程对临界资源访问的互斥性与进程间的同步；利用信号量实现同步示例；进程通信；死锁。\u003c/p\u003e\n","title":"计算机操作系统原理总结(一)——处理器管理"},{"content":"\r\n\r\n## 一、类-xml方式\r\n\r\n这种方式是先编写普通的Java类，然后在Spring配置文件中通过`\u003cbean\u003e`标签来定义bean，最后就可以通过IoC容器取得Bean实例，如下\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\npublic interface SpringBean {\r\n\r\n\tpublic abstract void sayHello();\r\n\t\r\n}\r\n```\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\npublic class SpringBeanImpl implements SpringBean {\r\n\r\n\t@Override\r\n\tpublic void sayHello() {\r\n\t\tSystem.out.println(\"hello, world\");\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringBeanMain {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tApplicationContext ac = new ClassPathXmlApplicationContext(\"context.xml\");\r\n\t\tSpringBean sb = ac.getBean(\"springBean\", SpringBean.class);\r\n\t\tsb.sayHello();\r\n\t}\r\n\r\n}\r\n```\r\n\r\n配置文件为(一定要放在src目录下)\r\n\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n    http://www.springframework.org/schema/context\r\n    http://www.springframework.org/schema/context/spring-context-3.0.xsd\"\u003e\r\n  \u003c!-- \r\n  \u003ccontext:component-scan base-package=\"spring.feily.tech\"/\u003e\r\n  \u003ccontext:annotationconfig/\u003e\r\n   --\u003e\r\n  \u003cbean id=\"springBean\" class=\"spring.feily.tech.SpringBeanImpl\"\u003e\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n\r\n运行结果为\r\n\r\n```\r\n五月 19, 2019 4:00:35 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh\r\n信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@b1a58a3: startup date [Sun May 19 16:00:35 CST 2019]; root of context hierarchy\r\n五月 19, 2019 4:00:35 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\r\n信息: Loading XML bean definitions from class path resource [context.xml]\r\nhello, world\r\n```\r\n\r\n## 二、注解-xml方式\r\n\r\n这种办法是给类加上注解，只是配置文件不需要`\u003cbean\u003e`标签，只需要打开注解和配置扫描路径就好了，IoC取得bean对象的代码不变，如下\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\npublic interface SpringBean {\r\n\r\n\tpublic abstract void sayHello();\r\n\t\r\n}\r\n```\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"springBean\")\r\npublic class SpringBeanImpl implements SpringBean {\r\n\r\n\t@Override\r\n\tpublic void sayHello() {\r\n\t\tSystem.out.println(\"hello, world\");\r\n\t}\r\n\t\r\n}\r\n```\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringBeanMain {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tApplicationContext ac = new ClassPathXmlApplicationContext(\"context.xml\");\r\n\t\tSpringBean sb = ac.getBean(\"springBean\", SpringBean.class);\r\n\t\tsb.sayHello();\r\n\t}\r\n\r\n}\r\n\r\n```\r\n\r\n配置文件为\r\n\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\r\n    http://www.springframework.org/schema/context\r\n    http://www.springframework.org/schema/context/spring-context.xsd\"\u003e\r\n  \u003ccontext:component-scan base-package=\"spring.feily.tech\"/\u003e\r\n  \u003ccontext:annotation-config/\u003e\r\n\u003c/beans\u003e\r\n```\r\n\r\n运行结果为\r\n\r\n```\r\n五月 19, 2019 4:23:25 下午 org.springframework.context.support.ClassPathXmlApplicationContext prepareRefresh\r\n信息: Refreshing org.springframework.context.support.ClassPathXmlApplicationContext@b1a58a3: startup date [Sun May 19 16:23:25 CST 2019]; root of context hierarchy\r\n五月 19, 2019 4:23:25 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions\r\n信息: Loading XML bean definitions from class path resource [context.xml]\r\nhello, world\r\n```\r\n\r\n### 三、注解-配置类方式\r\n\r\n这种办法是用一个被`@Configurator`和`ComponentScan(basePackages = \"\")`修饰的配置类来替代前两种办法中的xml配置文件的作用，IoC取得bean对象的方式也相应地变成了`AnnotationConfigApplicationContext`,如下\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\npublic interface SpringBean {\r\n\r\n\tpublic abstract void sayHello();\r\n\t\r\n}\r\n```\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component(\"springBean\")\r\npublic class SpringBeanImpl implements SpringBean {\r\n\r\n\t@Override\r\n\tpublic void sayHello() {\r\n\t\tSystem.out.println(\"hello, world\");\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\r\n\r\npublic class SpringBeanMain {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfigurator.class);\r\n\t\tSpringBean sb = ac.getBean(\"springBean\", SpringBean.class);\r\n\t\tsb.sayHello();\r\n\t}\r\n\r\n}\r\n```\r\n\r\n配置类为\r\n\r\n```\r\npackage spring.feily.tech;\r\n\r\nimport org.springframework.context.annotation.ComponentScan;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\n@ComponentScan(basePackages = \"spring.feily.tech\")\r\npublic class SpringConfigurator {\r\n\r\n}\r\n```\r\n\r\n运行结果为\r\n\r\n```\r\n五月 19, 2019 4:30:15 下午 org.springframework.context.annotation.AnnotationConfigApplicationContext prepareRefresh\r\n信息: Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@5fa7e7ff: startup date [Sun May 19 16:30:15 CST 2019]; root of context hierarchy\r\nhello, world\r\n```","cover":"/images/Spring-Framework.jpg","link":"configuration-of-beans-in-spring.html","preview":"\u003cp\u003eSpring中的Bean配置方式，包含类-xml配置、注解-xml配置、注解-配置类配置。\u003c/p\u003e\n","title":"Spring中Bean的配置方式"},{"content":"\r\n\r\n堆中几乎存放着Java中的所有对象实例，垃圾收集器在对堆进行回收前，要做的一件事情就是判断这些对象有哪些还“或者”，哪些已经“死去（即不可能再被任何途径使用的对象）”。然后对死去的对象进行垃圾清理完成内存回收。\r\n\r\n## 一、对象是死是活？\r\n\r\n### 1.1 引用计数法\r\n\r\n引用计数法（Reference Counting）是判断对象是否存活的一个办法，具体做法是：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减一；任何时候计数器都为0的对象就是不可能再被使用的。\r\n\r\n这种办法的优点是实现简单，但是缺点是难以解决对象之间的相互循环引用问题。例如\r\n\r\n```\r\nobjA.instance = objB;\r\nobjB.instance = objA'\r\n```\r\n\r\n对象objA与objB相互引用对方，使得二者的引用计数器不为0.于是无法通知GC收集器回收它们。\r\n\r\n### 1.2 根搜索算法\r\n\r\n在主流的商用程序语言中，都是使用根搜索算法（GC Roots Tracing）判断对象是否存活的。这个算法的基本思路是通过一系列名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链时或不可达时，则证明该对象是不可用的，它们会被判定为可回收的对象。这里的对象指的是\r\n\r\n+ 虚拟机栈（栈帧中的本地变量表）中引用的对象，即堆区中的对象；\r\n+ 方法区中类静态属性引用的对象；\r\n+ 方法区中的常量引用的对象；\r\n+ 本地方法栈JNI（即一般所说的Native方法）的引用的对象。\r\n\r\n![](/images/article/gc-roots.png)\r\n\r\n### 1.3 再谈引用\r\n\r\n无论是通过引用计数算法判断对象的引用数量，还是通过根搜索算法判断对象的引用链是否可达，可见，判定对象是否存活都与“引用有关”。在JDK1.2之前，Java中的引用的定义很传统：如果reference类型的护具中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。但是这种定义很简单纯粹，只有被引用雨没有被引用两种状态，对于一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保存在内存之中；如果内存在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。\r\n\r\n在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。\r\n\r\n+ 强引用就是指程序代码之中普遍存在的，类似于`Object obj = new Object()`之类的引用，只要强引用还存在，那么垃圾收集器永远都不会回收；\r\n+ 软引用是用来描述一些还有用，但并非必需的对象。对于软引用的对象，在系统将要发生内存溢出异常之前，将会把这些对象列入垃圾回收范围之内并进行第二次回收。如果这次回收还是没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了`SoftReference`类来实现软引用.\r\n+ 弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象（这也是区别于软引用的地方）。在JDK1.2之后，提供了`WeakReference`类来实现弱引用；\r\n+ 虚引用也成为幽灵引用或者幻影引用，是最弱的的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了`PhantomReference`类来实现虚引用。\r\n\r\n### 1.4 生存还是死亡\r\n\r\n在根搜素算法中，不可达的对象并非非死不可，这时候它们只是进入了缓刑阶段，要真正宣告一个对象的死亡，至少需要两次标记过程：如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那么它将会被标记并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法，当对象没有覆盖这个方法时或者该方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。\r\n\r\n如果这个对象被判定为有必要执行`finalize()`方法，那么这个对象将会被放置在一个名为`F-Queue`的队列之中，并在稍后由一条由虚拟机自动建立的、低优先级的`Finalizer`线程去执行。这里所谓的执行是指虚拟机会触发这个方法但并不承诺会等待它运行结束。这样做的原因是，如果一个对象在`Finalize()`方法中执行缓慢或者发生了死循环，将很可能会导致`F-Queue`队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。\r\n\r\n`finalize()`方法是对象逃脱死亡命运的最后一次机会，稍后GC将对`F-Queue`中的对象进行第二次小规模标记，如果对象要在`finalize()`中成功拯救自己，只需要重新与引用链上的任何一个对象建立关联即可。譬如，把自己(this关键字)赋给某个类变量或对象的成员变量（随便一个类都可以，包括自己），那么在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那么就真的离死不远了。示例如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class FinalizeEscapeGC {\r\n\r\n    public static FinalizeEscapeGC SAVE_HOOK = null;\r\n    \r\n    public void isLive() {\r\n        System.out.println(\"yes, i am still live.\");\r\n    }\r\n    \r\n    @Override\r\n    protected void finalize() throws Throwable {\r\n        super.finalize();\r\n        System.out.println(\"finalize method executed.\");\r\n        // 把自己赋给FinalizeEscapeGC型对象SAVE_HOOK,从而拯救自己\r\n        FinalizeEscapeGC.SAVE_HOOK = this;\r\n    }\r\n    public static void main(String[] args) throws InterruptedException {\r\n        SAVE_HOOK = new FinalizeEscapeGC();\r\n        \r\n        // 对象第一次成功拯救自己\r\n        SAVE_HOOK = null;\r\n        System.gc();\r\n        // 因为Finalizer方法优先级很低，主线程暂停0.5s，以等待它\r\n        TimeUnit.SECONDS.sleep(5);\r\n        if (SAVE_HOOK != null) {\r\n            SAVE_HOOK.isLive();\r\n        } else {\r\n            System.out.println(\"no, i am dead.\");\r\n        }\r\n        \r\n        // 下面这段代码与上面的完全相同，但是却拯救失败了\r\n        SAVE_HOOK = null;\r\n        System.gc();\r\n        // 因为Finalizer方法优先级很低，主线程暂停0.5s，以等待它\r\n        TimeUnit.SECONDS.sleep(5);\r\n        if (SAVE_HOOK != null) {\r\n            SAVE_HOOK.isLive();\r\n        } else {\r\n            System.out.println(\"no, i am dead.\");\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nfinalize method executed.\r\nyes, i am still live.\r\nno, i am dead.\r\n```\r\n\r\n可以看到，SAVE_HOOK对象的`finalize()`方法确实被GC收集器触发过，并且在被收集之前成功逃脱了。\r\n\r\n第二次执行失败是因为`finalize()`方法只会被系统自动执行一次，第二次无效，所以自救失败了。\r\n\r\n### 1.5 回收方法区\r\n\r\n方法区并不是没有垃圾收集，而是方法区很少发生垃圾收集行为。在堆中，尤其是新生代中，常规应用进行一次垃圾收集一般可以回收70% - 95%的空间，而方法区(永久代)的垃圾收集效率远低于此。\r\n\r\n方法区的垃圾收集主要回收两部分内容：废弃常量和无用的类。\r\n\r\n对于废弃常量的判断和判断堆中的对象非常类似，以回收常量池中的字面量为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有方法引用这个字面量，如果在这个时候发生垃圾收集，而且有必要的话，该常量就会被请出常量池。常量池中的其它类（接口）、方法、字段的符号引用也与此类似。\r\n\r\n而对于一个类是否无用的判断需要同时满足下面三个条件：\r\n\r\n+ 该类的所有的实例都已经被回收，即Java堆中不存在该类的任何实例；\r\n+ 加载该类的`ClassLoader`已经被回收；\r\n+ 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\r\n\r\n虚拟机可以对满足以上3个条件的无用类进行回收，但并非和对象一样，无用了必然会被回收。\r\n\r\n## 二、垃圾收集算法\r\n\r\n### 2.1 标记-清除算法（Mark-Sweep）\r\n\r\n该算法分为“标记”和“清除两个阶段”，首先标记出所有需要回收的对象，在标记完成后统一回收。优点是实现简单，但是缺点有两个，一个事效率不高，另一个是会产生大量不连续的内部碎片。\r\n\r\n### 2.2 复制算法（Copying）\r\n\r\n该算法将可用内存划分为大小相等的两块，一次只用其中的一块，当这一块的内存快用完了，就将存活的对象复制到另一块上，然后一次性清除原来的一整块内存。这样使得每次都是对其中的一块内存进行内存回收，内存分配时不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可。这种算法的代价是内存缩小为原来的一半。\r\n\r\n现在的商业虚拟机都采用这种收集算法来回收**新生代**，但是并非按照1：1的比例来划分空间，而是将内存划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Suivivor。当回收时，将Eden和Survivor中还存活的对象一次性地拷贝到另外一块Survivor熵，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80% + 10%），每次只有10%的内存会被浪费。\r\n\r\n## 2.3 标记-整理算法（Mark-Compact）\r\n\r\n复制算法在对象存活率较高时就需要执行较多的复制操作，效率会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，因此老年代一般不直接使用这种算法。\r\n\r\n根据老年代的特点，使用的一般是标记-整理算法，标记过程仍然与标记-清除算法一样，但是后续步骤不死直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后再清理掉端边界之外的内存。\r\n\r\n### 2.4 分代收集算法（Generational Collection）\r\n\r\n当前商业虚拟机的垃圾回收都是用收集算法，这种算法的基本思想是根据独享存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都会有大批对象死去，只有少量存活，那就选择复制算法，只需要付出少量存活对象的复制成本就可以完成垃圾收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-整理或者标记-清除算法来进行回收。\r\n\r\n## 三、垃圾收集器\r\n\r\n+ 新生代垃圾收集器（采用复制算法）\r\n  + Serial收集器：最基本、最悠久的收集器，是一个单线程的收集器，单线程指的是在进行垃圾收集时，必须暂停掉其他所有的工作线程，直到它收集结束；\r\n  + ParNew收集器：Serial的多线程版本，除了使用多线程进行垃圾回收之外，其余行为与Serial完全一样；\r\n  + Parallel Scavenge收集器：该收集器也是采用复制算法的收集器，也是并行的多线程收集器，但是关注点不一样，其目的是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+ 垃圾收集时间））。也被称为“吞吐量优先”收集器。\r\n+ 老年代垃圾收集器\r\n  + Serial Old收集器：是Serial的老年代版本，即使一个单线程收集器，使用“标记-整理算法”；\r\n  + Parallel Old收集器：是Parallel Scavenge的老年代版本，使用多线程和“标记-整理”算法；\r\n  + CMS（Cocurrent Mark Sweep）收集器：是一种以获取最短回收停顿时间为目标的收集器，采用“标记-清除”算法；\r\n  + G1（Garbage First）收集器：是当前收集器技术发展的最前沿成果，与CMS相比有两个显著改进，一个是采用“标记-整理”算法来实现的收集器；另一个是可以非常精确的控制停顿，即能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾回收上的时间不得超过N毫秒，这几乎已经是实时Java的垃圾收集器特征了。\r\n  \r\n## 四、内存分配与回收策略\r\n\r\n+ 对象优先在Eden分配：大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC；\r\n+ 大对象直接进老年代；\r\n+ 长期存活的对象将进入老年代；\r\n+ 动态对象年龄判定：为了能更好的适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到maxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，那么年龄大于或等于该年龄的对象就可以直接进入老年代。","cover":"/images/jvm-gc.PNG","link":"garbage-collector-and-memory-allocation-strategy.html","preview":"\u003cp\u003e堆中几乎存放着Java中的所有对象实例，垃圾收集器在对堆进行回收前，要做的一件事情就是判断这些对象有哪些还“或者”，哪些已经“死去（即不可能再被任何途径使用的对象）”。然后对死去的对象进行垃圾清理完成内存回收。\u003c/p\u003e\n","title":"垃圾收集器与内存分配策略"},{"content":"\r\n\r\n**JVM执行引擎在执行方法字节码的之前最重要的一个步骤就是方法调用。方法调用阶段唯一的任务就是确定被调用方法的版本，即调用哪一个方法，并未涉及方法的运行过程。**\r\n\r\n在程序运行时，进行方法调用是最普遍、最频繁的操作，但是Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在Class文件中存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（相当于直接引用）。这个特性给Java带来了更强大的动态拓展能力，但也使得Java方法的调用过程变得相对复杂起来，需要在类加载期间甚至到运行期间才能确定目标方法的直接引用。\r\n\r\n如果类不存在多个版本的方法，那么在解析阶段就可以直接将符号引用替换为直接引用。而如果一个类如果存在重载方法或者方法重写，由于运行期传入参数类型的不同等原因，只能在运行期确定方法的版本。方法调用包括两个内容：解析与分派。\r\n\r\n## 一、解析\r\n\r\n如果方法在程序真正运行之前就有一个确定的调用版本，并且这个方法的调用版本在运行期是不可变的，换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。\r\n\r\n在Java中，符合“编译期可知，运行期不可变”这个要求的方法主要有静态方法和私有方法两大类，前者直接与类型关联，后者在外部不可被访问，这两种方法都不可能通过继承或别的方式重写出其他版本，因此他们都适合在类加载阶段进行解析。\r\n\r\n与之相对应，在Java虚拟机中提供了四条方法调用字节码指令，分别是\r\n\r\n+ `invokestatic`：调用静态方法；\r\n+ `invokespecial`：调用实例构造器`\u003cinit\u003e`方法、私有方法和父类方法；\r\n+ `invokevirtual`：调用所有的虚方法；\r\n+ `invokeinterface`：调用接口方法，**会在运行时再确定一个实现此接口的对象。**\r\n\r\n**只要能被`invokestatic`和`invokespecial`指令调用的方法，都可以在解析阶段确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器和父类方法四类，它们在类加载的时候就会把符号引用解析为该方法的直接引用（从而在运行期间方法调用的时候根据调用该方法的对象在堆内存中的句柄地址获得该对象所属类型的该方法的直接引用，直接就可以获取到方法的字节码指令，为方法执行奠定基础）。这些方法可以称为非虚方法，与之相反，其他方法称为虚方法（除过final方法）。**\r\n\r\n**简言之，方法调用就是将源码中的符号引用替换为字节码指令中的直接引用的过程，目的是为方法执行做前期准备，对于非虚方法（包括静态方法、私有方法、实例构造器和父类方法）而言，可以在类加载阶段的解析阶段直接替换为直接引用，因为非虚方法的方法版本唯一，不会在运行期变化，所以适合在解析阶段就替换直接引用。**\r\n\r\n## 二、分派\r\n\r\n而对于方法版本不唯一的方法而言，无法在类加载的解析期间进行直接引用的替换，因为在运行期可能根据传入方法的实际参数类型的变化或者转型的原因造成方法版本的动态变化(即父类和子类的方法会根据实际情况而选择性调用)，那么只能在运期间选择正确的目标方法进行直接引用的替换。\r\n\r\n### 2.1 静态分派\r\n\r\n可以简单的理解为静态分派是针对方法重载而言的，我们知道，方法重载的情况下，方法调用的选择是根据传入的参数的实际类型进行逐一匹配的，哪个匹配度最高那么就会调用哪个方法，即谁的匹配度最高就将虚拟机栈中即将执行的方法的引用指向谁(在常量池中)。这叫做静态分派。静态分派发生在编译阶段，最典型的应用就是方法重载。\r\n\r\n### 2.2 动态分派\r\n\r\n也可以简单的理解为动态分派是针对方法重写而言的，我们仍然知道，方法重写的情况下，`invokevirtual`指令调用方法确定方法版本的过程如下\r\n\r\n+ 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C；\r\n+ 如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回`java.lang.IllegalAccessError`异常；\r\n+ 否则，按照继承关系从下往上依次对C的各个父类进行上一步的搜索和验证过程；\r\n+ 如果始终没有找到合适的方法，则抛出`java.lang.AbstractMethodError`异常。\r\n\r\n综上，可见`invokevirtual`指令执行的第一步就是在运行期间确定接收者(调用的方法的接收者，比如`obj.method()`的接收者就是`obj`)的实际类型，从而就可以从该接收者的堆句柄中获得所属类(方法)的引用，这也是方法重写的本质。这种在运行期间根据实际类型确定方法执行版本的分配过程称为动态分派。\r\n\r\n### 2.3 单分派与多分派\r\n\r\n方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种，单分派是根据一个宗量对目标方法进行选择，多分派是根据多个宗量对目标方法进行选择。直接给出结论，如下\r\n\r\n+ Java语言的静态分派属于多分派模型，因为重载的方法只有参数类型不同，所以有多个宗量，那么就属于多分派模型；\r\n+ Java语言的动态分派属于单分派模型，因为方法的重写所有都是相同的（包括参数类型），即有一个宗量，那么自然属于单分派模型。\r\n\r\n**综上，对于非虚方法（包括静态方法、私有方法、实例构造器和父类方法），因为方法的唯一性，即不可能被重写或重载，那么就会在类加载的解析阶段直接完成引用替换，从而直接确定方法的调用版本；但是对于虚方法（可以理解为飘渺不定，不能简单的确定）而言，方法的重载是同一个对象的方法重载，因此可以确定该对象所属类型的直接引用（那么自然也能确定方法的直接引用），方法版本的选择是通过参数匹配实现的；对于方法的重写而言，是不同对象的同一种方法，那么方法版本的确定就要根据对象的实际类型来确定到底是哪一个对象从而确定所属的类（与方法）的直接引用。**","cover":"/images/jvm_method_stack.jpg","link":"jvm-method-call.html","preview":"\u003cp\u003eJVM执行引擎在执行方法字节码的之前最重要的一个步骤就是方法调用。方法调用阶段唯一的任务就是确定被调用方法的版本，即调用哪一个方法，并未涉及方法的运行过程。\u003c/p\u003e\n","title":"方法调用"},{"content":"\r\n\r\n**先总结一下，JVM通过执行方法的字节码指令来对内存(包括运行时的方法区、堆、栈)中数据进行操作，这个操作是在栈（栈帧的操作数栈）中进行的，栈中所需要的局部变量与方法参数存储在局部变量表中、类静态变量以及常量存储在方法区中、实例变量存储在堆中，对局部变量表数据的提取与存储很容易理解因为每个栈帧都有自己的局部变量表，对方法区以及堆的数据的提取与存储是通过对象句柄(如果使用的是句柄方式访问对象的话)来访问堆中的实例数据以及方法区中对象对引发的类型数据的。即句柄保存了到对象实例以及对象类型数据的指针。而这个句柄就是某对象调用方法时将自身作为this参数传递进入方法参数列表的一个隐含参数，会被映射到该栈帧的局部变量表的第一个Slot中。**\r\n\r\n这部分内容其实之前在[Class文件结构](https://doc.feily.tech/class-file-structure.html) 一文中的方法表集合中的属性表集合中的Code数据项中已经描述过了。不再赘述。","cover":"/images/jvm_method_stack.jpg","link":"stack-based-interpreter-execution-process.html","preview":"\u003cp\u003e先总结一下，JVM通过执行方法的字节码指令来对内存(包括运行时的方法区、堆、栈)中数据进行操作，这个操作是在栈（栈帧的操作数栈）中进行的，栈中所需要的局部变量与方法参数存储在局部变量表中、类静态变量以及常量存储在方法区中、实例变量存储在堆中，对局部变量表数据的提取与存储很容易理解因为每个栈帧都有自己的局部变量表，对方法区以及堆的数据的提取与存储是通过对象句柄(如果使用的是句柄方式访问对象的话)来访问堆中的实例数据以及方法区中对象对引发的类型数据的。即句柄保存了到对象实例以及对象类型数据的指针。而这个句柄就是某对象调用方法时将自身作为this参数传递进入方法参数列表的一个隐含参数，会被映射到该栈帧的局部变量表的第一个Slot中。\u003c/p\u003e\n","title":"基于栈的解释器执行过程"},{"content":"\r\n\r\n栈帧(Stack Frame)是用于支持虚拟机方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧中存储了方法的局部变量表、操作数栈、动态链接和方法返回出口等信息。每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。\r\n\r\n每一个栈帧都包括了局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性中，因此一个栈帧需要分配多少内存，不会受到程序运行期间变量数据的影响(Slot因作用域的变化可以重用)，而仅仅取决于具体的虚拟机实现。\r\n\r\n一个线程中方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为**当前栈帧（Current Stack Frame）**，这个栈帧所关联的方法称为当前方法（Current Method）。**执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。**\r\n\r\n![](/images/JVM_Internal_Architecture.png)\r\n\r\n## 一、局部变量表\r\n\r\n局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的最大局部变量表的容量。\r\n\r\n局部变量表的容量以变量槽（Variable Slot）为最小单位，虚拟机规范中并没有明确指明一个Slot应占用的内存空间的大小，只是导向性地说明了每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference（对象的引用）或returnAddress（是为字节码指令jsr、jsr_w、ret服务的，指向了一条字节码指令的地址，即javap中方法的Code属性字节码指令开头的数字）类型的数据，即一个Slot应该能存放一个32位以内的数据类型，对于32位之外的数据类型double、long（均为64位）使用连续的两个Slot存储。\r\n\r\n虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始到局部变量表最大的Slot数量。如果是32位数据类型的变量，索引n就代表了使用第n个Slot，如果是64位数据类型的变量，则说明要使用局部变量表第n和第n + 1两个Slot。\r\n\r\n在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果是实例方法，那么局部变量表中第0位索引即第一个Slot中存放的是用于传递方法所属对象实例的引用，这样的话就可以在该方法中通过this关键字来访问这个方法所属对象的实例变量(因为实例变量是属于某个对象的，该类的对象可能有多个，但是方法是类层面的，方法可能涉及对实例变量的操作，所以调用该类的方法必须通过this关键字指明该方法所属对象的引用，这样就可以拿到该对象的实例变量，**具体而言，方法是通过`obj.method()`的形式调用的，这样就可以在调用过程中直接将对象obj的堆句柄(或地址)通过一个隐含的参数this传递给method方法，这个this可以理解为方法参数列表隐藏的一个值，然后该方法就会将this传递给局部变量表中的第一个Slot(索引为0)。这样的解释也是有依据的，因为即使方法参数列表没有参数，那么该方法(方法表集合中的属性表集合中的Code属性)的数据项`args_size`仍然为1，代表的就是隐含的this**)，其余参数则按照参数表的顺序来排列，占用从1(索引)开始的局部变量表的Slot，参数表分配完毕后，再根据方法体内部定义的变量 顺序和作用域分配其余的Slot。\r\n\r\n局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前PC计数器的值已经超出了某个变量的作用域，那么这个变量对应的Slot就可以分配给其它变量使用。这样设计不仅仅是为了节省栈空间，在某些情况下Slot的复用会直接影响系统的垃圾收集行为。\r\n\r\n## 二、操作数栈\r\n\r\n操作数栈也常被称为操作栈，是一个后进先出的数据结构。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到了Class文件的方法表集合的属性表集合的Code属性max_stacks数据项中。操作数栈中的每个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位的则为2.在方法执行的任何时候，操作数栈的深度都不会超过在max_stacks数据项中设定的最大值。\r\n\r\n**当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，即入栈出栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的。**\r\n\r\n操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。\r\n\r\n另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的。但是大多数虚拟机实现里都会做一些优化处理，令两个栈出现一部分重叠，让下面的栈帧的部分操作数栈与上面栈帧的部分操作数栈的部分局部变量表重叠在一起，这样在进行方法调用时就可以共用一部分数据，就无须进行额外的参数复制传递了。\r\n\r\n## 三、动态连接\r\n\r\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存有大量的符号引用(算是方法名)，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用(算是方法名)一部分会在**类加载阶段或第一次使用的时候**转化为直接引用，这种转化称为静态解析。另外一部分将会**在每一次的运行期间**转化为直接引用，这部分称为动态连接。关于这两个链接会在《方法调用》一文中进行阐述。\r\n\r\n## 四、方法返回地址\r\n\r\n当一个方法被执行时，有两种方式退出这个方法。\r\n\r\n+ 第一种是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。\r\n\r\n+ 另一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。**一个方法是用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。**\r\n\r\n无论以何种方式退出，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。**一般来说，方法正常退出时，调用者的PC计数器的值就可以作为被调用者（当前栈帧）的方法返回地址。而方法异常退出时，返回地址是需要异常处理器表来确定的，栈帧中一般不会保存这部分信息。**\r\n\r\n方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中（因为调用者调用该方法的目的就是获得返回值），调整PC计数器的值以指向方法调用指令后面的一条指令(即调用者开始执行下一条指令)。\r\n\r\n## 五、附加信息\r\n\r\n虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。","cover":"/images/JVM_Internal_Architecture.png","link":"runtime-stack-frame-structure.html","preview":"\u003cp\u003e栈帧(Stack Frame)是用于支持虚拟机方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧中存储了方法的局部变量表、操作数栈、动态链接和方法返回出口等信息。每一个方法从调用开始到执行完成的过程，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。\u003c/p\u003e\n","title":"JVM运行时栈帧结构"},{"content":"\r\n\r\nJava虚拟机在执行Java程序过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域各有用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。Jva虚拟机所管理的内存区域将会包括以下几个运行时数据区域：\r\n\r\n![](/images/jvm-runtime.jpg)\r\n\r\n## 一、程序计数器\r\n\r\n程序计数器（Program Counter Register）是一小块内存空间，它的作用可以看作**当前线程所执行字节码的行号指示器。**在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器值来选取下一条需要执行的字节码指令，分支、循环、跳转和异常处理、线程恢复等基础功能也都是依赖这个计数器完成的，即改变计数器的行号，从而实现特定的功能。\r\n\r\n由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(或者多核处理器的一个核心)只会执行一条线程中的字节码指令。因此，为了多线程情况下每个线程都能在运行时恢复到正确的执行位置，各条线程都需要一个独立的程序计数器，各个线程之间的程序计数器互不影响，独立存储。即**程序计数器是线程私有的内存。**\r\n\r\n如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这个计数器值则为空(Undefined)。此内存区域也是唯一一个在Java虚拟机规范中没有规定任何`OutOfMemoryError`情况的区域。\r\n\r\n## 二、Java虚拟机栈\r\n\r\n与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的。在[《Class文件结构》](https://doc.feily.tech/class-file-structure.html)中已经接触过了，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。**每个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程，而一个栈帧(方法)内部的字节码指令的操作也是基于栈的(操作数栈).**\r\n\r\n局部变量表中存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置，也就是对对象访问的两种主流方式：**使用句柄和直接指针**）和returnAddress类型（指向了一条字节码指令的地址）。\r\n\r\n其中64位长度的double和long类型的数据将会占用2个局部变量空间(Slot)，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配(Class文件结构中，方法表集合中的属性表集合中的Code属性中就有栈深度和变量表大小，这在编译期间就会确定下来，当调用一个方法，虚拟机栈就会读取相应的数据从而创建对应大小的操作数栈和局部变量表)，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间完全是确定的，在方法运行期间不会改变局部变量表的大小。\r\n\r\n该区域存在两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常；如果虚拟机可以动态拓展，当拓展无法申请到足够的内存时会抛出`OutOfMemoryError`异常。\r\n\r\n## 三、本地方法栈\r\n\r\n本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法(即字节码)服务，而本地方法栈则是为虚拟机使用到的Native方法服务。本地方法栈也会抛出`StackOverflowError`和`OutOfMemoryError`异常。\r\n\r\n## 四、Java堆\r\n\r\n对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域（即多线程环境下，堆中的对象(句柄)可能会被多个线程持有），在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配的。这一点在Java虚拟机规范中的描述是：所有的对象实例和数组都要在堆上分配。但是随着JIT编译器的发展与逃逸分析技术的成熟，所有的对象分配在堆上也渐渐变得不再那么绝对。\r\n\r\nJava堆是垃圾收集器管理的主要区域，因此很多时候被称为“GC堆”（Garbage Collected Heap）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer, TLAB）。**不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的仍然是对象实例，进一步划分的目的是更好更快的回收内存。**\r\n\r\n根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，既可以实现成固定大小的，也可以是可拓展的，不过当前主流的虚拟机都是按照可拓展来实现的（通过`-Xmx`和`-Xms`控制）。如果堆中没有内存满足实例分配，并且堆也无法再拓展时，将会抛出OutOfMemoryError异常。\r\n\r\n## 五、方法区\r\n\r\n方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却又一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。\r\n\r\nJava虚拟机对这个区域的限制非常宽松，除了和Java对一样不需要连续的内存和可以选择固定大小或者可拓展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少见的。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。\r\n\r\n根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出`OutOfMemoryError`异常。\r\n\r\n## 六、运行时常量池\r\n\r\n运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池（Constant Pool Table），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。\r\n\r\nJava虚拟机对Class文件的每一部分的格式都有严格的规定，每一字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域\r\n\r\n运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性。Java语言并不要求常量一定只能在编译期间产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的`intern()`方法。\r\n\r\n由于运行时常量池是方法区的一部分，那么当常量池无法再申请到内存时会抛出`OutOfMemoryError`异常。\r\n\r\n## 七、直接内存\r\n\r\n直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也有可能导致`OutOfMemoryError`异常出现。\r\n\r\n在JDK1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用来进行操作。这样能在一些场景中提高性能，因为避免了在Java堆和Native堆中来回复制数据(因为是通过指针来引用的)。\r\n\r\n本机直接内存的分配不会受到Java堆大小的限制，但是会受到本机总内存（包括RAM及SWAP区或者分页文件）的大小及处理器寻址空间的限制。当该区域动态拓展时超过物理内存的限制时将会抛出`OutOfMemoryError`异常。","cover":"/images/jvm-runtime.jpg","link":"jvm-runtime-data-area.html","preview":"\u003cp\u003eJava虚拟机在执行Java程序过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域各有用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。\u003c/p\u003e\n","title":"JVM运行时数据区域"},{"content":"\r\n\r\nClass文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件之中，中间没有任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用8为字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。\r\n\r\n根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储，这种伪结构只有两种数据类型：无符号数和表。\r\n\r\n无符号数属于基本数据类型，以u1、u2、u4、u8来分别代表1、2、4、8个字节的无符号数，无符号数可以描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值。\r\n\r\n表是多个无符号数或其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾，表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。Class文件由以下表项构成(需要注意的是，**数据类型只是指明了该名称表项占用的连续内存的多少**)\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u4|magic|1|\r\n|u2|minor_version|1|\r\n|u2|major_version|1|\r\n|u2|constant_pool_count|1|\r\n|cp_info|constant_pool|constant_pool_count - 1|\r\n|u2|access_flags|1|\r\n|u2|this_class|1|\r\n|u2|super_class|1|\r\n|u2|interfaces_count|1|\r\n|u2|interfaces|interfaces_count|\r\n|u2|fields_count|1|\r\n|field_info|fields|fields_count|\r\n|u2|methods_count|1|\r\n|method_info|methods|methods_count|\r\n|u2|attributes_count|1|\r\n|attribute_info|attributes|attributes_count|\r\n\r\n无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。\r\n\r\n## 一、魔数与Class文件的版本\r\n\r\n魔数的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。Java文件的魔数是十六进制的`CAFEBABE`，共占用四个字节，即名称为魔数的表项的类型为u4，那么从Class文件中开头连续数四个字节的数据就是魔数，如下\r\n\r\n![](/images/article/class1.png)\r\n\r\n紧接着魔数的四个字节分别是此版本号和主版本号，分别占两个字节，共4个字节，如下\r\n\r\n![](/images/article/class2.png)\r\n\r\n主版本号为52，说明是JDK1.8编译出来的。JDK1.1的主版本号为45，1.2的主版本号为46，1.7的主版本号为51，自然地1.8的主版本号为52.\r\n\r\n## 二、常量池容量计数与常量池\r\n\r\n常量池容量计数（constant_pool_count）是一个u2类型的数据，占用16个bit，即最多表示65536个(0 - 65535)个常量池项目，即常量池最多有65536个项目。\r\n\r\n![](/images/article/class3.png)\r\n\r\n可见，该Class文件中常量池容量计数值为19，即常量池中共有18项常量(该计数是从1开始的而非0，索引值为1 - 18)，也就意味着接下来的类型为`cp_info`的`constant_pool`会有`constant_pool_count - 1`项常量。\r\n\r\n常量池`constant_pool`是Class文件表中的一张子表，主要存放两大类常量：字面量和符号引用。字面量包括文本字符串、被声明为final的常量值等。而符号引用则包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。完整结构如下\r\n\r\n\u003ctable\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003e常量\u003c/td\u003e\u003ctd\u003e项目\u003c/td\u003e\u003ctd\u003e类型\u003c/td\u003e\u003ctd\u003e对应描述\u003c/td\u003e\u003ctd\u003e标志\u003c/td\u003e\u003ctd\u003e常量描述\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 3\u003eCONSTANT_Utf8_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为1\u003c/td\u003e\u003ctd rowspan = 3\u003e1\u003c/td\u003e\u003ctd rowspan = 3\u003eUTF-8编码的字符串\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003elength\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003eUTF-8编码的字符串占用的字节数\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003ebytes\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e长度为length的UTF-8编码的字符串\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 2\u003eCONSTANT_Integer_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为3\u003c/td\u003e\u003ctd rowspan = 2\u003e3\u003c/td\u003e\u003ctd rowspan = 2\u003e整型字面量\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003ebytes\u003c/td\u003e\u003ctd\u003eu4\u003c/td\u003e\u003ctd\u003e按照高位在前存储的int值\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 2\u003eCONSTANT_Float_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为4\u003c/td\u003e\u003ctd rowspan = 2\u003e4\u003c/td\u003e\u003ctd rowspan = 2\u003e浮点型字面量\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003ebytes\u003c/td\u003e\u003ctd\u003eu4\u003c/td\u003e\u003ctd\u003e按照高位在前存储的float值\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 2\u003eCONSTANT_Long_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为5\u003c/td\u003e\u003ctd rowspan = 2\u003e5\u003c/td\u003e\u003ctd rowspan = 2\u003e长整型型字面量\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003ebytes\u003c/td\u003e\u003ctd\u003eu8\u003c/td\u003e\u003ctd\u003e按照高位在前存储的Long值\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 2\u003eCONSTANT_Double_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为6\u003c/td\u003e\u003ctd rowspan = 2\u003e6\u003c/td\u003e\u003ctd rowspan = 2\u003e双精度浮点型字面量\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003ebytes\u003c/td\u003e\u003ctd\u003eu8\u003c/td\u003e\u003ctd\u003e按照高位在前存储的double值\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 2\u003eCONSTANT_Class_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为7\u003c/td\u003e\u003ctd rowspan = 2\u003e7\u003c/td\u003e\u003ctd rowspan = 2\u003e类或接口的符号引用\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003eindex\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003e指向全限定名常量项的索引，即指向常量池第index项常量，该常量类型为CONSTANT_Utf8_info\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 2\u003eCONSTANT_String_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为8\u003c/td\u003e\u003ctd rowspan = 2\u003e8\u003c/td\u003e\u003ctd rowspan = 2\u003e字符串类型字面量\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003eindex\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003e指向字符串字面量的索引，即指向常量池第index项常量，该常量类型为CONSTANT_Utf8_info\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 3\u003eCONSTANT_Fieldref_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为9\u003c/td\u003e\u003ctd rowspan = 3\u003e9\u003c/td\u003e\u003ctd rowspan = 3\u003e字段的符号引用\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003eindex\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003e指向声明字段的类或接口描述符CONSTANT_Class_info的索引项，即第index项常量，该常量类型为CONSTANT_Class_info\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003eindex\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003e指向字段描述符CONSTANT_NameAndType的索引项，即第index项常量，该常量类型为CONSTANT_NameAndType\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 3\u003eCONSTANT_Methodref_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为10\u003c/td\u003e\u003ctd rowspan = 3\u003e10\u003c/td\u003e\u003ctd rowspan = 3\u003e类中方法的符号引用\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003eindex\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003e指向声明方法的类描述符CONSTANT_Class_info的索引项，即第index项常量，该常量类型为CONSTANT_Class_info\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003eindex\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003e指向名称及类型描述符CONSTANT_NameAndType的索引项，即第index项常量，该常量类型为CONSTANT_NameAndType\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 3\u003eCONSTANT_InterfaceMethodref_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为11\u003c/td\u003e\u003ctd rowspan = 3\u003e11\u003c/td\u003e\u003ctd rowspan = 3\u003e接口中方法的符号引用\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003eindex\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003e指向声明方法的接口类描述符CONSTANT_Class_info的索引项，即第index项常量，该常量类型为CONSTANT_Class_info\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003eindex\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003e指向名称及类型描述符CONSTANT_NameAndType的索引项，即第index项常量，该常量类型为CONSTANT_NameAndType\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \r\n  \u003ctr\u003e\r\n    \u003ctd rowspan = 3\u003eCONSTANT_NameAndType_info\u003c/td\u003e\u003ctd\u003etag\u003c/td\u003e\u003ctd\u003eu1\u003c/td\u003e\u003ctd\u003e同[标志]，为12\u003c/td\u003e\u003ctd rowspan = 3\u003e12\u003c/td\u003e\u003ctd rowspan = 3\u003e字段或方法的部分符号引用\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003eindex\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003e指向该字段或方法名称常量项的索引\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n  \u003ctr\u003e\r\n    \u003ctd\u003eindex\u003c/td\u003e\u003ctd\u003eu2\u003c/td\u003e\u003ctd\u003e指向该字段或方法描述符常量项的索引\u003c/td\u003e\r\n  \u003c/tr\u003e\r\n\u003c/table\u003e\r\n\r\n由于常量池每一项的第一个子项均为tag，因此可以通过tag的数值区分该项常量为常量池中的哪个项目，再通过该项目子项的项目及其类型就可以确定下一个常量池的tag。\r\n\r\n举个例子，在本例中常量池的第一个u1类型的tag为十进制10，如下\r\n\r\n![](/images/article/class4.png)\r\n\r\n即代表第一项常量为**类中方法的符号引用**，该项常量除tag外各有两个字节的index，第一个index值为\r\n\r\n![](/images/article/class5.png)\r\n\r\n即代表指向常量池中第4项常量，第二个index为\r\n\r\n![](/images/article/class6.png)\r\n\r\n即代表指向常量池中第15项常量。接下来第二项常量为\r\n\r\n![](/images/article/class7.png)\r\n\r\ntag为9，代表这项常量是**字段的符号引用**，两个u2类型的index的值分别为\r\n\r\n![](/images/article/class8.png)\r\n\r\n![](/images/article/class9.png)\r\n\r\n即分别指向第3项和第16项常量。\r\n\r\n剩余常量的分析与上述同理，即都是通过tag判断常量池中常量类型，然后tag后该常量池经过子项的数据类型代表的连续地址空间之后就是另一个常量的tag，继续重复即可。\r\n\r\n剩余的常量我们借助Class文件字节码分析工具javap来完成，常量池中完整内容如下\r\n\r\n```\r\nC:\\Users\\Administrator\u003ejavap -verbose C:\\Users\\Administrator\\Desktop\\docs\\TestCl\r\nass.class\r\nClassfile /C:/Users/Administrator/Desktop/docs/TestClass.class\r\n  Last modified 2019-4-22; size 295 bytes\r\n  MD5 checksum 81f2ab948a7a3068839b61a8f91f634b\r\n  Compiled from \"TestClass.java\"\r\npublic class org.fenixsoft.clazz.TestClass\r\n  minor version: 0\r\n  major version: 52\r\n  flags: ACC_PUBLIC, ACC_SUPER\r\nConstant pool:\r\n   #1 = Methodref          #4.#15         // java/lang/Object.\"\u003cinit\u003e\":()V\r\n   #2 = Fieldref           #3.#16         // org/fenixsoft/clazz/TestClass.m:I\r\n   #3 = Class              #17            // org/fenixsoft/clazz/TestClass\r\n   #4 = Class              #18            // java/lang/Object\r\n   #5 = Utf8               m\r\n   #6 = Utf8               I\r\n   #7 = Utf8               \u003cinit\u003e\r\n   #8 = Utf8               ()V\r\n   #9 = Utf8               Code\r\n  #10 = Utf8               LineNumberTable\r\n  #11 = Utf8               inc\r\n  #12 = Utf8               ()I\r\n  #13 = Utf8               SourceFile\r\n  #14 = Utf8               TestClass.java\r\n  #15 = NameAndType        #7:#8          // \"\u003cinit\u003e\":()V\r\n  #16 = NameAndType        #5:#6          // m:I\r\n  #17 = Utf8               org/fenixsoft/clazz/TestClass\r\n  #18 = Utf8               java/lang/Object\r\nSourceFile: \"TestClass.java\"\r\n```\r\n\r\n可见前两项常量的分析我们是正确的，常量池中共有18项常量，第一项常量的具体子项分别指向第4和第15项常量，内容分别为`java/lang/Object`和`\"\u003cinit\u003e\":()V`；\r\n\r\n而第二项常量分别指向第3和16项常量，内容分别为`org/fenixsoft/clazz/TestClass`和`m:I`。\r\n\r\n## 三、访问标志\r\n\r\n常量池结束后的两个字节代表访问标志(access_flags)，该标志用于识别一些类或接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是的话，是否被声明为final，等等。具体的标志位以及含义见下表\r\n\r\n|标志名称|标志值|含义|\r\n|------|------|------|\r\n|ACC_PUBLIC|0x0001|是否为public类型|\r\n|ACC_FINAL|0x0010|是否被声明为final，只有类可设置|\r\n|ACC_SUPER|0x0020|是否允许使用`invokespecial`字节码指令，JDK1.2之后编译出来的类的这个标志为真|\r\n|ACC_INTERFACE|0x0200|标识这是一个接口|\r\n|ACC_ABSTRACT|0x0400|是否为abstract类型，对于接口或者抽象类来说，此标志值为真，其它值为假|\r\n|ACC_SYNTHETIC|0x1000|标识这个类并非由用户代码产生的|\r\n|ACC_ANNOTATION|0x2000|标识这是一个注解|\r\n|ACC_ENUM|0x4000|标识这是一个枚举|\r\n\r\naccess_flags共有16个标志位可用，当前只定义了8个，没有使用到的标志位要求一律为0。以本例为例，TestClass被public关键字修饰但是并没有被声明为final和abstract，并且使用了JDK1.2之后的编译器进行编译，因此access_flags的值应为：`0x0001 | 0x0020 = 0x0021`,如下图所示\r\n\r\n![](/images/article/class10.png)\r\n\r\n## 三、类索引、父类索引与接口索引集合\r\n\r\n类索引(this_class)与父类索引(super_class)均为u2类型的数据，其值分别指向常量池中的某项常量，即符号引用。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，也就是说出了java.lang.Object之外，所有的Java类的父类索引(super_class)都不为0。在本例中如下图所示\r\n\r\n![](/images/article/class11.png)\r\n\r\n即类索引指向常量池中第3项常量，值为`org/fenixsoft/clazz/TestClass`，即该类的全限定名。\r\n\r\n![](/images/article/class12.png)\r\n\r\n父类的全限定名指向常量池第四项常量，为`java/lang/Object`。\r\n\r\n接口索引集合的计数器`interfaces_count`为0，代表接口索引集合`interfaces`字段无值，直接跳过(如下图)。接口索引集合用来描述这个类实现了那些接口，这些被实现的接口按照implements的顺序从做左到右的顺序排列在接口索引集合中。接口索引集合的元素仍然是u2类型的数据，即指向常量池中的某项常量，该常量给出了接口的全限定名，接口索引集合计数器为多少就连续数多少个u2类型数据。如果当前类本身就是一个接口，那么接口索引集合后的值就是extends语句。\r\n\r\n![](/images/article/class13.png)\r\n\r\n## 四、字段表集合\r\n\r\n字段表(field_info)用来描述接口或者类中声明的变量。字段(field)包括了类级变量或实例级变量，但不包括在方法内部声明的变量(这种变量包含在栈中的局部变量表中)。一个字段的描述信息都包括：字段的作用域(public、private、protected修饰符)、是实例变量还是类变量(static修饰符)、可变性(final)、并发可见性(volatile修饰符，是否强制从主内存读写)、可否序列化(transient修饰符)、字段数据类型(基本类型、对象、数组)、字段名称。\r\n\r\n这些信息中，各个修饰符都是布尔值，即要么有要么没有，很适合用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型是无法固定的，也就意味着会指向常量池中的某项常量。字段表是Class文件表的一张子表，其格式如下\r\n\r\n\r\n|类型|名称|数量|描述|\r\n|------|------|------|------|\r\n|u2|access_flags|1|字段的修饰符，具体值见下表|\r\n|u2|name_index|1|字段名称|\r\n|u2|descriptor_index|1|字段数据类型修饰符,各数据类型的常量表示见下下表|\r\n|u2|attributes_count|1|该字段与下一个字段描述字段表集合的额外信息|\r\n|attribute_info|attributes|attributes_count|该字段与上一个字段描述字段表集合的额外信息|\r\n\r\n字段访问标志access_flags的标志位与值如下表\r\n\r\n\r\n|标志名称|标志值|含义|\r\n|------|------|------|\r\n|ACC_PUBLIC|0x0001|字段是否为public|\r\n|ACC_PRIVATE|0x0002|字段是否为private|\r\n|ACC_PROTECTED|0x0004|字段是否为protected|\r\n|ACC_STATIC|0x0008|字段是否为static|\r\n|ACC_FINAL|0x0010|字段是否为final|\r\n|ACC_VOLATILE|0x0040|字段是否为volatile|\r\n|ACC_TRANSIENT|0x0080|字段是否为transient|\r\n|ACC_SYNTHETIC|0x1000|字段是否由编译器自动产生的|\r\n|ACC_ENUM|0x4000|字段是否为enum|\r\n\r\n常量池中描述符表示字符的含义为\r\n\r\n|标识字符|含义|\r\n|------|------|\r\n|B|基本类型byte|\r\n|C|基本类型char|\r\n|D|基本类型double|\r\n|F|基本类型float|\r\n|I|基本类型int|\r\n|J|基本类型long|\r\n|S|基本类型short|\r\n|Z|基本类型boolean|\r\n|V|特殊类型void|\r\n|L|对象类型，如Ljava/lang/Object;|\r\n\r\n对于数组类型，每一维度将使用一个前置的`[`字符来描述，如一个定义为`java.lang.String[][]`类型的二维数组，将被记录为：`[[Ljava/lang/String;`，其中`[[`二维数组，`L`表示这是一个对象，`java/lang/String`表示这是一个String型。合起来就是一个String对象二维数组，那么一个整型数组`int[]`会被记录为`[I`。\r\n\r\n题外话：而用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号`()`之内。如方法`void inc()`的描述符为`()V`，方法`java.lang.String toString()`的描述符为`()Ljava/lang/String;`,表示该方法无参，返回值为对象`(L)String`。而方法`int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)`的描述符为`([CII[CIII)I`,很好理解，不解释。\r\n\r\n接下来对TestClass字段表集合的分析如下\r\n\r\n![](/images/article/class14.png)\r\n\r\n首先该字段表集合计数器fields_count为1，即字段集合表中只有一个实例变量或者类变量。那么进入字段集合表继续分析这一个变量。\r\n\r\n![](/images/article/class15.png)\r\n\r\n上图显示该字段的access_flags值为`0x0002`，查字段访问标志表得，该字段的访问修饰符为`private`。\r\n\r\n![](/images/article/class16.png)\r\n\r\n上图显示，`name_index`字段指向了常量池中第五项常量，内容为\r\n\r\n```\r\n#5 = Utf8               m\r\n```\r\n\r\n即该字段的名称为`m`。\r\n\r\n![](/images/article/class17.png)\r\n\r\n上图中descriptor_index值为6，该值仍然指向常量池，内容为\r\n\r\n```\r\n#6 = Utf8               I\r\n```\r\n\r\n那么综上所述就可以推断出该字段被定义为`private int m;`。其后的两个字节表示attributes_count，如下图\r\n\r\n![](/images/article/class18.png)\r\n\r\n值为0，代表attributes无值，可以直接跳过。\r\n\r\n## 五、方法表集合\r\n\r\n方法表集合与字段表集合的解释几乎一样，连结构也一样，如下表所示\r\n\r\n|类型|名称|数量|描述|\r\n|------|------|------|------|\r\n|u2|access_flags|1|方法的修饰符，具体值见下表|\r\n|u2|name_index|1|方法名称|\r\n|u2|descriptor_index|1|方法返回值修饰符,同字段表返回值修饰符|\r\n|u2|attributes_count|1|该字段与下一个字段描述方法表集合的额外信息|\r\n|attribute_info|attributes|attributes_count|该字段与上一个字段描述方法表集合的额外信息|\r\n\r\n\r\n方法访问标志access_flags如下表\r\n\r\n|标志名称|标志值|含义|\r\n|------|------|------|\r\n|ACC_PUBLIC|0x0001|方法是否为public|\r\n|ACC_PRIVATE|0x0002|方法是否为private|\r\n|ACC_PROTECTED|0x0004|方法是否为protected|\r\n|ACC_STATIC|0x0008|方法是否为static|\r\n|ACC_FINAL|0x0010|方法是否为final|\r\n|ACC_SYNCHRONIZED|0x0020|方法是否为synchronized|\r\n|ACC_BRIDGE|0x0040|方法是否是由编译器产生的桥接方法|\r\n|ACC_VARARGS|0x0080|方法是否接受不定参数|\r\n|ACC_NATIVE|0x0100|方法是否为native|\r\n|ACC_ABSTRACT|0x0400|方法是否为abstract|\r\n|ACC_STRICT|0x0800|方法是否为strictfp|\r\n|ACC_SYNTHETIC|0x1000|方法是否是由编译器自动产生的|\r\n\r\n接下来分析TestClass\r\n\r\n![](/images/article/class19.png)\r\n\r\nmethods_count为2，代表该类有两个方法(分别是编译器添加的构造器`\u003cinit\u003e`和源码中的`inc()`方法)。先看第一个方法的access_flags\r\n\r\n![](/images/article/class20.png)\r\n\r\n值为0x0001，查表得该方法的修饰符为public，name_index如下图\r\n\r\n![](/images/article/class21.png)\r\n\r\n可见指向常量池中第7项常量，内容为\r\n\r\n```\r\n#7 = Utf8               \u003cinit\u003e\r\n```\r\n\r\n可见该方法为构造器`\u003cinit\u003e`，接下来看descriptor_index的值，如下图\r\n\r\n![](/images/article/class22.png)\r\n\r\n值为8，仍然是指向常量池，第八项常量为\r\n\r\n```\r\n#8 = Utf8               ()V\r\n```\r\n\r\n即无参无返回值。接下来看attributes_count，如下图\r\n\r\n![](/images/article/class23.png)\r\n\r\n值为1，代表方法表中的属性表集合中有一项属性。接下来看Class文件的最后一个项目——属性表集合(attribute_info)。\r\n\r\n## 六、属性表集合\r\n\r\nClass文件、字段表、方法表均可以携带自己的属性表集合，以用于描述某些场景专有的信息。与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。为了能正确解析Class文件，《Java虚拟机规范（第2版）》中预定义了9项虚拟机应当能识别的属性，如下\r\n\r\n|属性名称|使用位置|含义|\r\n|------|------|------|\r\n|Code|方法表|Java代码编译成的字节码指令|\r\n|ConstantValue|字段表|final关键字定义的常量值|\r\n|Deprecated|类、方法表、字段表|被声明为deprecated的方法和字段|\r\n|Exceptions|方法表|方法抛出的异常|\r\n|InnerClasses|类文件|内部类列表|\r\n|LineNumberTable|上述Code属性中|Java源码的行号与字节码指令的对应关系|\r\n|LocalVariableTable|上述Code属性中|方法的局部变量描述|\r\n|SourceFile|类文件|源文件名称|\r\n|Synthetic|类、方法表、字段表|标识方法或字段是否为编译器自动生成的|\r\n\r\n对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要说明属性值所占用的位数长度即可。一个符合规则的属性表应该满足如下定义的结构(作用就是字段表和方法表中attributes_count指明了额外的属性信息后进入属性表集合中根据attribute_name_index查常量池从而确定为何种属性)\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|attribute_name_index|1|\r\n|u2|attribute_length|1|\r\n|u1|info|attribute_length|\r\n\r\n### 6.1 Code属性\r\n\r\n对于方法表集合中的属性表集合，Code属性是其中的一个。Java程序方法体里面的代码经过javac编译器处理之后，最终会变成字节码指令存储在方法表集合的属性表集合的Code属性中，也就是说方法表集合属性表集合之前的一些子项只是方法名称、返回值、修饰符的一些描述，真正的方法代码就在方法表集合的属性表集合的Code属性中，Code属性的表结构如下\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|attribute_name_index|1|\r\n|u4|attribute_length|1|\r\n|u2|max_stack|1|\r\n|u2|max_locals|1|\r\n|u4|code_length|1|\r\n|u1|code|code_length(即每个字节码占用1个字节，code_length为多大，那么该方法就有多少个code，连续读)|\r\n|u2|exception_table_length|1|\r\n|exception_info|exception_table|exception_table_length|\r\n|u2|attributes_count|1|\r\n|attribute_info|attributes|attributes_count|\r\n\r\nattribute_name_index指向CONSTANT_Utf8_info型常量的索引，常量值固定为`Code`，它代表了该属性的属性名称，attribute_length指示了属性**值**的长度，由于属性名称索引与属性长度共6个字节，所以属性值的长度固定为整个属性表的长度减去6个字节。\r\n\r\nmax_stack代表了操作数栈深度的最大值，在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机在运行的时候需要根据这个值来分配栈帧(Frame)中的操作栈深度。\r\n\r\nmax_locals代表了局部变量表所需的存储空间，基本单位是Slot，Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean、reference和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要2个Slot来存放。**方法参数（包括实例方法中的隐藏参数this）、显式异常处理器的参数(Exception Handler Parameter,即try-catch语句中catch快所定义的异常)、方法体中定义的局部变量都需要使用局部变量表来存放。另外，并不是方法中用到了多少个局部变量就把局部变量所占的Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot就可以被其他局部变量所占用，编译器会根据变量的作用域来分类Slot并分配给各个变量使用，然后计算出max_locals的大小。**\r\n\r\ncode_length和code用来存储Java源程序编译后生成的字节码指令，code_length代表字节码的长度，code是用于存储字节码指令的一系列字节流。既然名为字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以相应地找出这个字节码代表什么指令，并且可以知道这条指令后面是否需要跟随参数以及参数应该如何理解。我们知道一个u1类型的取值范围为0 - 255，也就是一共可以表达256条指令。当前，Java虚拟机规范中定义了约200条编码值对应的指令含义。\r\n\r\n关于code_length,虽然是一个u4类型的长度，理论上可以取值2\u003csup\u003e32\u003c/sup\u003e - 1,也就是说理论上一个方法可以有2\u003csup\u003e32\u003c/sup\u003e - 1条**指令**，但是虚拟机规范明确指出，一个方法不允许超过65535条**字节码指令**，如果超过了这个限制，javac编译器就会拒绝编译。\r\n\r\n**Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码(Code,方法体里面的Java代码)和元数据(Metadata，包括类、字段、方法定义及其他信息)两部分，那么在整个Class文件里，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。**\r\n\r\n继续以TestClass为例，说明方法表集合中属性表集合的Code属性\r\n\r\n![](/images/article/class23.png)\r\n\r\n由上图得知，方法表集合中第一个方法`\u003cinit\u003e`attributes_count的值为1,即代表该方法包含一个额外的描述信息，进入属性表集合，根据属性表结构第一项为u2类型的attribute_name_index，那么先连续读2个字节确定该属性属于何种属性\r\n\r\n![](/images/article/class24.png)\r\n\r\n得知指向常量池第9项常量，内容为\r\n\r\n```\r\n#9 = Utf8               Code\r\n```\r\n\r\n那么就可以确定方法表集合中的属性表集合中的属性为Code属性，即方法体中经编译产生的字节码，那就查Code属性结构表继续分析，连续四个字节为attribute_length\r\n\r\n![](/images/article/class25.png)\r\n\r\n即长度为29。如下两图分别指出了max_stack与max_locals的值\r\n\r\n![](/images/article/class26.png)\r\n\r\n![](/images/article/class27.png)\r\n\r\n分别为1。接下来连续四个字节为code_length,即字节码指令的长度，如下\r\n\r\n![](/images/article/class28.png)\r\n\r\n值为5，那么连续读5个字节就是字节码指令(code),分别如下\r\n\r\n![](/images/article/class29.png)\r\n\r\n此处的查表查的的编码值与字节码指令的对应表，这里无法列出。仅作说明\r\n\r\n+ 读入2A，查表得0x2A所对应的指令为aload_0,含义是将第0个Slot中卫reference类型的本地变量推送至栈顶；\r\n+ 读入B7，查表得0xB7所对应的指令为invokespecial，作用是以栈顶的reference类型的数据所指向的对象作为方法的接受者，调用此对象的实例构造器方法、private方法或其父类的方法。这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向常量池中的一个CONSTANT_Methodref_info类型的常量，即此方法的方法符号引用；\r\n+ 读入u2类型的数据00 01，这是invokespacial的参数，查常量池0x000A对应的常量为实例构造器`\u003cinit\u003e`方法的符号引用；\r\n+ 读入B1，查表得0xB1对应的指令为return，含义是返回此方法，并且返回值为void。这条指令执行后，当前方法结束。\r\n\r\n从这里可以看出，方法的执行过程中的数据交换、方法调用等操作都是基于栈(操作栈)进行的。因此可以初步猜测：Java虚拟机执行字节码是基于栈的体系结构。\r\n\r\n剩下个另一个方法通过javap命令来计算，如下\r\n\r\n```\r\n{\r\n  public org.fenixsoft.clazz.TestClass();\r\n    descriptor: ()V\r\n    flags: ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=1, args_size=1\r\n         0: aload_0\r\n         1: invokespecial #1                  // Method java/lang/Object.\"\u003cinit\u003e\r\n\":()V\r\n         4: return\r\n      LineNumberTable:\r\n        line 3: 0\r\n\r\n  public int inc();\r\n    descriptor: ()I\r\n    flags: ACC_PUBLIC\r\n    Code:\r\n      stack=2, locals=1, args_size=1\r\n         0: aload_0\r\n         1: getfield      #2                  // Field m:I\r\n         4: iconst_1\r\n         5: iadd\r\n         6: ireturn\r\n      LineNumberTable:\r\n        line 8: 0\r\n}\r\nSourceFile: \"TestClass.java\"\r\n```\r\n\r\n这是直接计算出了方法表集合中的所有信息，包括描述符标识字符descriptor、方法名称等、访问标志还有属性表集合Code属性。\r\n\r\n在字节码指令Code属性的code数据项之后是该方法的显式异常处理表集合，exception_table_length指明了该方法的异常数量，而exception_table数据项则指出了该方法每个异常类型为exception_info的exception_table_length个异常。exception_info的定义如下\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|start_pc|1|\r\n|u2|end_pc|1|\r\n|u2|handler_pc|1|\r\n|u2|catch_type|1|\r\n\r\n整体含义为：**如果字节码指令从第start_pc行到第end_pc行(不含第end_pc行)出现了类型为catch_type或其子类的异常(catch_type指向一个CONSTANT_Class_info型常量的索引)，则转到第handler_pc行继续处理。当catch_type的值为0时，代表任何异常都由handler_pc处进行处理。**\r\n\r\n这里的异常表不是必须的，比如TestClass没有显式的捕获异常，所以没有。\r\n\r\n我们改动一下TestClass文件，如下\r\n\r\n```\r\n1 package org.fenixsoft.clazz;\r\n2 \r\n3 public class TestClass {\r\n4 \t\r\n5     private int m;\r\n6 \t\r\n7     public int inc() {\r\n8         int x;\r\n9         try {\r\n10            x = 1;\r\n11            return x;\r\n12        } catch (Exception e) {\r\n13            x = 2;\r\n14            return x;\r\n15        } finally {\r\n16            x = 3;\r\n17        }\r\n18    }\r\n19\t\r\n20 }\r\n```\r\n\r\n编译后的inc方法的相关内容为\r\n\r\n```\r\npublic int inc();\r\n  descriptor: ()I\r\n  flags: ACC_PUBLIC\r\n  Code:\r\n    stack=1, locals=5, args_size=1\r\n       0: iconst_1    // x = 1;\r\n       1: istore_1\r\n       2: iload_1    // return x;\r\n       3: istore_2\r\n       4: iconst_3    // x = 3;\r\n       5: istore_1\r\n       6: iload_2    // return x;\r\n       7: ireturn\r\n       8: astore_2\r\n       9: iconst_2    // x = 2;\r\n      10: istore_1\r\n      11: iload_1    // return x;\r\n      12: istore_3    // int x;\r\n      13: iconst_3    // x = 3;\r\n      14: istore_1    \r\n      15: iload_3    // return x;\r\n      16: ireturn    \r\n      17: astore        4\r\n      19: iconst_3\r\n      20: istore_1\r\n      21: aload         4\r\n      23: athrow\r\n    Exception table:\r\n       from    to  target type\r\n           0     4     8   Class java/lang/Exception\r\n           0     4    17   any\r\n           8    13    17   any\r\n          17    19    17   any\r\n    LineNumberTable:\r\n      line 10: 0\r\n      line 11: 2\r\n      line 16: 4\r\n      line 11: 6\r\n      line 12: 8\r\n      line 13: 9\r\n      line 14: 11\r\n      line 16: 13\r\n      line 14: 15\r\n      line 16: 17\r\n      line 17: 21\r\n    StackMapTable: number_of_entries = 2\r\n      frame_type = 72 /* same_locals_1_stack_item */\r\n        stack = [ class java/lang/Exception ]\r\n      frame_type = 72 /* same_locals_1_stack_item */\r\n        stack = [ class java/lang/Throwable ]\r\n```\r\n\r\n**需要说明的是，方法中的参数以及局部变量均存储在栈帧中的局部变量表中，而对局部变量表中参数与局部变量的操作是在栈帧的操作数栈中进行的。**\r\n\r\n根据LineNumberTable指出的源码与字节码指令的对应关系得知\r\n\r\n+ 第0条字节码指令`iconst_1`对应的是源码中的第10行`x = 1;`，含义是**将int型1推送至栈顶**；\r\n  + 第1条字节码指令`istore_1`，含义是**将栈顶int数值存入本地变量表中的第二个Slot中**；\r\n+ 第2条字节码指令`iload_1`对应源码中的第11行`return x;`，含义是**将第2个int型本地变量推送至栈顶**；有个疑问，int型1不是本来就在栈顶吗，怎么又推送一次？还出现了个**第二个**？由于第1条字节码指令的执行，原来栈顶的int型1已经被存入局部变量表中的第二个Slot中，所以已经不在栈顶了，所以第2条字节码指令需要将本地变量表中的第2个Slot的int型1值取出来推送至栈顶；\r\n  + 第3条字节码指令`istore_2`，含义是**将栈顶int数值存入本地变量表中的第三个Slot中**；也就是将栈顶的int型1再次存入第三个Slot中；\r\n+ 第4条字节码指令`iconst_3`对应源码中的第16行`x = 3;`，含义是**将int型3推送至栈顶**。\r\n  + 第5条字节码指令`istore_1`的含义是**将栈顶int型数值存入局部变量表中的第二个Slot中**，由于int型1已经被从第二个Slot中取出推送至栈中后又被存入第三个Slot中，所以第二个Slot空出来了，任意一个int型数值都可以进入；这条字节码指令执行后，局部变量表中的第二个Slot中为int型3；\r\n+ 第6条字节码指令`iload_2`对应源码中的第11行`return x;`。含义是**将局部变量表中的第三个Slot的值推送至栈顶**，也就是int型1被推送至栈顶。\r\n  + 第7条字节码指令`ireturn`含义是**从当前方法返回int**。即将该方法的返回值返回给该方法的调用者(即虚拟机栈当前线程调用栈的在inc方法(栈帧)执行时位于其底部的栈帧)。返回值为1，**从这里也可以看出，方法的返回值仍然是从操作数栈中返回而不是局部变量表，所以没有返回3而是1。这里也揭示了try-finally块中返回值的原理。**\r\n\r\n以上是try中没有发生异常的情况下字节码指令的执行方式，如果发生了类型为`Class java/lang/Exception`的异常，即字节码指令第0条到第3条(不包括第4条)，那么根据异常表的指示将会跳转到第8行处理。由于字节码指令第4条才会将3推送至栈顶，而第五条才会将3存入第2个Slot，也就意味着如果发生异常就不会执行到第4条和第五条字节码指令，也就意味着第2个Slot并没有值(根据第2条字节码指令，局部变量表中的第2个Slot中的1被推送至栈顶后又存放到了第3个Slot中，所以第二个Slot没有值)如下\r\n\r\n+ 第8条字节码指令`astore_2`对应源码中的第12行`} catch (Exception e) {`，代表的是异常处理，继续看下一行，因为是一个整体；\r\n+ 第9条字节码指令`iconst_2`对应源码中的第13行`x = 2;`，是对异常的处理，含义为**将int型2推送至栈顶**；\r\n  + 第10条字节码指令`istore_1`一目了然，含义是将**将栈顶int数值2存入本地变量表中的第二个Slot中**；由于出现了异常，上面已经解释过了，第二个Slot无值，因此可以存放而不会覆盖别的值。\r\n+ 第11条字节码指令`iload_1`对应源码中的第14行`return x;`，含义是**将局部变量表中第2个Slot的值2推送至栈顶**；\r\n  + 第12条字节码指令`istore_3`的含义是将栈顶的值2存入局部变量表中的第四个Slot中，因为第三个Slot存放的是int型1，上面也解释过了；`由于是不管有没有发生异常，都会执行finally，所以接下来执行finally`；\r\n+ 第13条字节码指令`iconst_3`对应的仍是源码第16行`x = 3;`，含义是**将int型3推送至栈顶**。(注意，发生异常后try中并未执行到这里)；含义是将int型3推送至栈顶；\r\n  + 第14条字节码指令`istore_1 `的含义是**将栈顶的3存入局部变量表中的第2个Slot中**，由于第11条字节码指令`iload_1`将局部变量表第2个Slot中的数据2推送至了栈顶，紧接着第12条指令将栈顶的2存入了第四个Slot中，所以此时Slot无值，可以存入栈顶的3；\r\n+ 第15条字节码指令`iload_3`对应源码的第14行`return x;`，含义是**将局部变量表第4个Slot中的值推送至栈顶，即将2推送至栈顶；**\r\n  + 第16条字节码指令`ireturn`含义是**从当前方法返回int**。即将该方法的返回值返回给该方法的调用者(即虚拟机栈当前线程调用栈的在inc方法(栈帧)执行时位于其底部的栈帧)。返回值为2，**这里也揭示了try-catch-finally块中返回值的原理。**\r\n  \r\n以上是字节码指令第0条到第3条(不包括第4条)发生了类型为`Class java/lang/Exception`的异常的处理方式，如果发生了别的异常，即类型为`any`，那么将会跳转到第17条字节码指令处理。从方法表集合的属性表集合的Code属性的异常表集合得知，第8到12行字节码、17到18行字节码发生类型为`any`的异常，也会调到第17条字节码指令进行处理，所以统一看一下\r\n\r\n+ 第17条字节码指令`astore    4`对应源码第16行`x = 3;`，该指令原型为`astore index`，含义是将栈顶树值存入局部变量表中索引为index(第index+1个Slot)的Slot中，此处不详细展开，因为类型为`any`对应的异常字节码有三段，所以也不知道具体是哪一段的哪一条字节码出现异常，但是无非两种情况，一种是栈顶存在操作数，一种是栈顶不存在操作数，不管存不存在操作数，那么都将其存入第5(索引为4)个Slot中，这样就清空了栈；\r\n+ 第19条字节码指令`iconst_3`，含义是**将int型3推送至栈顶**。也就是finally中的x = 3；\r\n+ 第20条字节码指令`istore_1`，含义是**将栈顶的操作数存入第2个Slot中(索引为1)**,也就是将3存入第二个Slot中，这里分析也比较复杂，因为类型为`any`对应的异常字节码有三段，所以也不知道具体是哪一段的哪一条字节码出现异常，但是无非两种情况，第二个Slot中有可能有值也有可能没有。这种情况已经不重要了，因为这种情况下并没有返回值会返回给上层方法调用者，而是直接将栈顶的异常抛出。即第23条字节码`athrow`。\r\n\r\n解释完毕，可以看出，Java方法的执行确实是基于栈的，对参数以及变量(局部变量)的操作都是在操作数栈中进行的，局部变量表存储方法中的变量及参数，通过对局部变量表中变量的入栈参与指令运算和出栈暂存数值最终出栈栈顶元素实现返回结果！而对实例变量的访问是通过局部变量表中第1个Slot(索引为0)中存放的this来指向具体对象的地址，这样就可以通过地址引用到实例变量，也可以通过地址将对实例变量的修改写入堆中。\r\n\r\n### 6.2 Exceptions属性\r\n\r\n这里的Exceptions属性是在方法表中与Code属性平级的一项属性。Exceptions属性的作用是列举出方法中可能抛出的受检**异常**，也就是方法描述时在throws关键字后面列举的异常。结构如下表所示\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|attribute_name_index|1|\r\n|u4|attribute_length|1|\r\n|u2|number_of_exceptions|1|\r\n|u2|exception_index_table|number_of_exceptions|\r\n\r\n仍然是通过attribute_name_index判断该属性属于属性表集合中的哪一个具体的属性，number_of_exceptions指明了该方法可能抛出的受检异常的个数，紧接着连续从常量池读取number_of_exceptions个数个具体常量就是受检异常的类型。\r\n\r\n### 6.3 LineNumberTable属性\r\n\r\n该属性用于描述Java源码行号与字节码行号之间的对应关系。并不是运行时的必须属性，但是会默认生成到Class文件之中，可以在javac中使用`-g:none`或者`-g:lines`选项忽略该属性。\r\n\r\n如果选择不生成该属性，那么对程序主要的影响就是在抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候无法按照源码来设置断点。表结构如下\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|attribute_name_index|1|\r\n|u4|attribute_length|1|\r\n|u2|line_number_table_length|1|\r\n|line_number_info|line_number_table|line_number_table_length|\r\n\r\nline_number_info中包括了`start_pc`和`line_number`两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。\r\n\r\nTestClass中的该属性被描述为\r\n\r\n```\r\n{\r\n  public org.fenixsoft.clazz.TestClass();\r\n    descriptor: ()V\r\n    flags: ACC_PUBLIC\r\n    Code:\r\n      stack=1, locals=1, args_size=1\r\n         0: aload_0\r\n         1: invokespecial #1                  // Method java/lang/Object.\"\u003cinit\u003e\r\n\":()V\r\n         4: return\r\n      LineNumberTable:\r\n        line 3: 0\r\n\r\n  public int inc();\r\n    descriptor: ()I\r\n    flags: ACC_PUBLIC\r\n    Code:\r\n      stack=2, locals=1, args_size=1\r\n         0: aload_0\r\n         1: getfield      #2                  // Field m:I\r\n         4: iconst_1\r\n         5: iadd\r\n         6: ireturn\r\n      LineNumberTable:\r\n        line 8: 0\r\n}\r\nSourceFile: \"TestClass.java\"\r\n```\r\n\r\n### 6.4 localVariableTable属性\r\n\r\n该属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系，不是运行时必需的属性，默认也不会生成到Class文件中，可以通过在javac中使用`-g:none`或者`-g:vars`选项来忽略该属性信息。\r\n\r\n如果没有生成该属性，那么最大的影响就是当其他人引用这个方法时，所有的参数名称将丢失，IDE可能会使用诸如arg0、arg1之类的占位符来代替原有的参数名。表结构如下\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|attribute_name_index|1|\r\n|u4|attribute_length|1|\r\n|u2|local_variable_table_length|1|\r\n|local_variable_info|local_variable_table|local_variable_table_length|\r\n\r\n其中local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构如下\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|start_pc|1|\r\n|u2|length|1|\r\n|u2|name_index|1|\r\n|u2|descriptor_index|1|\r\n|u2|index|1|\r\n\r\nindex是这个局部变量在栈帧局部变量表中Slot的位置，当这个变量的数据类型是64位类型时(double、long)，它占用的Slot为index和index+1两个位置。\r\n\r\n### 6.5 SourceFile属性\r\n\r\n该属性用于记录生成这个Class文件的源码文件名称。该属性页数可选的，可以通过在javac中使用`-g:none`或者`-g:source`选项来忽略该属性信息。\r\n\r\n在Java中，对于大多数类来说，类名与文件名一致，但是一些特殊情况例外，例如内部类。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错误代码所属的文件名，结构如下\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|attribute_name_index|1|\r\n|u4|attribute_length|1|\r\n|u2|sourcefile_index|1|\r\n\r\n是一个定长属性，sourcefile_index数据项指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。\r\n\r\n### 6.6 ConstantValue属性\r\n\r\n该属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的类变量才可以使用这项属性。\r\n\r\n对于非static修饰的的变量(实例变量)的赋值是在实例构造器`\u003cinit\u003e`中进行的；而对于类变量，则有两种方法可以选择：\r\n\r\n+ 赋值在类构造器`\u003cclinit\u003e`方法中进行；\r\n+ 使用ConstantValue属性来赋值。\r\n\r\n目前Sun Javac编译器的选择是：**如果同时使用final和static来修饰一个变量(也就是常量，因为final)，并且这个变量的数据类型是基本类型或java.lang.String的话，就生成ConstantValue属性来初始化该变量，如果这个变量没有被final修饰，或者并非基本类型及字符串，则选择在`\u003cclinit\u003e`方法中进行初始化。**表结构如下\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|attribute_name_index|1|\r\n|u4|attribute_length|1|\r\n|u2|contributevalue_index|1|\r\n\r\n可以看出该属性是一个定长属性，它的attribute_length属性值必须为。该属性的数据项contributevalue_index代表了常量池中一个字面量常量的引用，根据常量字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info常量中的一种。\r\n\r\n### 6.7 InnerClasses属性\r\n\r\n该属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那么编译器将会为它及它所包含的内部类生成InnerClasses属性(因为内部类在编译期间，会被独立出来，所以需要建立内部类与宿主类之间的关联)。结构如下\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|attribute_name_index|1|\r\n|u4|attribute_length|1|\r\n|u2|number_of_classes|1|\r\n|inner_classes_info|inner_classes|number_of_classes|\r\n\r\n数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类信息都由一个inner_classes_info表进行描述，number_of_classes有多少就有几个连续的inner_classes_info表，inner_classes_info表结构如下\r\n\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|inner_classes_info_index|1|\r\n|u2|outer_class_info_index|1|\r\n|u2|inner_name_index|1|\r\n|u2|inner_class_access_flags|1|\r\n\r\ninner_classes_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类与宿主类的符号引用。\r\n\r\ninner_name_index是指向常量池中CONSTANT_Utf8_info类型常量的索引，代表这个内部类的名称，如果是匿名内部类，则这项值为0.\r\n\r\ninner_class_access_flags是内部类的访问标志，类似于类的access_flags，取值如下表所示\r\n\r\n|标志名称|标志值|含义|\r\n|------|------|------|\r\n|ACC_PUBLIC|0x0001|内部类是否为public|\r\n|ACC_PRIVATE|0x0002|内部类是否为private|\r\n|ACC_PROTECTED|0x0004|内部类是否为protected|\r\n|ACC_STATIC|0x0008|内部类是否为static|\r\n|ACC_FINAL|0x0010|内部类是否为final|\r\n|ACC_INTERFACE|0x0020|内部类是否为interface|\r\n|ACC_ABSTRACT|0x0400|内部类是否为abstract|\r\n|ACC_SYNTHETIC|0x1000|内部类是否并非由用户代码产生的|\r\n|ACC_ANNOTATION|0x2000|内部类是否是一个注解|\r\n|ACC_ENUM|0x4000|内部类是否是一个枚举|\r\n\r\n### 6.8 Deprecated及Synthetic属性\r\n\r\n这两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。\r\n\r\nDeprecated属性用于表示某个类、字段或方法，已经被程序作者定为不在推荐使用，它可以通过在代码中使用`@deprecated`注释进行设置。\r\n\r\n`Synthetic`属性代表此字段或方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK1.5之后，标识一个类、字段或方法是编译器自动产生的，也可以设置它们访问标志的ACC_SYNTHETIC标志位。\r\n\r\n这两个字段的结构都如下表\r\n\r\n|类型|名称|数量|\r\n|------|------|------|\r\n|u2|attribute_name_index|1|\r\n|u4|attribute_length|1|\r\n\r\n其中attribute_length数据项的值必须为0x00000000，因为没有任何属性值需要设置。\r\n\r\n以上就是Class文件的结构。可以看出，**类型**就是一个连续地址空间，而**名称**则指明了该连续地址空间代表的是什么内容，**数量**则表示该名称的内部有多少个子项(即连续数几个)。","cover":"/images/class-file.png","link":"class-file-structure.html","preview":"\u003cp\u003eClass文件被抽象组织为了一张表，名称描述该类型(连续地址空间)中的内容代表的是什么东西(魔数还是版本号？常量池？等等)，数量描述的是该名称内部的子项目有多少个。\u003c/p\u003e\n","title":"Class文件结构"},{"content":"\r\n\r\n单例模式提供了一种在多线程情况下保证实例唯一性的解决方案，单例模式设计的标准是：懒加载、高性能、线程安全。\r\n\r\n## 一、饿汉式\r\n\r\n```\r\n// final modifier, no inheritance allowed.\r\npublic final class Singleton {\r\n\r\n    // Some business code.\r\n    \r\n    private static Singleton instance = new Singleton();\r\n    \r\n    // Private constructor, no external `new` is allowed.\r\n    private Singleton() {\r\n        \r\n    }\r\n    \r\n    public static Singleton getInstance() {\r\n        return instance;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n测试如下，我们启动10个线程测试其获得的线程实例\r\n\r\n```\r\npublic class SingletonTest {\r\n\r\n    public static void main(String[] args) {\r\n        \r\n        for (int i = 0; i \u003c 10; i++) {\r\n            new Thread(() -\u003e {\r\n                System.out.println(Thread.currentThread().getName() + \" \"\r\n                    + Singleton.getInstance().toString());\r\n            }, \"thread-\" + i).start();\r\n        }\r\n        \r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nthread-0 tech.feily.doc.thread.Singleton@df7eb94\r\nthread-4 tech.feily.doc.thread.Singleton@df7eb94\r\nthread-3 tech.feily.doc.thread.Singleton@df7eb94\r\nthread-2 tech.feily.doc.thread.Singleton@df7eb94\r\nthread-7 tech.feily.doc.thread.Singleton@df7eb94\r\nthread-8 tech.feily.doc.thread.Singleton@df7eb94\r\nthread-1 tech.feily.doc.thread.Singleton@df7eb94\r\nthread-9 tech.feily.doc.thread.Singleton@df7eb94\r\nthread-6 tech.feily.doc.thread.Singleton@df7eb94\r\nthread-5 tech.feily.doc.thread.Singleton@df7eb94\r\n```\r\n\r\n可见，均为相同的实例。懒汉式的关键在于`instance`作为类变量并且直接得到了初始化，即如果主动使用(使用类变量属于主动使用，会导致类的加载并初始化)Singleton类，那么instance实例将会直接完成创建并初始化。具体而言，instance作为类变量在类初始化的过程中被收集进`\u003cclinit\u003e()`方法中，该方法能够百分百保证同步，即instance在多线程环境下不可能被实例化两次，但是instance被ClassLoader加载后可能很长一段时间才被使用，那么就意味着instance实例所开辟的堆内存会驻留更久的时间。\r\n\r\n综上，这种办法的优点在于保证了多个线程下的唯一实例，在一个类中的成员属性比较少且占用的内存资源不多的情况下性能还可以，但是无法进行懒加载(即类实例在需要时再创建)。\r\n\r\n## 二、懒汉式\r\n\r\n懒汉式就是在使用类实例的时候再去创建，这样就避免了类在初始化时提前创建，代码如下\r\n\r\n```\r\n// final modifier, no inheritance allowed.\r\npublic final class Singleton {\r\n\r\n    // Some business code.\r\n    \r\n    private static Singleton instance = null;\r\n    \r\n    // Private constructor, no external `new` is allowed.\r\n    private Singleton() {\r\n        \r\n    }\r\n    \r\n    public static Singleton getInstance() {\r\n        if (null == instance) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n这样，`instance`在初始化阶段由于为`null`，那么就不会占用内存空间，在使用时即调用`getInstance()`方法后才会被实例化。\r\n\r\n我们继续启动10个线程测试是否可以保证多线程环境下的实例唯一性，测试代码同上，输出为\r\n\r\n```\r\nthread-2 tech.feily.doc.thread.Singleton@59e410f2\r\nthread-5 tech.feily.doc.thread.Singleton@38f983ba\r\nthread-0 tech.feily.doc.thread.Singleton@38f983ba\r\nthread-4 tech.feily.doc.thread.Singleton@38f983ba\r\nthread-1 tech.feily.doc.thread.Singleton@38f983ba\r\nthread-3 tech.feily.doc.thread.Singleton@59e410f2\r\nthread-8 tech.feily.doc.thread.Singleton@38f983ba\r\nthread-7 tech.feily.doc.thread.Singleton@38f983ba\r\nthread-6 tech.feily.doc.thread.Singleton@38f983ba\r\nthread-9 tech.feily.doc.thread.Singleton@38f983ba\r\n```\r\n\r\n可见，并没有保证实例唯一性，此处instance可以看作是多线程的共享变量，即多线程对instance进行操作，那么就有可能某线程在判断了`instance == null`之后CPU时间片到而进入就绪状态，待重新进入运行态时就执行了`new`操作，所以线程不安全，无法保证多线程环境下的实例唯一性。\r\n\r\n解决的办法就是加锁，即给共享变量加锁。\r\n\r\n## 三、懒汉式 + 同步方法\r\n\r\n通过给懒汉式`getInstance()`方法进行同步，那么就会实现线程安全即多线程环境下实例的唯一性，如下\r\n\r\n```\r\n// final modifier, no inheritance allowed.\r\npublic final class Singleton {\r\n\r\n    // Some business code.\r\n    \r\n    private static Singleton instance = null;\r\n    \r\n    // Private constructor, no external `new` is allowed.\r\n    private Singleton() {\r\n        \r\n    }\r\n    \r\n    public static synchronized Singleton getInstance() {\r\n        if (null == instance) {\r\n            instance = new Singleton();\r\n        }\r\n        return instance;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n同样的测试代码，输出为\r\n\r\n```\r\nthread-3 tech.feily.doc.thread.Singleton@5dd54814\r\nthread-2 tech.feily.doc.thread.Singleton@5dd54814\r\nthread-0 tech.feily.doc.thread.Singleton@5dd54814\r\nthread-6 tech.feily.doc.thread.Singleton@5dd54814\r\nthread-5 tech.feily.doc.thread.Singleton@5dd54814\r\nthread-9 tech.feily.doc.thread.Singleton@5dd54814\r\nthread-1 tech.feily.doc.thread.Singleton@5dd54814\r\nthread-4 tech.feily.doc.thread.Singleton@5dd54814\r\nthread-7 tech.feily.doc.thread.Singleton@5dd54814\r\nthread-8 tech.feily.doc.thread.Singleton@5dd54814\r\n```\r\n\r\n没毛病了。但是`synchronized`关键字又导致了`getInstance()`方法只能在同一时刻被一个线程访问，性能低下。\r\n\r\n## 四、Double-Check\r\n\r\n顾名思义，这种办法就是**检查两次**，作为解决**懒汉式 + 同步方法**方法的性能低下的缺陷，如下\r\n\r\n```\r\n// final modifier, no inheritance allowed.\r\npublic final class Singleton {\r\n\r\n    // Some business code.\r\n    \r\n    private static Singleton instance = null;\r\n    \r\n\tConnection conn;\r\n\tSocket socket;\r\n\t\r\n    // Private constructor, no external `new` is allowed.\r\n    private Singleton() {\r\n\t    this.conn;\r\n\t\tthis.socket;\r\n    }\r\n    \r\n    public static Singleton getInstance() {\r\n        if (null == instance) {\r\n            synchronized (Singleton.class) {\r\n                if (null == instance) {\r\n                    instance = new Singleton();\r\n                }\r\n            }\r\n        }\r\n        return instance;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n这种办法很巧妙的解决了**懒汉式 + 同步方法**方法的性能低下的缺陷，不仅有懒汉式的懒加载，还有了同步方法带来的实例的唯一性，而且通过缩小锁的粒度提供了高效的数据同步策略，可以允许多个线程同时对getInstance()访问，但是现在的问题是，这种方式在多线程情况下可能会引起空指针异常。\r\n\r\n在Singleton的构造函数中，需要分别实例化conn和socket两个资源，还有Singtelon自身，根据JVM运行时指令重排序和Happens-Before规则，这三者之间的实例化顺序并无前后约束关系，那么极有可能是instance最先被实例化，而conn和socket并未完成实例化。以两个线程为例，第一个线程进入了同步代码块，先创建了instance实例，但是还未来得及创建conn和socket实例便进入就绪状态，线程二判断到instance已经创建便去使用conn和socket，但是实际上并未创建，这样就造成了NPE。\r\n\r\n## 五、Volatile + Double-Check\r\n\r\n作为对Double-Check的NPE缺陷的改进，那么使用Volatile关键字修饰instance就可以避免这种重排序的发声，即\r\n\r\n```\r\nprivate volatile static Singleton instance = null;\r\n```\r\n\r\n这样就满足了多线程下的单例、懒加载和获取实例的高效性需求。\r\n\r\n## 六、Holder方式\r\n\r\nHolder方式完全借助了类加载的特点，如下\r\n\r\n```\r\n// final modifier, no inheritance allowed.\r\npublic final class Singleton {\r\n\r\n    // Some business code.\r\n    \r\n    // Private constructor, no external `new` is allowed.\r\n    private Singleton() {\r\n    }\r\n    \r\n    private static class Holder {\r\n        private static Singleton instance = new Singleton();\r\n    }\r\n    \r\n    public static Singleton getInstance() {\r\n        return Holder.instance;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n在Singleton类中并没有instance静态成员，而是将其放到了静态内部类Holder中，因此在Singleton类的初始化过程中并不会创建Singleton的实例，Holder类中定义了Singleton的静态变量，并且直接进行了实例化，当Holder被主动引用时会创建Singleton实例，Singleton实例的创建过程在Java程序编译时期收集至`\u003cclinit\u003e()`方法中，该方法又是同步方法，同步方法可以保证内存的可见性、JVM指令的顺序性和原子性，所以该模式应用较广。","cover":"/images/java.jpg","link":"design-of-seven-kinds-of-singleton-patterns.html","preview":"\u003cp\u003e单例模式提供了一种在多线程情况下保证实例唯一性的解决方案，单例模式设计的标准是：懒加载、高性能、线程安全。\u003c/p\u003e\n","title":"七种单例模式的设计"},{"content":"\r\n\r\n类加载器的职责就是负责类的加载，对于任意一个class，都需要由加载它的类加载器和这个类本身确立其在JVM中的唯一性，这也就是运行时包。\r\n\r\n## 一、JVM内置的三大类加载器\r\n\r\nJVM提供内置的三大类加载器，不同的类加载器负责将不同的类加载到JVM内存之中，并且它们之间严格遵守着父委托机制，如下图所示\r\n\r\n![](/images/article/jvm-class-loader1.jpg)\r\n\r\n\u003e 图片来源：http://www.cnblogs.com/huizhi/p/10177126.html\r\n\r\n### 1.1 根类加载器\r\n\r\n又称Bootstrap类加载器，该类加载器是最顶层的类加载器，没有任何父加载器，由C++编写，主要负责虚拟机核心类库的加载，比如整个java.lang包都是由根加载器所加载，可以通过`-Xbootclasspath`来指定根加载器的路径,也可以通过系统属性来得知当前JVM的根加载器都加载了哪些资源。\r\n\r\n```\r\npublic class BootstrapClassLoader {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(\"Bootstrap:\" + String.class.getClassLoader());\r\n        System.out.println(System.getProperty(\"sun.boot.class.path\").replace(\";\", \"\\n\"));\r\n    }\r\n\r\n}\r\n```\r\n\r\n上述代码获取了String类的类加载器以及根加载器所在的加载路径，输出为\r\n\r\n```\r\nBootstrap:null\r\nC:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\resources.jar\r\nC:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\rt.jar\r\nC:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\sunrsasign.jar\r\nC:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jsse.jar\r\nC:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jce.jar\r\nC:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\charsets.jar\r\nC:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\jfr.jar\r\nC:\\Program Files\\Java\\jdk1.8.0_201\\jre\\classes\r\n```\r\n\r\n由于`String.class`的类加载器是根加载器，而根加载器是获取不到引用的，所以输出为null。\r\n\r\n### 1.2 扩展类加载器\r\n\r\n扩展类加载器的父加载器是根加载器，主要是用于加载`JAVA_HOME`下的`jre/lib/ext`子目录里面的类库，由纯Java语言实现，扩展类加载器所加载的类库可以通过系统属性`java.ext.dirs`获得，如下\r\n\r\n```\r\npublic class ExtClassLoader {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(System.getProperty(\"java.ext.dirs\").replace(\";\", \"\\n\"));\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nC:\\Program Files\\Java\\jdk1.8.0_201\\jre\\lib\\ext\r\nC:\\Windows\\Sun\\Java\\lib\\ext\r\n```\r\n\r\n也可以将自己的类打包为jar，然后放到扩展类加载器所在的路径中，扩展类加载器会负责加载自己所需要的类。\r\n\r\n### 1.3 系统类加载器\r\n\r\n系统类加载器是一种常见的类加载器，其负责加载classpath下的类库资源。系统类加载器的父加载器是扩展类加载器，同时也是自定义类加载器的默认父加载器，系统类加载器的加载路径一般通过`-classpath`或者`-cp`指定，同样也可以通过系统属性`java.class.path`获取，如下\r\n\r\n```\r\npublic class SysClassLoader {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(System.getProperty(\"java.class.path\").replace(\";\", \"\\n\"));\r\n        System.out.println(SysClassLoader.class.getClassLoader());\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nD:\\R-Java\\REngine.jar\r\nD:\\R-Java\\RserveEngine.jar\r\nC:\\Users\\Administrator\\eclipse-workspace\\Demo\\bin\r\nsun.misc.Launcher$AppClassLoader@6d06d69c\r\n```\r\n\r\n## 二、自定义类加载器\r\n\r\n自定义类加载器都是ClassLoader的直接子类或者间接子类，`java.lang.ClassLoader`是一个抽象类，但是里面并没有抽象方法，但是有`findClass`方法，自定义类加载器务必重写该方法，否则会抛出Class找不到的异常。\r\n\r\n一个自定义类加载器如下所示\r\n\r\n```\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\n\r\npublic class MyClassLoader extends ClassLoader {\r\n\r\n    private final static Path DEFAULT_CLASS_DIR = Paths.get(\"D:\", \"classloader\");\r\n    private final Path classDir;\r\n    \r\n    public MyClassLoader() {\r\n        super();\r\n        this.classDir = DEFAULT_CLASS_DIR;\r\n    }\r\n    \r\n    public MyClassLoader(String classDir) {\r\n        super();\r\n        this.classDir = Paths.get(classDir);\r\n    }\r\n    \r\n    public MyClassLoader(String classDir, ClassLoader parent) {\r\n        super(parent);\r\n        this.classDir = Paths.get(classDir);\r\n    }\r\n    \r\n    \r\n    /*\r\n     * Method of overwriting parent class.\r\n     * (non-Javadoc)\r\n     * @see java.lang.ClassLoader#findClass(java.lang.String)\r\n     */\r\n    @Override\r\n    protected Class\u003c?\u003e findClass(String name) throws ClassNotFoundException {\r\n        // Read class binary data.\r\n        byte[] classBytes = this.readClassBytes(name);\r\n        // If the data is null, or no information was read, then throw ClassNotFoundException.\r\n        if (null == classBytes || classBytes.length == 0) {\r\n            throw new ClassNotFoundException(\"Can not load the class \" + name);\r\n        }\r\n        // Calling defineClass method define class.\r\n        return this.defineClass(name, classBytes, 0, classBytes.length);\r\n    }\r\n    \r\n    /*\r\n     * Read the class file into memory.\r\n     */\r\n    private byte[] readClassBytes(String name) throws ClassNotFoundException {\r\n        // Converting a package delimiter to a file path delimiter.\r\n        String classPath = name.replace(\".\", \"/\");\r\n        Path classFullPath = classDir.resolve(Paths.get(classPath + \".class\"));\r\n        if (!classFullPath.toFile().exists()) {\r\n            throw new ClassNotFoundException(\"The class \" + name + \" not found.\");\r\n        }\r\n        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\r\n            Files.copy(classFullPath, baos);\r\n            return baos.toByteArray();\r\n        } catch (IOException e) {\r\n            throw new ClassNotFoundException(\"load the class \" + name + \" occur error.\", e);\r\n        }\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return \"My ClassLoader\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n以上是一个简单的基于磁盘的类加载器，共有三个构造器，分别为\r\n\r\n+ 第一个构造器使用默认的文件路径；\r\n+ 第二个构造器允许从外部指定一个特定的磁盘目录；\r\n+ 第三个构造器除了可以指定磁盘目录之外还可以指定该类加载器的父加载器。\r\n\r\n在上述定义的自定义类加载器中，将类的权限定名转换成文件的全路径然后读取class文件的字节流数据，最后使用`defineClass`方法对class完成了定义。\r\n\r\n以下再编写一个简单的程序，通过如下自定义类加载器进行加载。\r\n\r\n```\r\npublic class HelloWorld {\r\n\r\n    static {\r\n        System.out.println(\"Hello World Class is Initialized.\");\r\n    }\r\n    \r\n    public String welcome() {\r\n       return \"Hello, World\";\r\n    }\r\n    \r\n}\r\n```\r\n\r\n如果用的是IDE，那么编译完成后需要将包下的`HelloWorld.class`文件(连同包)复制到加载器默认文件路径下并且删除IDE工作空间下的`HelloWorld.class`和`HelloWorld.java`文件，否则JVM仍然会通过系统类加载器所加载(这是由于类加载器的双亲委托机制所导致的)，接下来进行加载，如下\r\n\r\n```\r\npublic class MyClassLoaderTest {\r\n\r\n    public static void main(String[] args) throws ClassNotFoundException {\r\n        MyClassLoader myClassLoader = new MyClassLoader();\r\n        Class\u003c?\u003e aClass = myClassLoader.loadClass(\"tech.feily.doc.thread.HelloWorld\");\r\n        System.out.println(aClass.getClassLoader());\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nMy ClassLoader\r\n```\r\n\r\n可见是通过自定义类加载器加载的，这里通过一种变相的方式打破了双亲委托机制。还有两种方式来打破，等会介绍。\r\n\r\n而且上述程序也验证了**类加载器也不会导致类的初始化**，因为HelloWorld程序中静态代码块并未得到执行，即在初始化阶段静态代码会得到执行的，但是并没有执行，所以得到了类加载器不会导致类主动初始化的结论。\r\n\r\n如果再通过反射操作来执行代码，那么将会输出，修改一下\r\n\r\n```\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\n\r\npublic class MyClassLoaderTest {\r\n\r\n    public static void main(String[] args) \r\n            throws ClassNotFoundException, InstantiationException, \r\n            IllegalAccessException, NoSuchMethodException, SecurityException, \r\n            IllegalArgumentException, InvocationTargetException {\r\n        MyClassLoader myClassLoader = new MyClassLoader();\r\n        Class\u003c?\u003e aClass = myClassLoader.loadClass(\"tech.feily.doc.thread.HelloWorld\");\r\n        System.out.println(aClass.getClassLoader());\r\n        \r\n        // Here the static code block is executed.\r\n        Object helloWorld = aClass.newInstance();\r\n        System.out.println(helloWorld);\r\n        Method welcomeMethod = aClass.getMethod(\"welcome\");\r\n        String result = (String) welcomeMethod.invoke(helloWorld);\r\n        System.out.println(\"Result: \" + result);\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nMy ClassLoader\r\nHello World Class is Initialized.\r\ntech.feily.doc.thread.HelloWorld@2328c243\r\nResult: Hello, World\r\n```\r\n\r\n## 三、双亲委托机制\r\n\r\n有一张图很好的说明了类加载器的双亲委托机制，如下\r\n\r\n![](/images/JVM-class-loader.jpg)\r\n\r\n\u003e 图片来源：该图尚无法找到原始出处\r\n\r\n\r\n上图双亲委托机制的源码描述片段为\r\n\r\n```\r\npublic Class\u003c?\u003e loadClass(String name) throws ClassNotFoundException {\r\n    return loadClass(name, false);\r\n}\r\n\r\nprotected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException {\r\n    synchronized (getClassLoadingLock(name)) {\r\n\t    Class\u003c?\u003e c = findLoadedClass(name);    // ①\r\n\t\tif (c == null) {\r\n\t\t    long t0 = System.nanoTime();\r\n\t\t\ttry {\r\n\t\t\t    if (parent != null) {\t// ②\r\n\t\t\t\t    c = parent.loadClass(name, false);    // ③\r\n\t\t\t\t} else {\r\n\t\t\t\t    c = findBootstrapClassOrNull(name);    // ④\r\n\t\t\t\t}\r\n\t\t\t} catch (ClassNotFoundException e) {\r\n\t\t\t\r\n\t\t\t}\r\n\t\t    if (c == null) {\r\n\t\t\t    long t1 = System.nanoTime();\r\n\t\t\t\tc = findClass(name);    // ⑤\r\n\t\t\t\tsun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\r\n\t\t\t\tsun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\r\n\t\t\t\tsun.misc.PerfCounter.getFindClasses().increment();\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (resolve) {\r\n\t\t    resolveClass(c);\r\n\t\t}\r\n\t\treturn c;\r\n\t}\r\n}\r\n```\r\n\r\n解释如下\r\n\r\n+ ①：从当前类加载器的缓存中根据类的全路径名查询是否存在该类，如果存在则直接返回(即后面的if条件就不满足了，直接就return了)；\r\n+ ②③：如果当前类加载器缓存中不存在该类，那么进入if判断，如果当前类存在父类加载器，那么就调用父类加载器的loadClass方法对该类进行加载，即执行③；\r\n+ ④：如果当前类不存在父类加载器那么就用根类加载器对该类进行加载；\r\n+ ⑤：如果当前类的所有父类加载器都没有成功加载class，那么就尝试调用当前类加载器的`findClass`方法对其进行加载，**该方法就是我们自定义类加载器需要重写的方法；**\r\n+ 最后如果类被成功加载，就做一些性能数据的统计；\r\n+ 由于`loadClass`指定了`resolve`为`false`，所以不会进行连接阶段的继续进行，**这也就解释了为什么通过类加载器加载类并不会导致类的初始化。**\r\n\r\n另外两种自定义类加载器绕过双亲委托机制加载类的办法分别是：\r\n\r\n+ 一种办法是，**直接将拓展类加载器作为自定义类加载器的父加载器，**示例代码如下\r\n\r\n```\r\npublic class MyClassLoaderTest {\r\n\r\n    public static void main(String[] args) throws ClassNotFoundException {\r\n        ClassLoader extClassLoader = MyClassLoader.class.getClassLoader().getParent();\r\n        MyClassLoader myClassLoader = new MyClassLoader(\"D:\\\\classloader\", extClassLoader);\r\n        Class\u003c?\u003e aClass = myClassLoader.loadClass(\"tech.feily.doc.thread.HelloWorld\");\r\n        System.out.println(aClass.getClassLoader());\t// My ClassLoader\r\n    }\r\n\r\n}\r\n```\r\n\r\n+ 另一种办法是，**在构造自定义类加载器的时候指定父类加载器为null，**示例如下\r\n\r\n```\r\npublic class MyClassLoaderTest {\r\n\r\n    public static void main(String[] args) throws ClassNotFoundException {\r\n        MyClassLoader myClassLoader = new MyClassLoader(\"D:\\\\classloader\", null);\r\n        Class\u003c?\u003e aClass = myClassLoader.loadClass(\"tech.feily.doc.thread.HelloWorld\");\r\n        System.out.println(aClass.getClassLoader());\t// My ClassLoader\r\n    }\r\n\r\n}\r\n```\r\n\r\n上述破坏类加载器的双亲委托机制是通过绕过系统类加载器（SystemClassLoader）实现的，但是并没有避免一层一层的委托，还有一种更为稳健的办法就是**通过在自定义类加载器中重写`loadClass`方法来实现。**\r\n\r\n## 四、重写loadClass方法来打破双亲委托机制\r\n\r\n对上述自定义类加载器做如下改动，即增加重写的classLoad方法，为\r\n\r\n```\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.file.Files;\r\nimport java.nio.file.Path;\r\nimport java.nio.file.Paths;\r\n\r\npublic class MyClassLoader extends ClassLoader {\r\n\r\n    private final static Path DEFAULT_CLASS_DIR = Paths.get(\"D:\", \"classloader\");\r\n    private final Path classDir;\r\n    \r\n    public MyClassLoader() {\r\n        super();\r\n        this.classDir = DEFAULT_CLASS_DIR;\r\n    }\r\n    \r\n    public MyClassLoader(String classDir) {\r\n        super();\r\n        this.classDir = Paths.get(classDir);\r\n    }\r\n    \r\n    public MyClassLoader(String classDir, ClassLoader parent) {\r\n        super(parent);\r\n        this.classDir = Paths.get(classDir);\r\n    }\r\n    \r\n    \r\n    /*\r\n     * Method of overwriting parent class.\r\n     * (non-Javadoc)\r\n     * @see java.lang.ClassLoader#findClass(java.lang.String)\r\n     */\r\n    @Override\r\n    protected Class\u003c?\u003e findClass(String name) throws ClassNotFoundException {\r\n        // Read class binary data.\r\n        byte[] classBytes = this.readClassBytes(name);\r\n        // If the data is null, or no information was read, then throw ClassNotFoundException.\r\n        if (null == classBytes || classBytes.length == 0) {\r\n            throw new ClassNotFoundException(\"Can not load the class \" + name);\r\n        }\r\n        // Calling defineClass method define class.\r\n        return this.defineClass(name, classBytes, 0, classBytes.length);\r\n    }\r\n    \r\n    /*\r\n     * Read the class file into memory.\r\n     */\r\n    private byte[] readClassBytes(String name) throws ClassNotFoundException {\r\n        // Converting a package delimiter to a file path delimiter.\r\n        String classPath = name.replace(\".\", \"/\");\r\n        Path classFullPath = classDir.resolve(Paths.get(classPath + \".class\"));\r\n        if (!classFullPath.toFile().exists()) {\r\n            throw new ClassNotFoundException(\"The class \" + name + \" not found.\");\r\n        }\r\n        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\r\n            Files.copy(classFullPath, baos);\r\n            return baos.toByteArray();\r\n        } catch (IOException e) {\r\n            throw new ClassNotFoundException(\"load the class \" + name + \" occur error.\", e);\r\n        }\r\n    }\r\n    \r\n    @Override\r\n    public String toString() {\r\n        return \"My ClassLoader\";\r\n    }\r\n    \r\n    @Override\r\n    protected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException {\r\n        synchronized(getClassLoadingLock(name)) {    // ①\r\n\t\t    // ②\r\n            Class\u003c?\u003e cls = findLoadedClass(name);\r\n\t\t\t// ③\r\n            if (cls == null) {\r\n\t\t\t    // ④\r\n                if (name.startsWith(\"java.\") || name.startsWith(\"javax\")) {\r\n                    try {\r\n                        cls = getSystemClassLoader().loadClass(name);\r\n                    } catch (Exception e) {\r\n                        \r\n                    }\r\n                } else {\r\n\t\t\t\t    // ⑤\r\n                    try {\r\n                        cls = this.findClass(name);\r\n                    } catch (ClassNotFoundException e) {\r\n                        \r\n                    }\r\n\t\t\t\t\t// ⑥\r\n                    if (cls == null) {\r\n                        if (getParent() != null) {\r\n                            cls = getParent().loadClass(name);\r\n                        } else {\r\n                            cls= getSystemClassLoader().loadClass(name);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\t\t\t// ⑦\r\n            if (null == cls) {\r\n                throw new ClassNotFoundException(\"The class \" + name + \" not found.\");\r\n            }\r\n            if (resolve) {\r\n                resolveClass(cls);\r\n            }\r\n            return cls;\r\n        }\r\n    }\r\n    \r\n}\r\n```\r\n\r\n代码还是很好理解的，与**双亲委托机制的源码描述片段**的理解同理，详细的代码解释如下\r\n\r\n+ ①：根据类的全路径名称进行加锁，确保每一个类在多线程的情况下只被加载一次；\r\n+ ②：到已加载类的缓存中查看该类是否已经被加载，如果已加载则直接返回；\r\n+ ③④：若缓存中没有被加载的类，则需要对其进行首次加载，如果类的全路径以`java`和`javax`开头，(那么说明是核心类库，)则直接委托给系统类加载器对其进行加载；\r\n+ ⑤如果类不是以`java`或`javax`开头，则尝试用我们自定义的类加载器进行加载；\r\n+ ⑥若自定义类加载器仍旧没有完成对类的加载，则委托给其父类加载器进行加载或者系统类加载器进行加载；\r\n+ ⑦经过若干次尝试之后，如果还是无法对类进行加载，则抛出无法找到类的异常。\r\n\r\n然后现在即使是IDE下,不用删除`HelloWorld.java`与`HelloWorld.class`文件仍然能够通过自定义类加载器加载HelloWorld。","cover":"/images/JVM-class-loader.jpg","link":"jvm-class-loader.html","preview":"\u003cp\u003e类加载器的职责就是负责类的加载，对于任意一个class，都需要由加载它的类加载器和这个类本身确立其在JVM中的唯一性，这也就是运行时包。\u003c/p\u003e\n","title":"JVM类加载器"},{"content":"\r\n\r\nClassLoader的主要职责就是负责加载各种class文件到JVM中，ClassLoader是一个抽象的class，给定一个class的二进制文件名，ClassLoader会尝试加载并且在JVM中生成构成这个类的各个数据结构，然后使其分布在JVM对应的内存区域中。\r\n\r\n## 一、类的加载过程\r\n\r\n类的加载过程一般分为三大步，分别是加载阶段、连接阶段、初始化阶段，如下图所示\r\n\r\n![](/images/article/class-load-process.jpg)\r\n\r\n\u003e 图片来源：http://www.cnblogs.com/chenpi/p/5393650.html\r\n\r\n+ 加载阶段：主要负责查找并且加载类的二进制数据文件，其实就是class文件；\r\n+ 连接阶段：主要包括如下三个方面；\r\n  - 验证：主要是确保类文件的正确性，比如class的版本、魔数等是否正确；\r\n  - 准备：为类的静态变量分配内存，并且为其初始化默认值；\r\n  - 解析：把类中的符号引用转换为直接引用。\r\n+ 初始化阶段：为类的静态变量赋予正确的初始值。\r\n\r\n当一个JVM在我们通过执行Java命令启动之后，其中可能包含的类非常多，并不是所有的类都会被初始化。JVM对类的初始化是一个延迟的机制，即使用的是lazy的方式，当一个类在首次**主动使用**时在会被初始化，在同一个运行时包下，一个Class只会被初始化一次。那么什么是主动使用呢？\r\n\r\n## 二、主动使用与被动使用\r\n\r\nJVM虚拟机规范规定了，每个类或者接口被Java程序首次主动使用时才会对其进行初始化，JVM规范了以下6种主动使用类的场景：\r\n\r\n+ 通过`new`关键字会导致相应类的初始化；\r\n+ 访问类的静态`变量`会导致相应类的初始化；\r\n+ 访问类的静态方法会导致相应类的初始化；\r\n+ 对某个类进行反射操作，会导致相应类的初始化；\r\n+ 初始化子类会导致对应父类的初始化（但是需要注意的是，通过子类使用父类的静态变量只会导致父类的初始化，子类不会被初始化）；\r\n+ 启动类，即`main`函数所在的类会导致该类的初始化。\r\n\r\n除了以上6种情况，其余均属于被动使用，不会导致类的加载和初始化。\r\n\r\n还有两种情况需要注意，分别是\r\n\r\n+ 构造某个类的数组时并不会导致该类的初始化；\r\n\r\n```\r\npublic static void main(String[] args) {\r\n    Simple[] simple = new Simple[10];\r\n\tSystem.out.println(simple.length);\r\n}\r\n```\r\n即上述代码并不会导致类的初始化，虽然仍然使用了new关键字，但是实际上只是建立了一个Simple型的数组，只是在堆内存中开辟了一段4byte × 10的连续地址空间。\r\n\r\n+ 引用类的静态常量不会导致类的初始化。\r\n\r\n即被final修饰的静态常量被其它类访问是不会导致该类的初始化的。\r\n\r\n## 三、类的详细加载过程详解\r\n\r\n### 3.1 类的加载阶段\r\n\r\n**类的加载就是将class文件中的二进制数据读取到内存中，然后将该字节流所代表的静态存储结构转换为方法区中运行时的数据结构，并且在堆内存中生成一个该类的java.lang.Class对象，作为访问方法区数据结构的入口。**\r\n\r\n类加载的最终产物就是堆内存中的class对象，对同一个ClassLoader来讲，不管某个类被加载了多少次，对应到堆内存中的class对象始终是同一个。虚拟机规范中指出了类的加载是通过一个全限定名(包名+类名)来获取二进制数据流，但是并没有限定必须通过何种方式去获得，**常见的是通过class二进制文件的形式**，但除此之外还有其他形式：\r\n\r\n+ 运行时动态生成；\r\n+ 通过网络获取；\r\n+ 通过读取zip文件获得类的二进制字节流；\r\n+ 将类的二进制数据压缩在数据库的BLOB字段类型中；\r\n+ 运行时生成class文件，并且动态加载。\r\n\r\n### 3.2 类的连接阶段\r\n\r\n可以分为三个步骤，分别是验证、准备和解析。\r\n\r\n#### 3.2.1 验证\r\n\r\n验证的主要目的就是确保class文件的字节流所包含的内容符合当前JVM的规范要求，并且不会出现危害JVM自身安全的代码。当字节流信息不符合要求时，将会抛出VerifyError这样的异常或者其子异常。验证的内容主要包括：\r\n\r\n+ 验证文件格式：包括魔数、版本号、MD5指纹、常量池是否存在不被支持的变量类型(比如int64)、指向常量中的引用是否指到了不存在的常量或者该常量的类型不被支持等；\r\n+ 验证元数据（其实就是对class的字节流进行语义分析的过程）：检查该类是否存在父类、检查该类是否继承了被final修饰的类、检查该类是否为抽象类如果是抽象类那么它是否实现了父类的抽象方法或者接口中的所有方法、检查方法重载的合法性以及 其它语义验证；\r\n+ 字节码验证（主要是验证程序的控制流程，比如循环和分支等）：保证当前线程在程序计数器中的指令不会跳转到不合法的字节码指令中去、保证类型转换是合法的、保证任意时刻虚拟机栈中的操作栈类型与指令代码都能正确地被执行、其它验证；\r\n+ 符号引用验证（主要作用是验证符号引用转化为直接引用时的合法性，主要目的就是为了保证解析动作的顺利执行）：通过符号引用描述的字符串全限定名是否能够顺利的找到相关的类、符号引用中的类(、字段、方法)是否对当前类可见等。\r\n\r\n#### 3.2.2 准备\r\n\r\n当一个class对象的字节流通过了所有的验证过程之后，就开始为该对象的类变量(即静态变量)分配内存并且赋默认值，类变量的内存会被分配到方法区中，不同于实例变量会被分配到堆内存之中。\r\n\r\n#### 3.2.3 解析\r\n\r\n解析就是在常量池中寻找类、接口、字段和方法的符号应用，并且将这些符号引用替换为直接引用的过程，解析过程中照样会进行一些交叉验证，比如符号引用的验证。\r\n\r\n### 3.3 类的初始化阶段\r\n\r\n类的初始化阶段就是整个类加载过程中的最后一个阶段，在该阶段最主要的一件事情就是执行`\u003cclinit\u003e()`方法，该方法是在编译阶段生成的，包含了所有的类变量和静态语句块中的代码，在此阶段所有的类变量都会被赋予正确的值。但是需要注意的是，静态语句块只能对后面的静态变量赋值但是不能对其访问，比如\r\n\r\n```\r\npublic class ClassInit {\r\n    static {\r\n\t    System.out.println(x);\r\n\t\tx = 100;\r\n\t}\r\n\tprivate static int x = 10;\r\n}\r\n```\r\n以上代码无法编译通过，因为静态语句块只能执行静态变量的赋值但是不能访问静态变量。\r\n\r\n另外`\u003cclinit\u003e()`方法与类的构造函数不同，它不需要显示的调用父类的构造器，虚拟机会保证父类的`\u003cclinit\u003e()`方法最先执行，因此父类的静态变量总是能够得到优先赋值。\r\n\r\n另外，JVM保证了`\u003cclinit\u003e()`方法在多线程的执行环境下的同步语义，即`\u003cclinit\u003e()`方法中的代码在多线程并发的环境下只会被某一个线程执行且只会被执行这一次，也就是说不会重复的执行`\u003cclinit\u003e()`方法(初始化静态变量和静态语句块)。\r\n\r\n## 四、一个例子\r\n\r\n在上述类加载机制的基础上分析以下代码会输出什么\r\n\r\n```\r\npublic class Singleton {\r\n\r\n    private static int x = 0;\r\n    private static int y;\r\n    private static Singleton instance = new Singleton();\r\n    \r\n    private Singleton() {\r\n        x++;\r\n        y++;\r\n    }\r\n    \r\n    public static Singleton getInstance() {\r\n        return instance;\r\n    }\r\n    \r\n    public static void main(String[] args) {\r\n        Singleton singleton = Singleton.getInstance();\r\n        System.out.println(singleton.x);\r\n        System.out.println(singleton.y);\r\n    }\r\n\r\n}\r\n```\r\n\r\n我们重点关注准备和初始化阶段，因为这是最重要的我们可以直观感受到的阶段\r\n\r\n首先在准备过程中，类变量被赋予默认值，如下\r\n\r\n```\r\nx = 0;\r\ny = 0;\r\ninstance = null;\r\n```\r\n\r\n然后在初始化阶段中执行`\u003cclinit\u003e()`方法，类变量被赋予正确值，如下\r\n\r\n```\r\nx = 0;\r\ny = 0;\r\ninstance = new Singleton();\r\n```\r\n\r\n在`new Singleton()`的时候会执行类的构造函数，而在构造函数中分别对x和y进行了自增操作，所以结果为\r\n\r\n```\r\nx = 1;\r\ny = 1;\r\n```\r\n\r\n现在调换一下`private static Singleton instance = new Singleton()`的顺序，如下\r\n\r\n```\r\npublic class Singleton {\r\n\r\n    private static Singleton instance = new Singleton();\r\n    private static int x = 0;\r\n    private static int y;\r\n    \r\n    private Singleton() {\r\n        x++;\r\n        y++;\r\n    }\r\n    \r\n    public static Singleton getInstance() {\r\n        return instance;\r\n    }\r\n    \r\n    public static void main(String[] args) {\r\n        Singleton singleton = Singleton.getInstance();\r\n        System.out.println(singleton.x);\r\n        System.out.println(singleton.y);\r\n    }\r\n\r\n}\r\n```\r\n\r\n同样的在准备阶段，结果为\r\n\r\n```\r\ninstance = null;\r\nx = 0;\r\ny = 0;\r\n```\r\n\r\n初始化阶段中，在`new Singleton()`的时候会执行类的构造函数，执行结果为\r\n\r\n```\r\nx = 1;\r\ny = 1;\r\n```\r\n\r\n然后顺序继续初始化静态变量x，由于x没有显式地进行赋值，因此0才是所期望的正确赋值，再继续初始化静态变量y，由于y没有给定初始值，所在在构造函数中计算所得的值就是所谓的正确赋值，最终结果为\r\n\r\n```\r\nx = 0;\r\ny = 1;\r\n```","cover":"/images/article/class-load-process.jpg","link":"class-loading-process.html","preview":"\u003cp\u003eClassLoader的主要职责就是负责加载各种class文件到JVM中，ClassLoader是一个抽象的class，给定一个class的二进制文件名，ClassLoader会尝试加载并且在JVM中生成构成这个类的各个数据结构，然后使其分布在JVM对应的内存区域中。\u003c/p\u003e\n","title":"类的加载过程"},{"content":"\r\n\r\n## 一、数据备份\r\n\r\n### 1.1 使用mysqldump命令备份\r\n\r\n备份单个数据库中的所有表，以booksdb数据库为例\r\n\r\n```\r\nmysqldump -u root - p booksdb \u003e C:/backup/dbs.sql\r\n```\r\n\r\n备份单个数据库中的某个表，如下\r\n\r\n```\r\nmysqldump -u root - p booksdb table_name \u003e C:/backup/dbs.sql\r\n```\r\n\r\n备份多个数据库，如下\r\n\r\n```\r\nmysqldump -u root - p --databases booksdb booksdb1 \u003e C:/backup/dbs.sql\r\n```\r\n\r\n备份所有数据库，如下\r\n\r\n```\r\nmysqldump -u root - p --all-databases \u003e C:/backup/dbs.sql\r\n```\r\n\r\n### 1.2 直接复制整个数据库目录\r\n\r\n这种方法对InnoDB存储引擎的表不适用。使用这种方法备份的数据最好还原到相同版本的服务器中，不同的版本可能不兼容。\r\n\r\n### 1.3 使用mysqlhotcopy工具快速备份\r\n\r\n这是备份数据库或者单个表最快的途径，但是该工具只能运行在数据库目录所在的机器上，并且只能备份MyISAM和ARCHIVE类型的表。\r\n\r\n该工具在Unix系统中使用方法为，比如将test数据库备份到/usr/backup目录下，命令为\r\n\r\n```\r\nmysqlhotcopy -u root -p test /usr/backup\r\n```\r\n\r\n需要注意的是，要想执行`mysqlhotcopy`，必须可以访问备份的表文件，具有那些表的SELECT权限、RELOAD权限（以便能够执行FLUSH TABLES）和LOCK TABLES权限。\r\n\r\n## 二、数据还原\r\n\r\n### 2.1 使用MySQL命令还原\r\n\r\n```\r\nmysql -u root -p booksDB \u003c C:/backup/dbs.sql\r\n```\r\n\r\n### 2.2 使用source命令还原\r\n\r\n前提是已经登录MySQL服务器，然后选择一个数据库，再执行命令\r\n\r\n```\r\nsource C:/backup/dbs.sql\r\n```\r\n\r\n### 2.3 直接复制数据库到数据库目录\r\n\r\n如果数据库通过复制数据库文件备份，那么就可以使用这种方式。\r\n\r\n### 2.4 mysqlhotcopy快速恢复\r\n\r\nmysqlhotcopy备份的文件也可以用来恢复数据库，在MySQL停止运行时，将备份的数据库文件复制到MySQL存放数据的位置（MySQL的data文件夹），重新启动MySQL服务器即可。即\r\n\r\n```\r\ncp -R /usr/backup/test /usr/local/mysql/data\r\n```\r\n\r\n如果以根用户执行该操作，必须指定数据库文件的所有者，输入语句如下\r\n\r\n```\r\nchown -R mysql.mysql /var/lib/mysql/dbname\r\n```\r\n\r\n执行完该语句，重启服务器，MySQL将会恢复到备份状态。\r\n\r\n## 三、数据库迁移\r\n\r\n### 3.1 相同版本的MySQL数据库之间的迁移\r\n\r\n使用mysqldump和mysql管道命令组合的方式，如下\r\n\r\n```\r\nmysqldump -h www.abc.com -u root -ppassword dbname | mysql -h www.bcd.com -u root -ppassword\r\n```\r\n\r\n如果要迁移全部数据库，那么使用参数`--all-databases`\r\n\r\n### 3.2 不同版本的MySQL数据库之间的迁移\r\n\r\nMySQL服务器升级时，先备份数据文件，再停止服务，然后卸载旧版本，并安装新版MySQL，如果想要保留旧版本中的用户访问控制信息，则需要备份MySQL中的mysql数据库，在新版本MySQL安装完成之后，重新读取备份文件\r\n\r\n## 四、表的导出与导入\r\n\r\n### 4.1 使用SELECT … INTO OUTFILE导出文本文件\r\n\r\n该语句的基本格式为\r\n\r\n```\r\nSELECT columnlist FROM table WHERE condition INTO OUTFILE 'filename'  [OPTIONS]\r\n```\r\n\r\n其中OPTIONS选项为\r\n\r\n+ `FIELDS TERMINATED BY 'value'` : 设置字段之间的分隔字符，可以为单个或多个字符，默认情况下为制表符\"\\t\"。\r\n+ `FIELDS [OPTIONALLY] ENCLOSED BY 'value'` : 设置字段的包围字符，只能为单个字符，如果使用了OPTIONALLY，则只有CHAR和VERCHAR等字符数据字段被包括。\r\n+ `FIELDS ESCAPED BY 'value'` : 设置如何写入或读取特殊字符，只能为单个字符，即设置转义字符，默认值为\"\\\"。\r\n+ `LINES STARTING BY 'value'` : 设置每行数据开头的字符，可以为单个或多个字符，默认情况下不适用任何字符。\r\n+ `LINES TERMINATED BY 'value'` : 设置每行数据结尾的字符，可以为单个或多个字符，默认值为\"\\n\"。\r\n\r\n### 4.2 使用mysqldump命令导出文本文件\r\n\r\n基本格式为\r\n\r\n```\r\nmysqldump -T path -u root -p dbname [tables] [OPTIONS]\r\n```\r\n\r\n其中OPTIONS选项为\r\n\r\n+ `--fields-terminated-by=value` : 设置字段之间的分隔字符，可以为单个或多个字符，默认情况下为制表符；\r\n+ `--fields-enclosed-by=value` : 设置字段的包围字符；\r\n+ `--field-optionally-enclosed-by=value` : 设置字段的包围字符，只能为单个字符，只能包括CHAR和VERCHAR等字符数据字段；\r\n+ `--fields-escaped-by=value` : 控制如何写入或读取特殊字符，只能为单个字符，即设置转义字符，默认值为反斜线“\\n”；\r\n+ `--lines-terminated-by=value` : 设置每行数据结尾的字符，可以为单个或多个字符，默认值为“\\n”。\r\n\r\n### 4.3 用MySQL命令导出文本文件\r\n\r\n基本格式如下\r\n\r\n```\r\nmysql -u root -p --execute=\"sql\" dbname \u003e filename.txt\r\n```\r\n\r\n还可以导出为html文件，只需要加上参数`--html`即可，如下\r\n\r\n```\r\nmysql -u root -p --html --execute=\"sql\" dbname \u003e filename.html\r\n```\r\n\r\n### 4.4 使用LOAD DATA INFILE方式导入文本文件\r\n\r\n基本格式为\r\n\r\n```\r\nLOAD DATA INFILE 'filename.txt' INTO TABLE tablename [OPTIONS] [IGNORE number LINES]\r\n```\r\n\r\nOPTIONS选项包括：\r\n\r\n+ `FIELDS TERMINATED BY 'value'` : 设置字段之间的分隔字符，可以为单个或多个字符，默认情况下为制表符\"\\t\"。\r\n+ `FIELDS [OPTIONALLY] ENCLOSED BY 'value'` : 设置字段的包围字符，只能为单个字符，如果使用了OPTIONALLY，则只有CHAR和VERCHAR等字符数据字段被包括。\r\n+ `FIELDS ESCAPED BY 'value'` : 设置如何写入或读取特殊字符，只能为单个字符，即设置转义字符，默认值为\"\\\"。\r\n+ `LINES STARTING BY 'value'` : 设置每行数据开头的字符，可以为单个或多个字符，默认情况下不适用任何字符。\r\n+ `LINES TERMINATED BY 'value'` : 设置每行数据结尾的字符，可以为单个或多个字符，默认值为\"\\n\"。\r\n\r\nIGNORE number LINES选项表示忽略文件开始处的行数，number表示忽略的行数。\r\n\r\n执行LOAD DATA语句需要FILE权限。\r\n\r\n### 4.5 使用mysqlimport命令导入文本文件\r\n\r\n基本格式如下\r\n\r\n```\r\nmysqlimport -u root -p dbname filename.txt [OPTIONS]\r\n```\r\n\r\nOPTIONS常用选项包括：\r\n\r\n+ `--fields-terminated-by=value` : 设置字段之间的分隔字符，可以为单个或多个字符，默认情况下为制表符；\r\n+ `--fields-enclosed-by=value` : 设置字段的包围字符；\r\n+ `--field-optionally-enclosed-by=value` : 设置字段的包围字符，只能为单个字符，只能包括CHAR和VERCHAR等字符数据字段；\r\n+ `--fields-escaped-by=value` : 控制如何写入或读取特殊字符，只能为单个字符，即设置转义字符，默认值为反斜线“\\n”；\r\n+ `--lines-terminated-by=value` : 设置每行数据结尾的字符，可以为单个或多个字符，默认值为“\\n”;\r\n+ `--ignore-lines=n` : 忽略数据文件的前n行。","cover":"/images/mysql-logo.png","link":"data-backup-and-restore.html","preview":"\u003cp\u003e包括数据备份、数据还原、数据库迁移以及导出数据到外部文件。\u003c/p\u003e\n","title":"数据备份与恢复"},{"content":"\r\n\r\n## 一、权限表\r\n\r\nMySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库中，由mysql_install_db脚本初始化。存储账户权限信息表主要有:user、db、host、tables_priv、columns_priv和procs_priv。\r\n\r\n### 1.1 user表\r\n\r\nuser表的字段可以分为四类，分别是用户列、权限列、安全列和资源控制列。\r\n\r\nuser表的用户列包括Host、User、Password，分别表示主机名、用户名和密码，其中Host和User为User表的联合主键。当用户与服务器之间建立连接时，输入的账户信息中的用户名称、主机名和密码必须匹配User表中的对应字段，只有三个值都匹配的时候，才允许连接的建立。\r\n\r\n权限列的字段决定了用户的权限，描述了在全局范围内允许对数据和数据库进行的操作。包括查询权限、修改权限等普通权限，还包括关闭服务器、超级权限和加载用户等高级权限。普通权限用于操作数据库，高级权限用户数据库管理。user表中对应的权限是针对所有用户数据库的，这些字段值的类型为ENUM，可以取的值只能为Y和N。\r\n\r\n安全列只有6个字段，其中两个是ssl相关的，用于加密;2个是x509相关的，用于标识用户;另外两个是授权插件相关的，用于验证用户身份，如果该字段为空，那么服务器使用内建授权验证机制验证用户身份。可以通过`show variables like 'have_openssl'`语句查询服务器是否支持ssl功能。\r\n\r\n资源控制列的字段用来限制用户使用的资源，包含四个字段，分别是\r\n\r\n+ max_questions:用户每小时允许执行的查询操作次数;\r\n+ max_updates:用户每小时允许执行的更新操作次数;\r\n+ max_connections:用户每小时允许执行的连接操作次数;\r\n+ max_user_connections:用户允许同时建立的连接次数。\r\n\r\n### 1.2 db表和host表\r\n\r\ndb表和host表是MySQL数据库中非常重要的权限表，db表中存储了某个主机对数据库的操作权限，决定了用户能从哪个主机存取哪个数据库，host表中存储了某个主机对数据库的操作权限，配合db权限表对给定的主机上的数据库级操作权限做更细致的控制，这个权限表不受grant和revoke语句的影响。db表比较常用，host表一般很少用。db表与host表结构相似，字段大致分为两类:用户列和权限列。\r\n\r\ndb表用户列只有三个字段，分别是Host、User、Db，标识从某个主机连接某个用户对某个数据库的操作权限，这三个字段的组合构成了db表的主键。host表不存储用户名称，只有Host和Db两个字段，该表很少用到，一般情况下db表就可以满足权限控制需求了。\r\n\r\ndb表和host表的权限列大致相同，表中create_routine_priv和alter_routine_priv字段表明用户是否有创建和修改存储过程的权限。\r\n\r\nuser表中的权限是针对所有数据库的，如果希望用户只对某个数据库有操作权限，那么需要将user表中对应的权限设置为N，然后在db表中设置对应数据库的操作权限。例如，有一个名称为Zhangting的用户分别从名称为large.domain.com和small.domain.com的两个主机连接并操作books数据库，那么可以将用户名称Zhangting添加到db表中，而db表中的host字段值为空，然后将两个主机地址分别作为两条记录的host字段值添加到host表中，并将两个表的数据库字段设置为相同的值books。当用户连接MySQL服务器时，db表中没有用户登录的主机名称，则MySQL会从host表中查找相匹配的值，并根据查询的结果决定用户的操作是否被允许。\r\n\r\n### 1.3 tables_priv表和columns_priv表\r\n\r\ntables_priv表用来对表设置操作权限，columns_priv用来对表的某一列设置权限。\r\n\r\ntables_priv表的字段名分别为:Host、User、Db、Table_name、grantor(表示修改该记录的用户)、Timestamp(表示修改该记录的时间)、Table_priv(表示对表的操作权限，包括Select、Update、Insert、Delete、Create、Drop、Grant、References、Index、Alter等)、Column_priv(表示对表中列的操作权限，包括Select、Insert、Update、Refenrences)。\r\n\r\nColumns_priv表字段分别为Host、User、Db、Table_name、Column_name(指定对哪些数据列具有操作权限)、Timestamp、Column_priv。\r\n\r\n### 1.4 procs_priv表\r\n\r\n该表可以对存储过程和存储函数设置操作权限，包含8个字段，分别是Host、Db、User、Routine_name(表示存储过程或函数的名称)、Routine_type(表示存储过程或函数的类型，有两个值，分别是PROCEDURE和FUNCTION，前者表明是存储过程，后者表明是函数)、Grantor(插入或修改该记录的用户)、Proc_priv(表示拥有的关权限，分别为Execute、Alter Routine、Grant)、Timestamp(表示记录更新时间)。\r\n\r\n注意:由于权限信息数据量比较小，访问频繁。所以MySQL服务器在启动后会将权限表的信息缓存起来，所以手动修改权限信息后，需要执行`FLUSH PRIVILEGES`指令来重新刷新缓存中的权限信息。\r\n\r\n## 二、账户管理\r\n\r\n### 2.1 登录和退出MySQL服务器\r\n\r\n```\r\nMySQL [-h localhost] -u root -p [databases_name] [-e \"sql;\"]\r\n```\r\n\r\n以上命令如果加上了-e参数执行SQL语句，那么登录后执行SQL语句后会退出MySQL服务器。\r\n\r\n### 2.2 新建普通用户\r\n\r\n有两种方式，一种是使用`CREATE USER`或`GRANT`语句，另一种是在根用户下执行SQL语句直接操作MySQL授权表以插入用户。\r\n\r\n```\r\nCREATE USER 'jeffrey'@'localhost' [IDENTIFIED BY 'mypass'];\r\n```\r\n\r\n省略以上语句的括号部分代表创建的用户登录不需要密码。不省略括号部分那么上述语句指定的是明文密码值，为了避免使用明文密码，可以通过`PASSWORD`关键字使用密码的哈希值设置密码，先通过`PASSWORD`关键字获取密码哈希值，如下\r\n\r\n```\r\nselect password('mypass');\r\n```\r\n\r\n然后在将得到的哈希值替换上述语句的明文密码。\r\n\r\n`GRANT`方式创建普通账户命令如下\r\n\r\n```\r\nGRANT SELECT,UPDATE ON *.* TO 'testUser'@'localhost' IDENTIFIED BY  'testPswd';\r\n```\r\n\r\n两个命令的区别是，`CREATE USER`命令创建用户后用户并没有权限，还需要通过`GRANT`语句赋予用户权限，而`GRANT`语句创建用户可以直接赋予用户权限。\r\n\r\n直接操作mysql用户表创建用户，即使用`insert`语句向mysql.user表中增加一条记录，如下\r\n\r\n```\r\nINSERT INTO mysql.user(Host, User, Password, [privilegelist]) VALUES('host', 'username', PASSWORD('pswd'), [privilegevaluelist]);\r\n```\r\n\r\n### 2.3 删除普通用户\r\n\r\n两种方式，分别是通过`DROP USER`语句删除和通过`DELETE`语句删除，如下\r\n\r\n```\r\nDROP USER 'jeffrey'@'localhost';\r\nDELETE FROM mysql.user WHERE host = 'localhost' and user = 'customer1';\r\n```\r\n\r\n### 2.4 root用户修改自己的密码\r\n\r\n一种方式是直接使用`mysqladmin`命令在命令行指定新密码，如下\r\n\r\n```\r\nmysqladmin [-h localhost] -u root -p password 'newpswd';\r\n```\r\n\r\n一种方式是使用SET语句来修改，需要注意的是新密码必须加密，如下\r\n\r\n```\r\nSET PASSWORD=PASSWORD('newpswd');\r\n```\r\n\r\n另一种但是是直接操作user表，如下\r\n\r\n```\r\nUPDATE mysql.user set Password = password('newpswd') WHERE User = 'root' and Host = 'localhost';\r\n```\r\n\r\n### 2.5 root用户修改普通用户密码\r\n\r\n一种方式是使用`SET`语句，如下\r\n\r\n```\r\nSET PASSWORD FOR 'testUser'@'localhost' = PASSWORD('newpswd');\r\n```\r\n\r\n一种方式是使用如2.4所示的`UPDATE`语句来修改。另一种方式是使用`GRANT`语句来修改，如下\r\n```\r\nGRANT USAGE ON *.* TO 'testUser'@'localhost' IDENTIFIED BY 'newpswd';\r\n```\r\n\r\n### 2.6 普通用户修改密码\r\n\r\n直接使用`SET`语句修改，如下\r\n\r\n```\r\nSET PASSWORD = PASSWORD('newpswd');\r\n```\r\n\r\n### 2.7 root用户丢失密码解决办法\r\n\r\nWindows下先停止MySQL服务器进程，然后键入如下命令启动MySQL服务\r\n\r\n```\r\nmysqld --skip-grant-tables\r\n```\r\n\r\n然后打开另一个命令行窗口，输入不加密码的登录命令\r\n\r\n```\r\nmysql -u root\r\n```\r\n\r\n然后使用`mysqladmin`命令或者`UPDATE`语句重置root密码，最后重新加载权限表，如下\r\n\r\n```\r\nFLUSH PRIVILEGES;\r\n```\r\n\r\n修改密码完成后，就可以将输入`mysqld --skip-grant-tables`命令的命令行窗口关掉，然后使用新密码登录。\r\n\r\n## 三、权限管理\r\n\r\n权限管理主要是对登录到MySQL的用户进行权限验证，MySQL权限系统的主要功能是证实连接到一台给定主机的用户，并且赋予该用户在数据库上的SELECT、INSERT、UPDATE、DELETE权限。\r\n\r\n账户权限信息被存储在MySQL数据库的user、db、host、tables_priv、columns_priv、procs_priv表中，在MySQL启动的时候，服务器将这些数据库表中的权限信息读取内存。\r\n\r\n### 3.1 授权与撤销授权\r\n\r\n授权可以分为多个层级。\r\n\r\n全局权限适用于一个给定服务器中的所有数据库，这些权限存储在mysql.user表中。`GRANT ALL ON *.*`和`REVOKE ALL ON *.*`只授予和撤销全局权限。\r\n\r\n数据库权限适用于一个给定数据库中的所有目标，这些权限存储在mysql.db和mysql.host表中。`GRANT ALL ON db_name.`和`REVOKE ALL ON db_name.*`只授予和撤销数据库权限。\r\n\r\n表权限适用于一个给定表中的所有列。这些权限存储在mysql.tables_priv表中。`GRANT ALL ON db_name.tb_name`和`REVOKE ALL ON db_name.tb_name`只授予和撤销表权限。\r\n\r\n列权限适用于一个给定表中的所有列。这些权限存储在mysql.columns_priv表中。当使用REVOKE时，必须指定与被授权列相同的列。\r\n\r\n还有子程序层级权限。\r\n\r\n以上`ALL`代表的是所有权限，也可以替换为具体的权限。\r\n\r\n### 3.2 查看权限\r\n\r\n可以通过如下命令查看指定用户的权限信息\r\n\r\n```\r\nSHOW GRANTS FOR 'user'@'host';\r\n```\r\n\r\n当然也可以使用`SELECT`语句来查询。\r\n\r\n### 3.3 访问控制(过程)\r\n\r\n当MySQL允许一个用户执行各种操作时，它将核实该用户向MySQL服务器发送的连接请求，然后确认用户的操作请求是否被允许。也就是MySQL的访问控制分为两个阶段:连接核实阶段和请求核实阶段。\r\n\r\n1. 连接核实阶段:当连接MySQL服务器时，服务器基于用户的身份以及用户是否能通过正确的密码身份验证来接受或拒绝连接。这一阶段就是user表在发挥作用。\r\n\r\n2. 请求核实阶段:建立了连接之后，MySQL服务器对在该连接上的每个请求都要执行核实操作，检查是否有足够的权限来执行它。这一阶段就是user、db、host、tables_priv或columns_priv表在发挥作用。具体过程为，MySQL先检查user表，若指定权限并未在user表中被授权，那么将依次检查db表、tables_priv、columns_priv表，如果所有权限表都检查完毕，但是还没有找到允许的权限操作，那么就返回错误信息，否则就执行请求。\r\n\r\n## 四、MySQL的安全问题\r\n\r\n### 4.1 操作系统层面\r\n\r\n+ 尽量避免以root方式运行MySQL服务器;\r\n+ 尽量关闭不必要的服务(通过端口扫描确定)。\r\n\r\n### 4.2 数据库层面\r\n\r\n+ 修改root用户口令和删除匿名账号;\r\n+ 设置安全的密码;\r\n+ 禁止远程连接数据库;\r\n+ 限制单个用户连接次数。","cover":"/images/mysql-logo.png","link":"mysql-permissions-and-security.html","preview":"\u003cp\u003eMySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库中，由mysql_install_db脚本初始化。存储账户权限信息表主要有:user、db、host、tables_priv、columns_priv和procs_priv。\u003c/p\u003e\n","title":"MySQL权限与安全"},{"content":"\r\n\r\n## 一、MySQL架构\r\n\r\nMySQL服务器由SQL层和存储引擎层构成，SQL层主要功能包括处理客户端请求、权限判断、SQL解析和查询缓存处理等，存储引擎层完成底层数据库的数据存储操作。\r\n\r\n### 1.1 SQL层\r\n\r\n+ 客户端通过连接/线程处理层来连接MySQL数据库，连接/线程处理层主要用来处理客户端请求、身份验证和数据库安全性验证等;\r\n+ 查询缓存和查询分析器是SQL层的核心部分，其中主要涉及查询的解析、优化、缓存以及所有内置函数、存储过程、触发器、视图等功能;\r\n+ 优化器主要负责存储和获取所有存储在MySQL中的数据。\r\n\r\n### 1.2 存储引擎层\r\n\r\n常见的存储引擎层有MyISAM、InnoDB、MEMORY、MERGE、NDB。\r\n\r\n查看当前默认存储引擎，使用如下命令:\r\n\r\n```\r\nshow variables like 'table-type';\r\nshow variables like 'have%';\r\n```\r\n\r\n修改表的存储引擎的命令为:\r\n\r\n```\r\nalter table tablename engine=innodb;\r\n```\r\n\r\n创建表时也可以添加默认的存储引擎:\r\n\r\n```\r\ncreate table tablename(\r\n)engine=MyISAM default charset=gbk;\r\n```\r\n\r\n## 二、MySQL各种存储引擎的特性\r\n\r\n尽管MySQL数据库支持种类繁多的数据存储引擎，但是数据存储不管是使用哪种存储引擎，所有的存储数据都被记录到.frm文件中，该文件记录了存储的数据以及表的一些属性值;不管是使用哪种数据存储引擎，都使用了高速缓存，数据库读取.frm文件信息后会将表的信息缓存起来，提高了服务器下次读取数据的速度。\r\n\r\n### 2.1 MyISAM\r\n\r\nLinux平台下，MySQL默认的存储引擎是MyISAM，该存储引擎不支持事务和主键，但是对数据的存储和批量查询速度比较快。因此在实际应用中主要对以查询和增加记录为主的应用采用MyISAM存储引擎。MyISAM存储引擎只缓存索引，对数据文件采用操作系统缓存，如果索引数据超过系统所分配的缓存空间时也会采用操作系统来缓存索引。\r\n\r\n#### 2.1.1 MyISAM文件格式\r\n\r\n+ frm文件:存储表的定义数据;\r\n+ ‌MYD文件:存放表具体记录数据;\r\n+ ‌MYI文件:存储索引。\r\n\r\n#### 2.1.2 MyISAM文件修复\r\n\r\nMyISAM类型的表在数据存储过程中可能会发生错误，可以通过myisamchk工具修复损坏的表。\r\n\r\n#### 2.1.3 MyISAM表的存储格式\r\n\r\n该类型的表支持三种不同类型格式的表，分别为\r\n\r\n+ 静态(固定长度)表\r\n+ 动态可变长度表\r\n+ 压缩表\r\n\r\n其中静态和动态数据存储根据起表中数据列的类型自动选择，静态表是默认的存储格式，压缩表只能通过myisampack工具创建。\r\n\r\n静态表中的字段都是固定非变长的字段，这样每个记录都是固定长度的，这种存储方式的优势在于存储速度非常快、容易缓存，表发生缺损后容易恢复，缺点是静态表所占用的空间往往比动态表多。\r\n\r\nmyisamchk文件修复，该命令格式为\r\n\r\n```\r\nmyisam [options] tables[.MYI]\r\n```\r\n\r\n示例为\r\n\r\n```\r\n[root@localhost books]# ls\r\nbooks.frm books.MYD books.MYI db.opt\r\n[root@localhost books]# myisamchk -e books.MYI\r\n```\r\n\r\n动态表支持动态可变长度，字符型的列长是可变的，除了小于4个字符的。动态可变长字符通常比静态固定格式需要更少的存储空间，由于采用动态可变长度存储，所以出错的时候也比静态格式恢复更加困难。\r\n压缩表需要的磁盘存储空间最小，可以通过myisampack工具来压缩MyISAM表，每行单独压缩，每列的压缩也不一样。\r\n\r\n### 2.2 InnoDB\r\n\r\n该存储引擎写的处理相对于MyISAM效率低一些，其牺牲了存储和查询的效率，但是支持事务安全、支持自动增长列以及外键约束。\r\n\r\n### 2.3 MEMORY\r\n\r\n该存储引擎通过使用内存中的内容来创建表，每个MEMORY表实际上和一个磁盘文件关联起来，文件名采用.frm的形式。该类型的表访问速度非常快，因为数据来源于内存空间，该存储引擎默认使用HASH索引，也可以在创建表时使用BTREE索引。虽然该存储引擎访问速度非常快，但是一旦数据库发生故障关闭，那么内存中的数据就会丢失。\r\nMEMORY表内容存储在内存中，如果一个表内部变的很大，那么服务器会自动把它转换为一个磁盘表。\r\n\r\n创建MEMORY型数据表并制定索引为hash\r\n\r\n```\r\ncreate table tablename(\r\n  id int,\r\n  index using hash(id)\r\n)engine=memory;\r\n```\r\n\r\n删除hash索引\r\n\r\n```\r\ndrop index id on tablename;\r\n```\r\n\r\n然后修改索引\r\n\r\n```\r\ncreate index id_index using btree on tablename(id);\r\n```\r\n\r\n通过如下命令查看索引\r\n\r\n```\r\nshow index from tablename \\g;\r\n```\r\n\r\n也可以在创建表的时候指定表的最大行数\r\n\r\n```\r\ncreate table tablename(\r\n  id int primary key,\r\n)engine=memory max_rows=10000;\r\n```\r\n\r\n### 2.4 MERGE\r\nMERGE存储引擎是一组MyISAM表的组合，即将一组结构相同的MyISAM表组合为一个逻辑单元，MERGE表本身没有数据。\r\n对于MERGE表的插入操作，是通过INSERT_METHOD字句完成，可以使用FIRST或者LAST值，其实质上是对MyISAM表进行操作。\r\n\r\n```\r\ncreate table table_myisam_1(\r\n  id int primary key,\r\n  data datetime\r\n)engine=myisam default charset=gbk;\r\n\r\n\r\ncreate table table_myisam_2(\r\n  id int primary key,\r\n  data datetime\r\n)engine=myisam default charset=gbk;\r\n\r\n\r\ncreate table table_merge_12(\r\n  id int primary key,\r\n  data datetime\r\n)engine=merge union=(table_myisam_1,table_myisam_2) insert_method=first;\r\n```","cover":"/images/mysql-jiagou.png","link":"mysql-architecture.html","preview":"\u003cp\u003eMySQL服务器由SQL层和存储引擎层构成，SQL层主要功能包括处理客户端请求、权限判断、SQL解析和查询缓存处理等，存储引擎层完成底层数据库的数据存储操作。\u003c/p\u003e\n","title":"MySQL架构"},{"content":"\r\n\r\n基于贝叶斯定理的朴素贝叶斯算法是利用训练数据并根据特征的取值来计算每个类别被观察到的概率。这里的“朴素”并不意味着算法有限或者效率低下，而是该算法依赖于一个基本假设，即预测变量具有独立性，也就是说假定类中特定特征的存在与任何其他特征的存在无关。虽然有时该条件看起来很难成立，但是在特定情况下，不同情况之间的依赖关系可能会相互清除，即使朴素贝叶斯分类器的朴素性假设不成立，但是依然能够表现出相当好的性能。\r\n\r\n## 一、贝叶斯定理\r\n\r\n考虑两个概率事件A和B，使用乘积法则可以将边缘概率P(A)和P(B)与条件概率P(A|B)和P(B|A)相关联：\r\n\r\n![](/images/article/bayes1.png)\r\n\r\n考虑到交集可以互换，等式的左边是相等的，那么就可以得到贝叶斯定理，如下：\r\n\r\n![](/images/article/bayes2.png)\r\n\r\n还需要再了解一下似然函数，可以简单的理解为是一种关于统计模型参数的函数。在给定输出x时，关于参数θ的似然函数L(θ|x)(在数值上)等于给定参数θ后变量X的概率：L(θ|x)=P(X=x|θ)\r\n\r\n\r\n对贝叶斯定义各部分的解释如下：\r\n\r\n+ 后验概率：即P(A|B)，是在事件B发生的条件下事件A发生的可能性的大小；\r\n+ 先验概率：即P(A)，是根据以往经验和分析得到的某事件的概率；\r\n+ 似然概率：即P(B|A)，似然是关于参数的函数L(θ|x)，即在参数θ给定的条件下，对于观察到的x的值的条件分布，即概率P(X=x|θ)，也就是L(θ|x)=P(X=x|θ)；\r\n+ 边际似然概率(或者归一化因子)：即P(B)，作为上述似然概率的推广，那么边际似然概率也就是在二维随机变量θ与X的分布中，随机变量X的边际概率P(X=x)。\r\n\r\n由于归一化因子常用希腊字母α来表示，那么公式就变为\r\n\r\n![](/images/article/bayes7.png)\r\n\r\n这是在二维特征空间内的贝叶斯定理，推广到多维特征空间，那么贝叶斯定理如下表示\r\n\r\n![](/images/article/bayes8.png)\r\n\r\n在朴素贝叶斯算法中，我们就是通过计算先验概率、似然概率与边际似然概率来估计后验概率发生的可能性，从而实现预测分类。\r\n\r\n## 二、朴素贝叶斯算法\r\n\r\n### 2.1 朴素贝叶斯算法的形象解释\r\n\r\n考虑有如下训练集，其中二维特征空间中绿点有40个，红点为20个，总数为60\r\n\r\n![](/images/article/bayes3.gif)\r\n\r\n我们有先验概率公式\r\n\r\n![](/images/article/bayes4.gif)\r\n\r\n那么我们就可以根据训练集数据得到如下先验概率(根据以往经验分析得到，即根据训练集数据得到单变量的概率分布)\r\n\r\n![](/images/article/bayes5.gif)\r\n\r\n如果此时加入一个新的案例(如下图所示)，我们假定，该案例的类别取决于其附近的案例的类别情况，那么我们不妨以该案例为圆心，画一个包含了一定数量的绿点和红点的圆出来，如下\r\n\r\n![](/images/article/bayes6.gif)\r\n\r\n然后我们计算属于每个类标签的圆中的点的个数。由此我们计算出可能性：\r\n\r\n![](/images/article/bayes7.gif)\r\n\r\n带入数值，从而\r\n\r\n![](/images/article/bayes8.gif)\r\n\r\n![](/images/article/bayes9.gif)\r\n\r\n到了这里，只需要通过贝叶斯定理将先验概率与似然概率综合起来就好了，如下\r\n\r\n![](/images/article/bayes10.gif)\r\n\r\n那么白色案例最终的预测类就是红点。\r\n\r\n即朴素贝叶斯算法则是综合似然概率与先验概率来产生最终的后验概率，即最终的分类预测概率。上述概率并未进行归一化(标准化)操作。但是，这不会影响分类结果，因为它们的归一化常数是相同的。\r\n\r\n## 2.2 朴素贝叶斯算法的数学定义\r\n\r\n考虑一个数据集：\r\n\r\n![](/images/article/bayes11.png)\r\n\r\n以上，为了简单起见，每个向量被表示为：\r\n\r\n![](/images/article/bayes12.png)\r\n\r\n再定义如下目标数据集，分别对应上述数据集案例的类别：\r\n\r\n![](/images/article/bayes13.png)\r\n\r\n那么根据条件独立下的贝叶斯定理，就有：\r\n\r\n![](/images/article/bayes14.png)\r\n\r\n即通过频率计数获得边际先验概率P(y)和条件概率P(xi|y)的值，那么给定输入向量x，预测得到的类就是后验概率最大的类。\r\n\r\n### 2.3 朴素贝叶斯算法的适用范围\r\n\r\n+ 实时预测：朴素贝叶斯训练起来很快。因此，它可以用于实时预测；\r\n+ 多类预测：该算法对于多类预测的性能也是不错的。在这里，我们可以预测多类目标变量的概率；\r\n+ 文本分类/垃圾邮件过滤/情感分析：与其他算法相比，主要用于文本分类的朴素贝叶斯分类器具有更高的成功率。因此，它被广泛用于垃圾邮件过滤（识别垃圾邮件）和情感分析（在社交媒体分析中，以识别积极和消极的客户情绪）；\r\n+ 推荐系统：朴素贝叶斯分类器和协同过滤一起构建一个推荐系统，该系统使用机器学习和数据挖掘技术来过滤看不见的信息并预测用户是否想要给定的资源。\r\n\r\n## 三、R语言中朴素贝叶斯函数及应用\r\n\r\n### 3.1 R语言中朴素贝叶斯函数\r\n\r\n使用e1071添加包中的函数`naiveBayes()`来实现朴素贝叶斯算法，原型如下\r\n\r\n先创建分类器\r\n\r\n```\r\nm \u003c- naiveBayes(train, class, laplace = 0)\r\n```\r\n\r\n+ train：训练集数据框；\r\n+ class：训练集数据框案例对应的类别，是一个因子型向量；\r\n+ laplace：控制拉普拉斯估计得一个数值，默认为0.\r\n\r\n该函数返回一个朴素贝叶斯对象，能够用于预测。\r\n\r\n进行预测\r\n\r\n```\r\np \u003c- predict(m, test, type = \"class\")\r\n```\r\n\r\n+ m：`naiveBayes()`函数得到的模型；\r\n+ test：测试集数据框；\r\n+ type：值为`class`或者`raw\t`，分别对应预测的类与概率。\r\n\r\n该函数返回一个向量，根据type参数的值决定该向量是预测类还是预测类概率。\r\n\r\n### 3.2 R语言中朴素贝叶斯函数应用\r\n\r\n我们使用 [分而治之——决策树学习算法](http://localhost:8000/decision-tree-learning.html) 一文中根据银行贷款数据来建立模型来预测贷款是否违约为例来说明朴素贝叶斯算法，只将C5.0决策树算法调整为朴素贝叶斯，其余代码不变，如下\r\n\r\n```\r\n\u003e credit_train_class \u003c- credit_train$default\r\n\u003e credit_test_class \u003c- credit_test$default\r\n\u003e credit_train \u003c- credit_train[-17]\r\n\u003e credit_test \u003c- credit_test[-17]\r\n\u003e library(e1071)\r\n\u003e m \u003c- naiveBayes(credit_train, credit_train_class)\r\n\u003e p \u003c- predict(m, credit_test)\r\n\u003e prop.table(table(credit_test_class == p))\r\n\r\nFALSE  TRUE \r\n 0.19  0.81 \r\n```\r\n\r\n评估模型效果发现，性能还是可以的。\r\n\r\n### 3.3 调整模型性能\r\n\r\n可以通过调整`naiveBayes()`函数中`laplace`参数的值来调整模型性能。设置`laplace`的值为1试试，如下\r\n```\r\n\u003e m \u003c- naiveBayes(credit_train, credit_train_class, laplace = 1)\r\n\u003e p \u003c- predict(m, credit_test)\r\n\u003e prop.table(table(credit_test_class == p))\r\n\r\nFALSE  TRUE \r\n  0.2   0.8 \r\n```\r\n\r\n模型性能稍微降低，可见之前的拟合效果还是不错的。\r\n\r\n\r\n###### 参考文献\r\n\r\n1. http://www.statsoft.com/Textbook/Naive-Bayes-Classifier\r\n2. Machine Learning Algorithms / Giuseppe Bonaccorso.\r\n3. https://www.analyticsvidhya.com/blog/2017/09/naive-bayes-explained/\r\n\r\n全文完！","cover":"/images/naive-bayes.png","link":"naive-bayes.html","preview":"\u003cp\u003e朴素贝叶斯算法是一种依据贝叶斯定理的分类技术，利用概率原则进行分类，该算法易于构建模型，适用于大规模数据集的分类任务。\u003c/p\u003e\n","title":"概率学习——朴素贝叶斯算法"},{"content":"\r\n\r\n## 一、常量与变量\r\n\r\nErlang中所有的变量名必须以大写字母开头，且变量属于**一次性赋值变量**，即只能被赋值一次，如果试图在变量被设置后再改变它的值就会得到一个错误。\r\n\r\n在Erlang里，变量不过是对某个值的引用，Erlang的实现方式是用指针指向一个包含值得内存区，这个值不能被修改。这样做的好处就是不存在共享内存，也就不存在锁，所以让并发实现的更简单。\r\n\r\n```\r\nC:\\Users\\Administrator\u003eerl\r\nEshell V10.0.1  (abort with ^G)\r\n1\u003e X = 1.\r\n1\r\n2\u003e X.\r\n1\r\n3\u003e X = 2.\r\n** exception error: no match of right hand side value 2\r\n```\r\n\r\n而Erlang中的常量(或者叫原子)是直接以小写字母开头的，可以直接使用，无需定义\r\n\r\n```\r\n4\u003e const.\r\nconst\r\n```\r\n\r\n## 二、常用数据类型(结构)\r\n\r\n### 2.1 整数和浮点数\r\n\r\n作为直接量直接使用，整数相除即使能够除尽得到的结果仍然是浮点数，想获取除数可以使用`div`操作符，想获取余数可以使用`rem`操作符。\r\n\r\n```\r\n5\u003e 5 / 3.\r\n1.6666666666666667\r\n6\u003e 5 div 3.\r\n1\r\n7\u003e 5 rem 3.\r\n2\r\n8\u003e 4 / 2.\r\n2.0\r\n```\r\n\r\nErlang在内部使用64位的IEEE 754-1985浮点数，因此浮点数的程序会存在和C等语言一样的浮点数取整和精度问题。\r\n\r\n### 2.2 原子\r\n\r\n原子类似于C语言中的宏，被用于表示常量值，以小写字母开头，后面可以跟字母、数字、下划线或at符号\r\n\r\n```\r\n9\u003e helloworld.\r\nhelloworld\r\n```\r\n\r\n### 2.3 元组\r\n\r\n元组是由一些**数量固定**的项目归组形成的单一的实体，创建元组的方法就是用大括号将想要表示的值括起来，并用逗号分隔每一部分。类似于C语言中的结构体，C语言中的结构体如下定义\r\n\r\n```\r\nstruct point {\r\n    int x;\r\n    int y;\r\n} P;\r\n```\r\n\r\n而对应的元组如下定义\r\n\r\n```\r\n10\u003e P = {1, 2}.\r\n{1,2}\r\n11\u003e P.\r\n{1,2}\r\n```\r\n\r\n为了指明元组的含义，一般情况下将第一个元素定义为原子类型，如下\r\n\r\n```\r\n12\u003e Q = {point, 1, 2}.\r\n{point,1,2}\r\n13\u003e Q.\r\n{point,1,2}\r\n```\r\n\r\n元组还可以嵌套，例如将如下JSON串利用嵌套的元组表示\r\n\r\n```\r\n{\r\n  \"name\" : \"joe\",\r\n  \"height\" : 1.82,\r\n  \"footsize\" : 42,\r\n  \"eyecolour\" : \"brown\"\r\n}\r\n```\r\n\r\n```\r\n14\u003e Person = {person, {name, joe}, {height, 1.82}, {footsize, 42}, {eyecolour, b\r\nrown}}.\r\n{person,{name,joe},\r\n        {height,1.82},\r\n        {footsize,42},\r\n        {eyecolour,brown}}\r\n15\u003e Person.\r\n{person,{name,joe},\r\n        {height,1.82},\r\n        {footsize,42},\r\n        {eyecolour,brown}}\r\n```\r\n\r\n其实可以看出，把元组大括号的第一个元素定义为常量，就相当于键值对中键的作用，但是并不是可以通过键提取值，而是代表了值的含义是什么。\r\n\r\n但是如何提取元组的值呢？答案是通过模式匹配操作符`=`来实现数据绑定，如下\r\n\r\n```\r\n16\u003e Point = {point, 10, 45}.\r\n{point,10,45}\r\n20\u003e {point, First, Second} = Point.\r\n{point,10,45}\r\n21\u003e First.\r\n10\r\n22\u003e Second.\r\n45\r\n```\r\n\r\n如果不匹配，比如说参数个数不一致，常量绑定值或者其他情况，那么就会提示错误，如下\r\n\r\n```\r\n17\u003e {point, X, Y} = Point.\r\n** exception error: no match of right hand side value {point,10,45}\r\n18\u003e {Point, First, second} = Point.\r\n** exception error: no match of right hand side value {point,10,45}\r\n19\u003e {Point, First, Second} = Point.\r\n** exception error: no match of right hand side value {point,10,45}\r\n20\u003e {point, First, Second} = Point.\r\n```\r\n\r\n再试试提取复杂元组的值，需要注意的是，如果我们对元组当中某个值不感兴趣，那么可以通过占位符`_`将其忽略，这样也省得定义没必要的变量名，如下提取前面定义的Person的元组值\r\n\r\n```\r\n24\u003e {_, {_, Name}, {_, Height}, {_, Footsize}, {_, Eyecolour}} = Person.\r\n{person,{name,joe},\r\n        {height,1.82},\r\n        {footsize,42},\r\n        {eyecolour,brown}}\r\n25\u003e Name.\r\njoe\r\n26\u003e Height.\r\n1.82\r\n28\u003e Footsize.\r\n42\r\n29\u003e Eyecolour.\r\nbrown\r\n```\r\n\r\n怎么样修改值呢？不会的，因为Erlang的变量是不允许修改的！\r\n\r\n### 2.4 列表\r\n\r\n列表是用来存放任意数量的事物的，创建列表的方法就是用中括号将列表元素括起来，并用逗号分隔它们，如下\r\n\r\n```\r\n30\u003e Drawing = [{square, {10, 10}, 10}, {triangle, {15, 10}, {25, 10}, {30, 40}}]\r\n.\r\n[{square,{10,10},10},{triangle,{15,10},{25,10},{30,40}}]\r\n31\u003e Drawing.\r\n[{square,{10,10},10},{triangle,{15,10},{25,10},{30,40}}]\r\n```\r\n\r\n列表可以分为表头和表尾，表头是第一个元素，除过表头的元素全部都是表尾，在多元素的情况下，表尾很有可能是一个列表。由于rlang不支持修改变量，那么拓展列表的办法就是将其赋值给新的变量并定义拓展的元素，如下\r\n\r\n```\r\n32\u003e ThingToBuy = [{apples, 10}, {pears, 6}, {milk, 3}].\r\n[{apples,10},{pears,6},{milk,3}]\r\n33\u003e ThingToBuy1 = [{oranges, 4}, {newspaper, 1} | ThingToBuy].\r\n[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]\r\n```\r\n\r\n列表元素的提取仍然是通过模式匹配操作符`=`来实现数据绑定，不过对于列表，我们可以通过表头表尾的配合来提取元素，如下\r\n\r\n```\r\n34\u003e [Buy1 | ThingToBuy2] = ThingToBuy1.\r\n[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]\r\n35\u003e Buy1.\r\n{oranges,4}\r\n36\u003e ThingToBuy2.\r\n[{newspaper,1},{apples,10},{pears,6},{milk,3}]\r\n```\r\n\r\n上述代码是将表头与表尾分别提取，可以以一次性提取若干的表头，以提取两个表头为例\r\n\r\n```\r\n37\u003e [Buy2, Buy3 | ThingToBuy3] = ThingToBuy1.\r\n[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]\r\n38\u003e Buy2.\r\n{oranges,4}\r\n39\u003e Buy3.\r\n{newspaper,1}\r\n40\u003e ThingToBuy3.\r\n[{apples,10},{pears,6},{milk,3}]\r\n```\r\n\r\n占位符`_`忽略元素同样有用，我们以下忽略列表的前四个元素，只提取最后一个元素\r\n\r\n```\r\n42\u003e [_, _, _, _ | Buy4] = ThingToBuy1.\r\n[{oranges,4},{newspaper,1},{apples,10},{pears,6},{milk,3}]\r\n43\u003e Buy4.\r\n[{milk,3}]\r\n```\r\n\r\n### 2.5 字符串\r\n\r\n严格来说，Erlang中并没有字符串，想要在Erlang中表示字符串，可以选择由一个整数组成的列表或者一个二进制型。当字符串表示为一个整数列表时，列表中的每个元素都代表了一个Unicode代码点。\r\n\r\n创建字符串最简单的方式就是使用字符串字面量，如下\r\n\r\n```\r\n44\u003e Names = \"Hello, World\".\r\n\"Hello, World\"\r\n```\r\n\r\n其实上述并不是真的字符串，而只是一个列表的简写，这个列表中包含了每个字符的整数字符代码，不信试试看\r\n\r\n可以通过操作符`$`获取某个字符的整数字符代码，如下\r\n\r\n```\r\n45\u003e H = $H.\r\n72\r\n46\u003e E = $e.\r\n101\r\n47\u003e L = $l.\r\n108\r\n48\u003e O = $o.\r\n111\r\n49\u003e Sign = $,.\r\n44\r\n50\u003e Space = $ .\r\n32\r\n51\u003e W = $W.\r\n87\r\n52\u003e R = $r.\r\n114\r\n53\u003e D = $d.\r\n100\r\n54\u003e HelloWorld = [H, E, L, L, O, Sign, Space, W, O, R, L, D].\r\n\"Hello, World\"\r\n```\r\n可见，效果一模一样。","cover":"/images/E-LearningLogo.png","link":"intro-erlang-1.html","preview":"\u003cp\u003e常量与变量、常用数据类型。\u003c/p\u003e\n","title":"Erlang程序设计(一)"},{"content":"\r\n\r\nkNN(k Nearest Neighbor)是一种非参数和惰性学习算法。非参数意味着没有基础数据分布的假设。换句话说，模型结构由数据集特别是训练集确定。在大多数现实世界数据集不遵循数学理论假设的实践中，这是非常有用的。懒惰算法意味着它不需要任何训练数据点就可以生成模型。在分类器的训练阶段会使用所有的训练集数据。但也就意味着扫描数据点时间的增长和内存占用的提高。\r\n\r\n## 一、kNN学习算法的原理\r\n\r\n该算法是基于案例之间的相似度进行分类的，训练集负责训练一个分类器，而测试集直接将案例带入就可以通过k个最相近的训练集案例进行投票以确定最终分类结果。\r\n\r\n首先从字面意思来解释，kNN又名K最近邻，有两层含义，分别是\r\n\r\n+ k：测试集数据的预测类需要由与它最近的K个邻居投票表决而定，哪类邻居的票数多，该案例就属于哪一类；\r\n+ 最近邻：与测试集数据点距离最近的训练集数据，是为该案例的最近邻。\r\n\r\n那么综上所述，k最近邻的本质就是**计算特征空间中测试集案例关于该特征空间中训练集数据点(类)的距离最近的k个训练集数据点(邻居)的距离，测试集案例的预测类通过这k个训练集数据的投票而定，哪一类票数多，测试集案例就属于哪一类**。\r\n\r\n### 1.1 距离的衡量\r\n\r\n同K均值聚类一样，该算法仍然是基于距离的(也可以说是案例之间的相似度，相似度通过距离来衡量)，距离的计算常用的仍然是欧式距离。公式如下\r\n\r\n![](/images/article/k-means1.png)\r\n\r\n其中，x和y分别为需要计算的两个案例，xi和yi分别为两个案例相对应的第i个特征的值。这样就足够度量测试集案例同周边k个相邻训练集案例的距离了，也就能找到最近邻。\r\n\r\n### 1.2 k的选择\r\n\r\n事实上，没有最优的k值适合所有类型的数据集。每个数据集都有自己的要求。如果k值较小，噪声将对结果具有更高的影响而且决策边界不是很平滑。如果k值较大，那么可以较少噪声数据对模型的影响或者减少噪声导致的模型波动，从而使得决策边界更为光滑，但是也意味着昂贵的计算成本。\r\n\r\n我们考虑两种极端的情况，如果k值为1，即测试集案例的预测类只取决于与它最相近的一个训练集数据点的类型，那么单一的近邻会使得噪声数据或者异常值过度影响案例的分类结果，一言堂是不可取的。如果k值非常大，甚至于等于训练集案例中所有观测值的数量，那么过度拟合的风险就极高，颇有一种仗势欺人的感觉。\r\n\r\n![](/images/article/knn1.png)\r\n\r\n因此，合理的k值应该介于这两种极端之间，并考虑训练数据中案例的数量，一种较为常见的做法是设置k值等于训练集中案例数量的平方根，但是对于训练集数据体量庞大的情况下仍然是不可取的。一般情况下k通常取3 — 10之间的某个数，\r\n\r\n![](/images/article/knn2.png)\r\n\r\n### 1.3 特征值标准化\r\n\r\n在应用kNN算法之前，必不可少的操作是将特征值转化到一个合理的区间内。这种操作的合理性在于，如果某个特征具有比其他特征更大的值，那么距离的度量就会强烈地被这个庞大的值所支配，所以必须避免这种情况。\r\n\r\n较为常用的数据标准化方法包括如下两种：\r\n\r\n+ min-max 标准化：就是特征X的每一个值减去该特征的最小值再除以特征X的值域，该方法会将特征值映射到0 — 1范围内，公式如下\r\n\r\n![](/images/article/knn3.png)\r\n\r\n+ z-score 标准化：特征X的每一个值减去特征X的均值，然后再除以特征X的标准差。经过处理的数据符合标准正态分布，即均值为0，标准差为1，公式为\r\n\r\n![](/images/article/knn4.png)\r\n\r\n## 二、R语言中kNN函数及应用\r\n\r\n### 2.1 R语言中kNN函数\r\n\r\n通过使用class添加包中的`knn()`函数来应用KNN算法，原型如下\r\n\r\n创建分类器并进行预测\r\n\r\n```\r\np \u003c- knn(train, test, cl, k)\r\n```\r\n\r\n+ train：一个包含数值型数据的训练集数据框；\r\n+ test：一个包含数值型数的测试集数据框；\r\n+ cl：包含训练集数据每一行分类的一个因子向量；\r\n+ k：标识最近邻数目的一个整数。\r\n\r\n该函数返回一个因子向量，该向量包含测试集数据框中每一行的预测分类。\r\n\r\n### 2.2 R语言中KNN函数应用\r\n\r\n以《Machine Learning With R》一书中的乳腺癌的识别为例，来说明kNN算法对数值型数据的预测分类能力，先读取数据并查看结构\r\n\r\n```\r\n\u003e getwd()\r\n[1] \"C:/Users/Administrator/Documents\"\r\n\u003e setwd(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\docs\\\\Machine-Learning-with-R-datasets-master\")\r\n\u003e wb \u003c- read.csv(\"wisc_bc_data.csv\", stringsAsFactors = FALSE)\r\n\u003e str(wb)\r\n'data.frame':\t569 obs. of  32 variables:\r\n $ id                     : int  842302 842517 84300903 84348301 84358402 843786 844359 84458202 844981 84501001 ...\r\n $ diagnosis              : chr  \"M\" \"M\" \"M\" \"M\" ...\r\n $ radius_mean            : num  18 20.6 19.7 11.4 20.3 ...\r\n $ texture_mean           : num  10.4 17.8 21.2 20.4 14.3 ...\r\n $ perimeter_mean         : num  122.8 132.9 130 77.6 135.1 ...\r\n $ area_mean              : num  1001 1326 1203 386 1297 ...\r\n $ smoothness_mean        : num  0.1184 0.0847 0.1096 0.1425 0.1003 ...\r\n $ compactness_mean       : num  0.2776 0.0786 0.1599 0.2839 0.1328 ...\r\n $ concavity_mean         : num  0.3001 0.0869 0.1974 0.2414 0.198 ...\r\n $ concave.points_mean    : num  0.1471 0.0702 0.1279 0.1052 0.1043 ...\r\n $ symmetry_mean          : num  0.242 0.181 0.207 0.26 0.181 ...\r\n $ fractal_dimension_mean : num  0.0787 0.0567 0.06 0.0974 0.0588 ...\r\n $ radius_se              : num  1.095 0.543 0.746 0.496 0.757 ...\r\n $ texture_se             : num  0.905 0.734 0.787 1.156 0.781 ...\r\n $ perimeter_se           : num  8.59 3.4 4.58 3.44 5.44 ...\r\n $ area_se                : num  153.4 74.1 94 27.2 94.4 ...\r\n $ smoothness_se          : num  0.0064 0.00522 0.00615 0.00911 0.01149 ...\r\n $ compactness_se         : num  0.049 0.0131 0.0401 0.0746 0.0246 ...\r\n $ concavity_se           : num  0.0537 0.0186 0.0383 0.0566 0.0569 ...\r\n $ concave.points_se      : num  0.0159 0.0134 0.0206 0.0187 0.0188 ...\r\n $ symmetry_se            : num  0.03 0.0139 0.0225 0.0596 0.0176 ...\r\n $ fractal_dimension_se   : num  0.00619 0.00353 0.00457 0.00921 0.00511 ...\r\n $ radius_worst           : num  25.4 25 23.6 14.9 22.5 ...\r\n $ texture_worst          : num  17.3 23.4 25.5 26.5 16.7 ...\r\n $ perimeter_worst        : num  184.6 158.8 152.5 98.9 152.2 ...\r\n $ area_worst             : num  2019 1956 1709 568 1575 ...\r\n $ smoothness_worst       : num  0.162 0.124 0.144 0.21 0.137 ...\r\n $ compactness_worst      : num  0.666 0.187 0.424 0.866 0.205 ...\r\n $ concavity_worst        : num  0.712 0.242 0.45 0.687 0.4 ...\r\n $ concave.points_worst   : num  0.265 0.186 0.243 0.258 0.163 ...\r\n $ symmetry_worst         : num  0.46 0.275 0.361 0.664 0.236 ...\r\n $ fractal_dimension_worst: num  0.1189 0.089 0.0876 0.173 0.0768 ...\r\n```\r\n\r\nid列并没有实际意义，应该剔除\r\n\r\n```\r\n\u003e wb \u003c- wb[-1]\r\n```\r\n\r\n预测类特征为diagnosis，应该是一个因子型向量，但是现在明显不是，所以应该转化一下\r\n\r\n```\r\n\u003e str(wb$diagnosis)\r\n chr [1:569] \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" \"M\" ...\r\n\u003e wb$diagnosis \u003c- factor(wb$diagnosis, levels = c(\"B\", \"M\"), labels = c(\"Benign\", \"Malignant\"))\r\n\u003e str(wb$diagnosis)\r\n Factor w/ 2 levels \"Benign\",\"Malignant\": 2 2 2 2 2 2 2 2 2 2 ...\r\n```\r\n\r\n从上述数据结构也可以看出，某些特征的值非常大，而某些特征的值又很小，所以必须进行标准化操作，如下\r\n\r\n```\r\n\u003e normalize \u003c- function(x) {\r\n+   return ((x - min(x)) / (max(x) - min(x)))\r\n+ }\r\n\u003e wb.normalize \u003c- as.data.frame(lapply(wb[2 : 31], normalize))\r\n```\r\n\r\n然后分别构造训练集与测试集，如下\r\n\r\n```\r\n\u003e wb.normalize.train \u003c- wb.normalize[1 : 469, ]\r\n\u003e wb.normalize.test \u003c- wb.normalize[470 : 569, ]\r\n```\r\n\r\n由于我们标准化的数据剔除了目标特征，在建模阶段需要训练集的目标特征，而在测试集验证中需要测试集的目标特征，所以我们从标准化之前的数据框中提取该列向量，如下\r\n\r\n```\r\n\u003e wb.normalize.train.labels \u003c- wb[1 : 469, 1]\r\n\u003e wb.normalize.test.labels \u003c- wb[470 : 569, 1]\r\n```\r\n\r\n现在就可以创建分类器并预测了，如下\r\n\r\n```\r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 3)\r\n```\r\n\r\n### 2.3 评估模型性能\r\n\r\n```\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.06  0.94 \r\n```\r\n\r\n可见正确率为94%，还是相当不错的，也可以通过双向交叉表来查看，如下\r\n\r\n```\r\n\u003e table(wb.normalize.test.labels, p)\r\n                        p\r\nwb.normalize.test.labels Benign Malignant\r\n               Benign        72         5\r\n               Malignant      1        22\r\n```\r\n\r\n或者\r\n\r\n```\r\n\u003e library(gmodels)\r\n\u003e CrossTable(x = wb.normalize.test.labels, y = p, prop.chisq = FALSE)\r\n\r\n \r\n   Cell Contents\r\n|-------------------------|\r\n|                       N |\r\n|           N / Row Total |\r\n|           N / Col Total |\r\n|         N / Table Total |\r\n|-------------------------|\r\n\r\n \r\nTotal Observations in Table:  100 \r\n\r\n \r\n                         | p \r\nwb.normalize.test.labels |    Benign | Malignant | Row Total | \r\n-------------------------|-----------|-----------|-----------|\r\n                  Benign |        72 |         5 |        77 | \r\n                         |     0.935 |     0.065 |     0.770 | \r\n                         |     0.986 |     0.185 |           | \r\n                         |     0.720 |     0.050 |           | \r\n-------------------------|-----------|-----------|-----------|\r\n               Malignant |         1 |        22 |        23 | \r\n                         |     0.043 |     0.957 |     0.230 | \r\n                         |     0.014 |     0.815 |           | \r\n                         |     0.010 |     0.220 |           | \r\n-------------------------|-----------|-----------|-----------|\r\n            Column Total |        73 |        27 |       100 | \r\n                         |     0.730 |     0.270 |           | \r\n-------------------------|-----------|-----------|-----------|\r\n```\r\n\r\n可见，共有1个原本是Benign的却被预测为Malignant，而有5个原本是Malignant的，却被预测为Benign。\r\n\r\n### 2.4 提高模型的性能\r\n\r\n提高模型的性能可以通过调整k值来实现，试着调大k值\r\n\r\n```\r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 5)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.03  0.97 \r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 7)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.02  0.98 \r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 9)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.02  0.98 \r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 11)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.02  0.98 \r\n```\r\n\r\n可见，分类器表现不错，再试试两个极端的k值？如下\r\n\r\n```\r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 1)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.07  0.93 \r\n\u003e p \u003c- knn(train = wb.normalize.train, test = wb.normalize.test, cl = wb.normalize.train.labels, k = 469)\r\n\u003e prop.table(table(p == wb.normalize.test.labels))\r\n\r\nFALSE  TRUE \r\n 0.23  0.77 \r\n```\r\n\r\n明显不如介于两个极端之间的K值拟合效果好。\r\n\r\n全文完！","cover":"/images/knn.png","link":"k-nearest-neighbor-algorithm.html","preview":"\u003cp\u003ek最近邻分类器就是把未标记的案例归类为与它们最相似的带有标记的案例所在的类，广泛适用于数据特征与目标类之间的关系众多且复杂，用其它方式难以理解，但是具有相似类的项目又非常类似的分类任务。\u003c/p\u003e\n","title":"懒惰学习——K最近邻学习算法"},{"content":"\r\n\r\n与有监督学习算法不同，无监督学习算法的训练集数据并没有目标特征，我们不知道有哪些类别以及有几个类别，只能通过算法探索将相似度较高或者同质性强的样本聚类在一起，最终实现对无标签案例的分类任务。\r\n\r\n## 一、K均值聚类学习算法\r\n\r\nK均值聚类(K-Means Clustering)是一种数据聚类算法，可用于无监督的机器学习。它能够将类似的非标记数据组合到预定数量的簇中。\r\n\r\n### 1.1 K均值聚类与kNN最近邻的对比\r\n\r\nK均值聚类在某些程度上与kNN最近邻有监督学习算法有相似之处，如下：\r\n\r\n1. 都是将相似度高或者同质性强的样本对象集聚在一起；\r\n2. 都包含一定簇，每个簇代表一类样本；\r\n3. 都是基于距离(特别是欧式距离)的分类或聚类算法。\r\n\r\n二者也有区别，如下：\r\n\r\n1. K均值属于无监督学习算法，kNN属于有监督学习算法；\r\n2. 由于K均值无监督学习算法的特征，数据集并没有目标特征，全靠算法探索；而kNN有监督学习算法则拥有目标特征；\r\n3. kNN被认为是懒惰的、机械的，模型性能或泛化能力高度依赖于训练集数据的泛性，如果训练集数据极具概括性，那么模型的泛化能力很强而且训练时间短，反之则模型泛化能力差；而K均值则由于模型的迭代修正使得预测结果更加稳健；\r\n4. 对模型的评估，kNN显得更加客观公正和简单；但是K均值则需要全方位多角度的评估，且带有主观性。\r\n\r\n### 1.2 K均值聚类的原理\r\n\r\n在训练阶段，**K均值聚类的目标是将n个训练集样本根据其特征集，将样本分配给与某簇相似的或者与某簇质心距离最近的簇中，而与当前簇距离较远的样本归入另外的簇中**。其中，簇是一个对象的集合，**簇中的对象(样本)相似度极高，簇间差异化极大**。\r\n\r\n该算法本质上包含以下步骤：\r\n\r\n1. 首先初始化簇质心，一种办法是从训练集数据中随机选择k个案例(这里的随机并不意味着训练结果的不精确，因为之后会通过迭代重新选择质心优化模型)；\r\n2. 计算训练集各案例到各簇质心的距离，然后将该案例归入距离最小的簇中；\r\n3. 训练集案例分配完毕后，重新计算各簇的质心(通过计算训练集特征空间中各特征的均值构造质心)；重复第2步和第3步，直至迭代操作不会再提升类优度为止。\r\n\r\n### 1.3 K均值通过距离实现类的更新与分配\r\n\r\n通常情况下，K均值使用欧式距离(欧式距离计算两点之间的距离，即两点之间的连线)来计算两个案例之间的距离，公式定义如下：\r\n\r\n![](/images/article/k-means1.png)\r\n\r\n其中，x和y分别代表两个案例，xi与yi分别代表两个案例的第i个特征值。通过使用该距离函数，就可以计算两个案例之间的距离。在K-Means中，我们通过计算某案例与簇质心之间的欧式距离，然后将该案例分配给距离最近的簇。\r\n\r\n但并不意味着K-Means只能使用欧式距离来度量案例之间的距离，其余距离公式如下\r\n\r\n+ 曼哈顿距离：用以标明两个点在标准坐标系上的绝对轴距总和, 又名“城市街区距离”，因为城市两点之间的实际距离并不是两点之间的直线距离(因为有建筑物等阻挡)，只能是两点在标准坐标系上的绝对距离之和。\r\n\r\n![](/images/article/k-means2.png)\r\n\r\n+ 切比雪夫距离：是向量空间中的一种度量，二个点之间的距离定义为其各坐标数值差绝对值的最大值。\r\n\r\n![](/images/article/k-means4.png)\r\n\r\n+ 闵可夫斯基距离：两个n维变量a(a1, a2, ..., an)与 b(b1, b2, ...,   bn)间的闵可夫斯基距离定义为：\r\n\r\n![](/images/article/k-means3.png)\r\n\r\n闵可夫斯基距离中，p是一个可变参数，特别的，当p=1时，就是曼哈顿距离；当p=2时，就是欧氏距离；当p→∞时，就是切比雪夫距离。可见，闵氏距离是一组距离而不是一个距离。\r\n\r\n### 1.4 聚类中K的选择\r\n\r\n影响K均值聚类模型的最重要的因素就是K的选择，过大的K利于提升簇内的同质性与簇间的异质性，但是会有过度拟合的风险，过小的K则无法识别类之间的差异。因此，K的选择应该是合适就好，一般有以下方法：\r\n\r\n+ 如果具备真实分组先验知识，那么我们就会提前知道我们想分为几类，那么K就是几，当然这是最理想的；\r\n+ 如果不具备先验知识，那么一个经验性的规则就是令`K = (n / 2) ^ (1 / 2)`，但是对于大样本而言，这无疑仍然会导一个较大的K值；\r\n+ 一种被称为“肘部法”的技术用于衡量关于K值选择的合适的度。一般情况下，**随着K值的增大，簇内部的同质性增强，同样的，簇间的异质性也会增强；但是随着k值的继续增大，簇内部的同质性仍然在增强，但是簇间的异质性却在降低，因为过度拟合**。**理想的情况是，当簇内的同质性与簇间的异质性达到最大时，就应该立即停止K的增大**，这时，K就是最合适的K。\r\n\r\n## 二、K均值聚类学习算法的数学定义\r\n\r\nK均值聚类在实际应用过程中，是用局部最优解来逐步实现全局最优的。即每一次迭代中根据簇内均值计算簇质心，然后将所有训练集样本重新分配，确保每次迭代中每一个样本都是满足“到达某簇质心的距离最小”这一条件的。数学定义如下\r\n\r\n### 2.1 数学定义\r\n\r\n各簇的定义为：\r\n\r\n![](/images/article/k-means8.png)\r\n\r\n可见，分为了c个簇，所有的训练集样本将会被分配到这c个簇当中；\r\n\r\n初始阶段，簇质心随机选择c个。而更新迭代阶段，簇质心的定义(更新规则)为：\r\n\r\n![](/images/article/k-means6.png)\r\n\r\n即对当前簇中各特征求和再除以簇内样本总数，即求均值，然后就会得到簇质心的坐标。\r\n\r\n而在整个模型训练中，对样本分配簇被定义为：\r\n\r\n![](/images/article/k-means7.png)\r\n\r\n其中xi为训练集中某一个样本的特征向量，uy为簇质心的特征向量，为了与绝对值区分，`||xi-uy||`代表两点之间的距离(可以理解为具体距离公式的统称)，那么整个式子的含义是**计算该样本与各个簇心的距离，并为该样本赋予距离最近的簇心类别，即将该样本纳入该簇当中**。上式也就是为达到全局最优解而拆分的局部最优解。\r\n\r\n### 2.2 算法的规范描述\r\n\r\n基于上述数学定义，那么算法的规范描述为：\r\n\r\n1. 给各个簇中心u1, u2, ..., uc以适当的初始值; \r\n2. 更新样本x1, x2, ..., xn对应的聚类标签y1, y2, ..., yn：\r\n![](/images/article/k-means7.png)\r\n3. 更新各个簇中心u1, u2, ..., uc：\r\n![](/images/article/k-means6.png)\r\n4. 直到聚类标签达到收敛精度为止，否则重复上述2，3步的计算。\r\n\r\n## 三、R语言中K均值聚类函数及应用\r\n\r\n### 3.1 K均值聚类函数\r\n使用stats添加包中的`kmeans()`函数来实现K均值聚类，原型如下\r\n\r\n首先建立模型\r\n\r\n```\r\nclusters \u003c- kmeans(mydata, k)\r\n```\r\n\r\n+ mydata：数值型数据框，包含需要聚类的实例；\r\n+ k：聚类的个数。\r\n\r\n该函数返回一个含有K均值聚类结果的对象。\r\n\r\n然后检查聚类结果\r\n\r\n+ `clusters$cluster`是`kmeans()`函数所给出的类成员变量；\r\n+ `clusters$centers`是含有每个类组合和每一个特征的均值的一个矩阵；\r\n+ `clusters$size`给出每一个类中的实例个数。\r\n\r\n### 3.2 K均值聚类函数应用\r\n\r\n本例使用K均值聚类探索青少年市场细分，共包含30 000名青少年随机案例数据集，由于是无监督机器学习，那么我们不需要拆分数据集为训练集与测试集，所有的数据均为训练集或者样本，首先读取数据\r\n\r\n```\r\n\u003e getwd()\r\n[1] \"C:/Users/Administrator/Documents\"\r\n\u003e setwd(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\docs\\\\Machine-Learning-with-R-datasets-master\")\r\n\u003e tee \u003c- read.csv(\"snsdata.csv\")\r\n\u003e str(tee)\r\n'data.frame':\t30000 obs. of  40 variables:\r\n $ gradyear    : int  2006 2006 2006 2006 2006 2006 2006 2006 2006 2006 ...\r\n $ gender      : Factor w/ 2 levels \"F\",\"M\": 2 1 2 1 NA 1 1 2 1 1 ...\r\n $ age         : num  19 18.8 18.3 18.9 19 ...\r\n $ friends     : int  7 0 69 0 10 142 72 17 52 39 ...\r\n $ basketball  : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ football    : int  0 1 1 0 0 0 0 0 0 0 ...\r\n $ soccer      : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ softball    : int  0 0 0 0 0 0 0 1 0 0 ...\r\n $ volleyball  : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ swimming    : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ cheerleading: int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ baseball    : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ tennis      : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ sports      : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ cute        : int  0 1 0 1 0 0 0 0 0 1 ...\r\n $ sex         : int  0 0 0 0 1 1 0 2 0 0 ...\r\n $ sexy        : int  0 0 0 0 0 0 0 1 0 0 ...\r\n $ hot         : int  0 0 0 0 0 0 0 0 0 1 ...\r\n $ kissed      : int  0 0 0 0 5 0 0 0 0 0 ...\r\n $ dance       : int  1 0 0 0 1 0 0 0 0 0 ...\r\n $ band        : int  0 0 2 0 1 0 1 0 0 0 ...\r\n $ marching    : int  0 0 0 0 0 1 1 0 0 0 ...\r\n $ music       : int  0 2 1 0 3 2 0 1 0 1 ...\r\n $ rock        : int  0 2 0 1 0 0 0 1 0 1 ...\r\n $ god         : int  0 1 0 0 1 0 0 0 0 6 ...\r\n $ church      : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ jesus       : int  0 0 0 0 0 0 0 0 0 2 ...\r\n $ bible       : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ hair        : int  0 6 0 0 1 0 0 0 0 1 ...\r\n $ dress       : int  0 4 0 0 0 1 0 0 0 0 ...\r\n $ blonde      : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ mall        : int  0 1 0 0 0 0 2 0 0 0 ...\r\n $ shopping    : int  0 0 0 0 2 1 0 0 0 1 ...\r\n $ clothes     : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ hollister   : int  0 0 0 0 0 0 2 0 0 0 ...\r\n $ abercrombie : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ die         : int  0 0 0 0 0 0 0 0 0 0 ...\r\n $ death       : int  0 0 1 0 0 0 0 0 0 0 ...\r\n $ drunk       : int  0 0 0 0 1 1 0 0 0 0 ...\r\n $ drugs       : int  0 0 0 0 1 0 0 0 0 0 ...\r\n```\r\n\r\n观察到`gender`列存在缺失值，不妨验证一下\r\n\r\n```\r\n\u003e table(tee$gender)\r\n    F     M \r\n22054  5222 \r\n\u003e table(tee$gender, useNA = \"ifany\")\r\n    F     M  \u003cNA\u003e \r\n22054  5222  2724\r\n```\r\n\r\n可见在`gender`列共有2724个缺失值，其它列有缺失值吗，不妨再看看\r\n\r\n```\r\n\u003e summary(tee)\r\n    gradyear     gender           age             friends         basketball     \r\n Min.   :2006   F   :22054   Min.   :  3.086   Min.   :  0.00   Min.   : 0.0000  \r\n 1st Qu.:2007   M   : 5222   1st Qu.: 16.312   1st Qu.:  3.00   1st Qu.: 0.0000  \r\n Median :2008   NA's: 2724   Median : 17.287   Median : 20.00   Median : 0.0000  \r\n Mean   :2008                Mean   : 17.994   Mean   : 30.18   Mean   : 0.2673  \r\n 3rd Qu.:2008                3rd Qu.: 18.259   3rd Qu.: 44.00   3rd Qu.: 0.0000  \r\n Max.   :2009                Max.   :106.927   Max.   :830.00   Max.   :24.0000  \r\n                             NA's   :5086                                        \r\n    football           soccer           softball         volleyball     \r\n Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000  \r\n 1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000  \r\n Median : 0.0000   Median : 0.0000   Median : 0.0000   Median : 0.0000  \r\n Mean   : 0.2523   Mean   : 0.2228   Mean   : 0.1612   Mean   : 0.1431  \r\n 3rd Qu.: 0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.0000  \r\n Max.   :15.0000   Max.   :27.0000   Max.   :17.0000   Max.   :14.0000  \r\n                                                                        \r\n    swimming        cheerleading       baseball           tennis        \r\n Min.   : 0.0000   Min.   :0.0000   Min.   : 0.0000   Min.   : 0.00000  \r\n 1st Qu.: 0.0000   1st Qu.:0.0000   1st Qu.: 0.0000   1st Qu.: 0.00000  \r\n Median : 0.0000   Median :0.0000   Median : 0.0000   Median : 0.00000  \r\n Mean   : 0.1344   Mean   :0.1066   Mean   : 0.1049   Mean   : 0.08733  \r\n 3rd Qu.: 0.0000   3rd Qu.:0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.00000  \r\n Max.   :31.0000   Max.   :9.0000   Max.   :16.0000   Max.   :15.00000  \r\n                                                                        \r\n     sports           cute              sex                sexy        \r\n Min.   : 0.00   Min.   : 0.0000   Min.   :  0.0000   Min.   : 0.0000  \r\n 1st Qu.: 0.00   1st Qu.: 0.0000   1st Qu.:  0.0000   1st Qu.: 0.0000  \r\n Median : 0.00   Median : 0.0000   Median :  0.0000   Median : 0.0000  \r\n Mean   : 0.14   Mean   : 0.3229   Mean   :  0.2094   Mean   : 0.1412  \r\n 3rd Qu.: 0.00   3rd Qu.: 0.0000   3rd Qu.:  0.0000   3rd Qu.: 0.0000  \r\n Max.   :12.00   Max.   :18.0000   Max.   :114.0000   Max.   :18.0000  \r\n                                                                       \r\n      hot              kissed            dance              band        \r\n Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000  \r\n 1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000  \r\n Median : 0.0000   Median : 0.0000   Median : 0.0000   Median : 0.0000  \r\n Mean   : 0.1266   Mean   : 0.1032   Mean   : 0.4252   Mean   : 0.2996  \r\n 3rd Qu.: 0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.0000  \r\n Max.   :10.0000   Max.   :26.0000   Max.   :30.0000   Max.   :66.0000  \r\n                                                                        \r\n    marching           music              rock              god         \r\n Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.0000  \r\n 1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.0000  \r\n Median : 0.0000   Median : 0.0000   Median : 0.0000   Median : 0.0000  \r\n Mean   : 0.0406   Mean   : 0.7378   Mean   : 0.2433   Mean   : 0.4653  \r\n 3rd Qu.: 0.0000   3rd Qu.: 1.0000   3rd Qu.: 0.0000   3rd Qu.: 1.0000  \r\n Max.   :11.0000   Max.   :64.0000   Max.   :21.0000   Max.   :79.0000  \r\n                                                                        \r\n     church            jesus             bible               hair        \r\n Min.   : 0.0000   Min.   : 0.0000   Min.   : 0.00000   Min.   : 0.0000  \r\n 1st Qu.: 0.0000   1st Qu.: 0.0000   1st Qu.: 0.00000   1st Qu.: 0.0000  \r\n Median : 0.0000   Median : 0.0000   Median : 0.00000   Median : 0.0000  \r\n Mean   : 0.2482   Mean   : 0.1121   Mean   : 0.02133   Mean   : 0.4226  \r\n 3rd Qu.: 0.0000   3rd Qu.: 0.0000   3rd Qu.: 0.00000   3rd Qu.: 0.0000  \r\n Max.   :44.0000   Max.   :30.0000   Max.   :11.00000   Max.   :37.0000  \r\n                                                                         \r\n     dress           blonde              mall            shopping     \r\n Min.   :0.000   Min.   :  0.0000   Min.   : 0.0000   Min.   : 0.000  \r\n 1st Qu.:0.000   1st Qu.:  0.0000   1st Qu.: 0.0000   1st Qu.: 0.000  \r\n Median :0.000   Median :  0.0000   Median : 0.0000   Median : 0.000  \r\n Mean   :0.111   Mean   :  0.0989   Mean   : 0.2574   Mean   : 0.353  \r\n 3rd Qu.:0.000   3rd Qu.:  0.0000   3rd Qu.: 0.0000   3rd Qu.: 1.000  \r\n Max.   :9.000   Max.   :327.0000   Max.   :12.0000   Max.   :11.000  \r\n                                                                      \r\n    clothes         hollister        abercrombie           die         \r\n Min.   :0.0000   Min.   :0.00000   Min.   :0.00000   Min.   : 0.0000  \r\n 1st Qu.:0.0000   1st Qu.:0.00000   1st Qu.:0.00000   1st Qu.: 0.0000  \r\n Median :0.0000   Median :0.00000   Median :0.00000   Median : 0.0000  \r\n Mean   :0.1485   Mean   :0.06987   Mean   :0.05117   Mean   : 0.1841  \r\n 3rd Qu.:0.0000   3rd Qu.:0.00000   3rd Qu.:0.00000   3rd Qu.: 0.0000  \r\n Max.   :8.0000   Max.   :9.00000   Max.   :8.00000   Max.   :22.0000  \r\n                                                                       \r\n     death             drunk             drugs         \r\n Min.   : 0.0000   Min.   :0.00000   Min.   : 0.00000  \r\n 1st Qu.: 0.0000   1st Qu.:0.00000   1st Qu.: 0.00000  \r\n Median : 0.0000   Median :0.00000   Median : 0.00000  \r\n Mean   : 0.1142   Mean   :0.08797   Mean   : 0.06043  \r\n 3rd Qu.: 0.0000   3rd Qu.:0.00000   3rd Qu.: 0.00000  \r\n Max.   :14.0000   Max.   :8.00000   Max.   :16.00000  \r\n ```\r\n \r\n发现只有age列和gender列存在缺失值，对待缺失值我们要么插补要么直接删除记录，我们这里使用插补的办法。\r\n \r\n再观察上述基本统计量，我们发现年龄的最小值为3.086，最大值为106.927，这明显是错误的，我们假定青少年的年龄区间是`[13, 20)`，那么我们定义超出该区间的所有数据为异常值，对于异常值，我们可以将其视作缺失值处理，也可以不处理，这里明显需要处理。\r\n \r\n首先，将不符合年龄区间的值统一设置为缺失值，如下\r\n \r\n```\r\n\u003e tee$age \u003c- ifelse(tee$age \u003e= 13 \u0026 tee$age \u003c 20, tee$age, NA)\r\n\u003e summary(tee$age)\r\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \r\n  13.03   16.30   17.27   17.25   18.22   20.00    5523 \r\n```\r\n\r\n接下来需要将年龄的缺失值进行插补，这里使用均值插补法，考虑到毕业年份`gradyear`和年龄`age`之间的关系，我们要计算多次均值来插补，使用`ave()`函数来计算`age`列关于`gradyear`列中各水平的均值，如下\r\n\r\n```\r\n\u003e ave_age \u003c- ave(tee$age, tee$gradyear, FUN = function(x) mean(x, na.rm = TRUE))\r\n\u003e length(ave_age)\r\n[1] 30000\r\n```\r\n\r\n参数`ave_age`包含数据框中以`gradyear`列为基准的`age`列对应的值。然后进行插补\r\n\r\n```\r\n\u003e tee$age \u003c- ifelse(is.na(tee$age), ave_age, tee$age)\r\n```\r\n\r\n如果`tee$age`满足条件`is.na(tee$age)`那么使用该`age`对应的根据`gradyear`得到的均值来插补，否则就原封不动(因为真实的值比虚拟的均值更能说明问题)，再看一下插补结果\r\n\r\n```\r\n\u003e summary(tee$age)\r\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \r\n  13.03   16.28   17.24   17.24   18.21   20.00 \r\n```\r\n\r\n以上是对`age`的处理，而对`gender`的处理我们通过创建虚拟变量来拆分gender语义，因为性别我们无法计算均值，首先我们创建虚拟变量`female`将所有的女性设置为变量1，其余均为0，如下\r\n\r\n```\r\n\u003e tee$female \u003c- ifelse(tee$gender == \"F\" \u0026 !is.na(tee$gender), 1, 0)\r\n\u003e table(tee$female)\r\n    0     1 \r\n 7946 22054 \r\n```\r\n\r\n然后再创建虚拟变量`no_gender`将`gender`中所有的缺失值设置为1，其余为0，如下\r\n\r\n```\r\n\u003e tee$no_gender \u003c- ifelse(is.na(tee$gender), 1, 0)\r\n\u003e table(tee$no_gender)\r\n\r\n    0     1 \r\n27276  2724 \r\n```\r\n\r\n如下，我们通过比较虚拟变量`female`与`no_gender`和变量`gender`发现，虚拟变量值为1的数目与变量`gender`中值为`F`和`NA`的数目是一致的。\r\n\r\n```\r\n\u003e table(tee$gender, useNA = \"ifany\")\r\n\r\n    F     M  \u003cNA\u003e \r\n22054  5222  2724 \r\n\u003e table(tee$female, useNA = \"ifany\")\r\n\r\n    0     1 \r\n 7946 22054 \r\n\u003e table(tee$no_gender, useNA = \"ifany\")\r\n\r\n    0     1 \r\n27276  2724 \r\n```\r\n\r\n在创建虚拟变量之后，数据框变量数量也变成了42个\r\n\r\n```\r\n\u003e str(tee)\r\n'data.frame':\t30000 obs. of  42 variables:\r\n\r\n $ female      : num  0 1 0 1 0 1 1 0 1 1 ...\r\n $ no_gender   : num  0 0 0 0 1 0 0 0 0 0 ...\r\n```\r\n\r\n我们暂且选择36个特征，并将相关的值进行标准化操作，如下\r\n\r\n```\r\n\u003e ts \u003c- tee[5 : 40]\r\n\u003e ts_z \u003c- as.data.frame(lapply(ts, scale))\r\n```\r\n\r\n然后进行聚类并查看簇数目以及簇内样本数\r\n\r\n```\r\n\u003e ts_clusters \u003c- kmeans(ts, 5)\r\n\u003e ts_clusters$size\r\n[1]  4937 22254  1202  1208   399\r\n```\r\n\r\n也可以查看各簇最终的质心坐标，如下\r\n\r\n```\r\n\u003e ts_clusters$centers\r\n  basketball  football    soccer  softball volleyball  swimming cheerleading\r\n1  0.2868139 0.2928904 0.2602795 0.1802714  0.1474580 0.1861454   0.09459186\r\n2  0.2298014 0.2149726 0.1969534 0.1441539  0.1302238 0.1124292   0.09526377\r\n3  0.7762063 0.6630616 0.5382696 0.3552413  0.3202995 0.2995008   0.28785358\r\n4  0.3625828 0.3716887 0.2408940 0.1895695  0.1912252 0.1605960   0.18791391\r\n5  0.2982456 0.2330827 0.1929825 0.2055138  0.1303258 0.1428571   0.09774436\r\n    baseball     tennis    sports      cute        sex      sexy       hot\r\n1 0.11221390 0.11829046 0.1691311 0.3607454 0.17318209 0.1498886 0.1484707\r\n2 0.09086007 0.07499775 0.1137773 0.2574818 0.09778017 0.1164285 0.1044756\r\n3 0.35690516 0.17387687 0.5049917 1.0232945 2.47420965 0.4692180 0.3319468\r\n4 0.08526490 0.10264901 0.1225166 0.6688742 0.16639073 0.2293046 0.2235099\r\n5 0.10025063 0.08521303 0.1929825 0.3433584 0.19047619 0.1604010 0.1779449\r\n      kissed     dance      band   marching     music      rock       god    church\r\n1 0.11403686 0.3133482 1.0870974 0.15596516 2.3101074 0.4231315 0.4909864 0.3862670\r\n2 0.04844073 0.2005033 0.1007459 0.01451424 0.3038106 0.1485126 0.3040352 0.1767323\r\n3 1.07820300 0.8569052 0.6663894 0.05407654 2.0316140 1.1605657 0.8386023 0.4068220\r\n4 0.09519868 4.6117550 0.3443709 0.03725166 0.9271523 0.3336093 0.5248344 0.4917219\r\n5 0.11027569 0.3634085 0.4060150 0.03759398 1.0200501 0.2706767 7.8370927 1.3082707\r\n       jesus      bible      hair      dress     blonde      mall  shopping\r\n1 0.13510229 0.02734454 0.3583148 0.13733036 0.07251367 0.3090946 0.4563500\r\n2 0.07764896 0.01285162 0.2316887 0.08164824 0.05194572 0.2039184 0.2962164\r\n3 0.14226290 0.03660566 3.9991681 0.33194676 1.07321131 0.8252912 0.6863561\r\n4 0.11423841 0.02649007 0.6092715 0.30463576 0.09850993 0.4528146 0.6423841\r\n5 1.64912281 0.35839599 0.5238095 0.16791980 0.11278195 0.2957393 0.3609023\r\n    clothes  hollister abercrombie       die     death      drunk      drugs\r\n1 0.1818918 0.06765242  0.04354871 0.2185538 0.1468503 0.09155358 0.06785497\r\n2 0.1040262 0.05895569  0.04147569 0.1331446 0.0871304 0.06385369 0.03181451\r\n3 0.7146423 0.25623960  0.22628952 0.8286190 0.3785358 0.47171381 0.56073211\r\n4 0.2367550 0.10264901  0.09023179 0.2425497 0.1374172 0.11175497 0.05711921\r\n5 0.2431078 0.04511278  0.04010025 0.4812030 0.3558897 0.16040100 0.06766917\r\n```\r\n\r\n而`cluster`分量则保存了每个样本的类别，可以将其作为一列添加到数据框中并查看部分数据，如下\r\n\r\n```\r\n\u003e tee$cluster \u003c- ts_clusters$cluster\r\n\u003e tee[1 : 5, c(\"gender\", \"age\", \"friends\", \"cluster\")]\r\n  gender    age friends cluster\r\n1      M 18.982       7       2\r\n2      F 18.801       0       3\r\n3      M 18.335      69       1\r\n4      F 18.875       0       2\r\n5   \u003cNA\u003e 18.995      10       1\r\n```\r\n\r\n### 3.3 提升模型性能\r\n\r\n无监督学习算法的模型评估不像有监督学习算法一样，因为有监督学习算法的模型评估都有一组训练集的目标值与模型预测值进行对照，因此很容易评估模型性能，但是无监督学习算法则丧失了这个优势。\r\n\r\n无监督学习模型的评估需要根据实际情况来判断。以K均值聚类算法为例，一般情况下评估一个模型是否有用的基本方法之一是检查落在每一组中的案例数，如果簇间的案例分布极不均匀或者某簇的案例过多或过少，那么这个模型就不太有用。\r\n\r\n```\r\n\u003e ts_clusters$size\r\n[1]  4937 22254  1202  1208   399\r\n\u003e prop.table(ts_clusters$size)\r\n[1] 0.16456667 0.74180000 0.04006667 0.04026667 0.01330000\r\n```\r\n\r\n对模型性能的实验，可以通过调整参数k来实现，我们可以尝试几种不同的k值，如下\r\n\r\n```\r\n\u003e ts_clusters \u003c- kmeans(ts, 6)\r\n\u003e prop.table(ts_clusters$size)\r\n[1] 0.15206667 0.13893333 0.62666667 0.02500000 0.03850000 0.01883333\r\n\u003e ts_clusters \u003c- kmeans(ts, 7)\r\n\u003e prop.table(ts_clusters$size)\r\n[1] 0.63376667 0.03773333 0.01903333 0.02416667 0.03093333 0.22570000 0.02866667\r\n\u003e ts_clusters \u003c- kmeans(ts, 8)\r\n\u003e prop.table(ts_clusters$size)\r\n[1] 0.03720000 0.01833333 0.61993333 0.02693333 0.14273333 0.11223333 0.02396667\r\n[8] 0.01866667\r\n\u003e ts_clusters \u003c- kmeans(ts, 9)\r\n\u003e prop.table(ts_clusters$size)\r\n[1] 0.065033333 0.052166667 0.036766667 0.006733333 0.314800000 0.463300000\r\n[7] 0.018933333 0.023766667 0.018500000\r\n```\r\n\r\n### 3.4 统计特征探索\r\n\r\n使用`aggregate()`函数，可以查看某特征在其水平约束下样本的某特征的相关统计量，比如\r\n\r\n```\r\n\u003e aggregate(data = tee, age ~ cluster, mean)\r\n  cluster      age\r\n1       1 17.23996\r\n2       2 17.25926\r\n3       3 16.98906\r\n4       4 17.02734\r\n5       5 17.36524\r\n```\r\n\r\n以上显示了在特征`cluster`五个水平的约束下各自样本的`age`均值，可以得出结论：**年龄并不是引起兴趣不同的主要因素(因为兴趣cluster约束下年龄的均值差别不大)**。\r\n\r\n```\r\n\u003e aggregate(data = tee, friends ~ cluster, mean)\r\n  cluster  friends\r\n1       1 32.13915\r\n2       2 29.23128\r\n3       3 31.43594\r\n4       4 37.36093\r\n5       5 33.28822\r\n```\r\n\r\n以上显示了特征`cluster`五个水平约束下各自样本的朋友数量的均值，可见，有差异但是还是比较集中。\r\n\r\n### 3.5 尾声\r\n\r\n之前在建立模型的时候，我们提取了数据所有行的第5到40列，原因之一就是gender列中还存在缺失值，但是我们通过两个虚拟变量分离出了gender的部分语义，那么我们将该变量再调整一下，以完全表达剩余语义，然后使用全部属性拟合模型，如下\r\n\r\n```\r\n\u003e tee \u003c- read.csv(\"snsdata.csv\")\r\n\u003e tee$age \u003c- ifelse(tee$age \u003e= 13 \u0026 tee$age \u003c 20, tee$age, NA)\r\n\u003e ave_age \u003c- ave(tee$age, tee$gradyear, FUN = function(x) mean(x, na.rm = TRUE))\r\n\u003e tee$age \u003c- ifelse(is.na(tee$age), ave_age, tee$age)\r\n\u003e tee$female \u003c- ifelse(tee$gender == \"F\" \u0026 !is.na(tee$gender), 1, 0)\r\n\u003e tee$no_gender \u003c- ifelse(is.na(tee$gender), 1, 0)\r\n\u003e tee$gender \u003c- ifelse(tee$gender == \"F\" | is.na(tee$gender), 0, 1)\r\n\u003e table(is.na(tee$gender))\r\n\r\nFALSE \r\n30000 \r\n\u003e tee \u003c- as.data.frame(lapply(tee, scale))\r\n\u003e tee_clusters \u003c- kmeans(tee, 5)\r\n\u003e tee_clusters$size\r\n[1]  2659  1766  9993 10485  5097\r\n\u003e prop.table(tee_clusters$size)\r\n[1] 0.08863333 0.05886667 0.33310000 0.34950000 0.16990000\r\n\u003e tee$cluster \u003c- tee_clusters$cluster\r\n\u003e tee[1 : 5, c(\"gender\", \"female\", \"no_gender\", \"age\", \"friends\", \"cluster\")]\r\n      gender     female  no_gender       age    friends cluster\r\n1  2.1782486 -1.6659508 -0.3160137 1.5279745 -0.6345171       5\r\n2 -0.4590691  0.6002378 -0.3160137 1.3694558 -0.8261358       2\r\n3  2.1782486 -1.6659508 -0.3160137 0.9613359  1.0626773       5\r\n4 -0.4590691  0.6002378 -0.3160137 1.4342645 -0.8261358       3\r\n5 -0.4590691 -1.6659508  3.1643138 1.5393598 -0.5523948       2\r\n```\r\n\r\n由于数据标准化方法采用的是`z-score`标准化，所以负值表示低于某列(特征)的均值，正值表示高于某列(特征)的均值。\r\n\r\n全文完！","cover":"/images/k-means.png","link":"k-means-clustering.html","preview":"\u003cp\u003e聚类学习被认为是典型的无监督学习算法，训练集数据没有目标特征。聚类的目标就是探索数据集中蕴藏的内在结构，并将相似或同质的群组数据聚集在一起。\u003c/p\u003e\n","title":"物以类聚——K均值聚类学习算法"},{"content":"\r\n\r\n## 一、SVM简介\r\n\r\n与其他传统的机器学习方法相比较，支持向量机(Support Vector Machine)的特点如下\r\n\r\n1. 以严格的数学理论为基础，克服了传统神经网络学习中靠经验和启发的先验成分等缺点;\r\n2. 以寻找特征空间最优超平面为目标使得学习器具有良好的泛化能力;\r\n3. 用内积的回旋巧妙地构造核函数，克服了特征空间中的维数灾难问题，通过非线性映射，只需在原空间中计算样本数据与支持向量的内积，而不需要知道非线性映射的显性表达式;\r\n4. 成功地解决了小样本学习问题，克服了传统上需要以样本数目无穷多为假设条件来推导各种算法的缺点，得到了小样本条件下的全局最优解。\r\n\r\n支持向量机包含三个主要思想：\r\n\r\n1. 最优超平面技术(控制决策面的推广能力或泛化能力);\r\n2. 硬间隔支持向量分类(决策边界从正负样本中间穿过)与软间隔支持向量分类(允许间隔计算中存在少许的误差);\r\n3. 内积核函数思想(使解平面从线性扩展到非线性)。\r\n\r\n## 二、硬间隔支持向量\r\n\r\n在数据线性可分的前提下，以分类任务为例，支持向量机可以理解为训练集中由不包括预测类在内的n维向量组成的特征空间中的一个n - 1维的超平面，该平面定义了各个数据点之间的界限。该超平面可以称之为**决策边界**。\r\n\r\n### 2.1 从二维空间推广到高维特征空间\r\n\r\n高维特征空间比较烧脑，不妨以二维特征空间为例，那么划分该二为特征空间的超平面的维数就是1，即一条线。\r\n\r\n有如下两种图形，分别是红圈与蓝星，直观上，我们可以用直线B将二者一刀切，正确划分！而直线A与直线C则表现得不是很好，产生了一定的误差。\r\n\r\n![](/images/article/svm1.png)\r\n\r\n事实上，如果我们愿意，甚至可以画出无数条可以正确区分二者的直线。\r\n\r\n![](/images/article/svm2.png)\r\n\r\n但是，这是样本较少的情况，如果测试集数据很多，那么我们当前看似能够正确区分二者的直线就有可能无法正确分割。有效应对这种问题的办法就是**寻找两个类之间最大间隔的最大间隔超平面**。\r\n\r\n那么在条件**两个类之间最大间隔的最大间隔超平面**的约束下，我们应该选择哪一条作为**决策边界**(超平面)？有两个办法(以本例为例)：\r\n\r\n第一种办法是，**求两种类边界组成的凸包间最短距离的直线的垂直平分线**。\r\n\r\n![](/images/article/svm4.png)\r\n\r\n上图中分别勾勒出了红圈与蓝星边界构成的凸包，绿色方点虚线为两个凸包之间的最短直线，而直线C则是穿过该最短直线的垂直平分线。那么直线C就是该问题中的最大间隔超平面或者决策边界。为什么一定要是垂直平分线呢？垂直平分线将两个凸包边界的最短距离平分，这样保证决策边界对两个类别是不偏不倚的，如果决策边界位于直线C的左边，那么蓝星就有可能越过该决策边界，同理，如果决策边界位于当前决策边界C的右边，红圈就有可能越过该决策边界。所以，垂直平分最短距离直线的直线才是本例中最好的决策边界。\r\n\r\n另一种办法是**通过寻找两个将一组数据划分为同类组的两个平行平面，但这两个平面本身却要尽可能远离，通过这两个平行平面确定决策边界**。\r\n\r\n![](/images/article/svm3.png)\r\n\r\n如上图所示，我们寻找到了两个能将一组数据划分为同类组的两个平行平面，分别是直线A和B，并且直线A与B已经最大程度上相互远离了，这样的话，我们的决策边界就是从这两个平行平面中间穿过的直线C。\r\n\r\n之前说过，支持向量机以严格的数学理论为基础，我们现在的问题是如何给决策边界或者说硬间隔支持向量分类的决策边界下数学定义。\r\n\r\n对于直线C，我们设其斜率为k，截距为b，那么其直线方程为：\r\n\r\n![](/images/article/svm5.png)\r\n\r\n同上一篇文章我们推理人工神经网络带0/1输出的硬阈值激活函数的过程相似，斜率k可以看作是特征x的权重，相应的特征y的权重为-1，截距仍然为b。\r\n\r\n这里的y并不是单纯的数学上的y，而是特征空间中的另一个特征，真正的y是分类的结果。以上直线方程是建立在二维特征空间的基础之上的，如果将其推广到高维空间，那么就会有如下的表达式：\r\n\r\n![](/images/article/svm6.png)\r\n\r\n其中，`fw,r(x)`代表预测类，即真正的y值，而`W的转置`代表特征空间x向量中各分量的权重，`r`代表截距。这不就是一个多元线性回归方程嘛，可以这么理解，但是不要被回归方程的思维所桎梏。那么我们再重新定义一下，其实`w`和`r`分别对应于把正样本和负样本隔离开的决策边界的法向量和截距。\r\n\r\n同上面说的一样，上述方程式在训练集样本完全线性可分的情况下仍然会有无数条直线满足条件，也就意味着分类效果仍然会受训练集样本概括性的影响，其泛化能力取决于测试集的实际情况。因为上述方程并未添加任何约束条件。我们接下来将其约束进一步确保我们的决策边界是唯一的是仅仅在训练集的条件下就具备泛化能力的。\r\n\r\n之前说过，决策边界是由两个平行平面决定的，也就意味着方程式斜率(特征空间各特征分量的权重)是一致的，即`w`相同，由于是二分类问题，我们定义正样本的边界(非决策边界而是正样本的与决策边界相平行的平行平面)为：\r\n\r\n![](/images/article/svm7.png)\r\n\r\n那么同理，负样本的边界定义为：\r\n\r\n![](/images/article/svm8.png)\r\n\r\n也就是说，所有的正样本被定义为1，所有的负样本被定义为-1，可以将这里的1与-1理解为训练集样本的实际值，但是为什么一定要定义为-1和1呢？这是因为一正一负最容易处理，而+1和-1更容易处理。\r\n\r\n综上，就有如下表达式：\r\n\r\n![](/images/article/svm9.png)\r\n\r\n其中`fw,r(x)`表示根据特征空间得到的预测值，而`yi`表示训练集样本目标值，由于我们上述将正样本的目标值定义为了`+1`，那么如果正样本的特征向量带入`fw,r(x)`后，得到的值为正，那么`fw,r(x)yi`一定为正；同理，我们上述将负样本的目标值定义为了`-1`，那么如果负样本的特征向量带入`fw,r(x)`后，得到的值为负，那么`fw,r(x)yi`也一定为正；也就是说：\r\n\r\n**如果模型正确二分类，那么上述表达式的值一定是大于0的。**\r\n\r\n我们现在找到了正确二分类的条件，但这还是远远不够的，同样的理由：可以正确二分类的函数有若干个(对应于几何解释就是有若干条直线可以正确划分正负样本训练集)，但是能最佳二分类的函数只有一个(对应的几何解释就是两个类之间最大间隔的最大间隔超平面只有一个)，那么接下来的目标就是定义这个最佳的超平面。\r\n\r\n而且我们也看出了，只有将正负样本的`yi`设置为异号时，`fw,r(x)yi`才能保证大于0，当然，也可以将正样本定义为-1，负样本定义为1，这样上述表达式的不等式就应该是小于0，很明显，这样的定义有点反人类。\r\n\r\n继续回到上述表达式(不等式)。该表达式表示了这个模型可以对所有的训练样本(训练集样本定义如下图所示)进行正确的分类：\r\n\r\n![](/images/article/svm10.png)\r\n\r\n由于如下开集约束条件在数学上难以处理：\r\n\r\n![](/images/article/svm11.png)\r\n\r\n而利用参数w和r可以任意取值的性质，可以将其变换为闭集约束条件：\r\n\r\n![](/images/article/svm12.png)\r\n\r\n`fw,r(x)yi \u003e 0`与`fw,r(x)yi \u003e 1`的意义是一样的。即：**满足该条件的样本是可以被正确二分类的**。我们也可以换一种说法，即：**当存在满足这样的条件的(w, r)时，就可以称这样的训练样本为线性可分的样本**。\r\n\r\n对于线性可分的训练样本，可以将所有的**训练样本**都正确分类的解(超平面或决策边界)有无数个。我们的目标就是找到唯一的最佳超平面，这样才能让我们的模型在测试样本上同样具备良好的鲁棒性。\r\n\r\n事实上，我们要做的就是**使得训练集样本数据点最接近决策边界的数据点到决策边界的距离(或间隔)最大**，这是我们的终极目标。这句话有两层含义：\r\n\r\n+ 训练集样本数据点最接近决策边界的数据点；\r\n+ 该数据点(训练集样本数据点最接近决策边界的数据点)到决策边界的距离最大。\r\n\r\n首先看第一层含义，**训练集样本数据点最接近决策边界的数据点**，这不就是求训练集样本到超平面的距离的最小值吗？即，我们如下定义点到超平面的距离(就是点到直线的距离公式在高维空间的推广)：\r\n\r\n![](/images/article/svm13.png)\r\n\r\n那么训练集样本到超平面的距离的最小值就可以定义为：\r\n\r\n![](/images/article/svm14.png)\r\n\r\n由于上式分子大于等于1，那么就等同于\r\n\r\n![](/images/article/svm15.png)\r\n\r\n这样，我们就定义了训练集样本数据点最接近决策边界的数据点。\r\n\r\n接下来看第二层含义，**该数据点(训练集样本数据点最接近决策边界的数据点)到决策边界的距离最大**，也就意味着将上式最大化，即\r\n\r\n![](/images/article/svm16.png)\r\n\r\n由于距离必然是正数，那么也就是说上式的图像就是一个定义域为`(0, +∞)`的反比例函数，让反比例函数值最大，也就意味着距离最小，即\r\n\r\n![](/images/article/svm17.png)\r\n\r\n如果距离的平方最小，那么距离必然最小，即上式等价于\r\n\r\n![](/images/article/svm18.png)\r\n\r\n这样的话，通过上述条件，我们就找到了最佳超平面，但是别忘了，上述条件我们是在训练集样本是线性可分的条件下推导的(因为我们上面定义了在满足`fw,r(x)yi \u003e 1`的条件时，我们就说**当存在这样的条件的(w, y)时，这样的训练集样本为线性可分的样本**，然后我们才在此基础之上推导的)，也就是说上述条件的约束条件就是训练集样本线性可分，即\r\n\r\n![](/images/article/svm19.png)\r\n\r\n上述公式即为**使得训练集样本数据点最接近决策边界的数据点到决策边界的距离(或间隔)最大所对应的分类器**，称之为**硬间隔支持向量机**。公式的含义就是在条件`fw,r(x)yi \u003e 1`的约束下或存在这样的条件的(w, y)时训练集样本线性可分的约束下硬间隔支持向量机(或训练集样本数据点最接近决策边界的数据点到决策边界的距离(或间隔)最大所对应的分类器)的决策边界。\r\n\r\n### 2.2 硬间隔支持向量的纯数学定义\r\n\r\n假设给定一个特征空间上的训练数据集为\r\n\r\n![](/images/article/svm20.png)\r\n\r\n其中\r\n\r\n![](/images/article/svm21.png)\r\n\r\n`xi`为第i个特征向量，`yi`为当前特征向量所代表的数据点的类标记，当类标记为+1时，表示正样本，为-1时表示负样本。还要假设数据集是线性可分的。\r\n\r\n我们如下定义支持向量机的**函数间隔**：\r\n\r\n![](/images/article/svm22.png)\r\n\r\n其中`ri`为数据点到决策边界的距离，为什么这么定义呢？将数据点`n`维特征向量带入决策边界表达式`w * xi + b`中，由于该表达式定义了一个`n - 1`维超平面，如果超平面上的`n - 2`维数据点(就是`n`维特征空间生成的数据点，在高维空间中也是一个超平面)在该超平面上，那么决策边界表达式`w * xi + b`的值必然为0。相反的，如果`n`维特征空间生成的数据点不在该决策边界上，那么表达式`w * xi + b`的值必然不为0，这种情况下，表达式`w * xi + b`代表的是穿过该样本的n维特征空间生成的数据点(也算是一个超平面)在与n-1维决策边界(最佳超平面)间的间隔(函数间隔)。由于`|w * xi + b|`可以`相对`表示数据点与决策边界的远程度(因为`|w * xi + b|`的值越接近于0越说明该数据点越接近决策边界，反之就越远离决策边界)，所以可以通过上述公式度量数据点与决策边界的间隔(函数间隔)。而`yi`表示距离的正负，其实不应该这么说(距离不为负)，`yi`取值为`+1`或`-1`，表示的是正样本或负样本到决策边界的距离，即正负号只是指明了样本的正负，真正的距离通过表达式`w * xi + b`的值来度量。\r\n\r\n还无法理解？好吧，我们考虑由两个特征值构成的特征空间，那么决策边界就是一条一维的直线，同样的，两个特征值构成的数据点(类别)就是一个点，是0维，如果决策边界的表达式如下\r\n\r\n![](/images/article/svm23.png)\r\n\r\n那么，如果一个数据点在该直线上，那么必然满足\r\n\r\n![](/images/article/svm24.png)\r\n\r\n相反，如果一个数据点满足如下关系\r\n\r\n![](/images/article/svm25.png)\r\n\r\n那么就说明该数据点位于决策边界的右下方，即可以分类为正样本。而如果一个数据点满足如下关系式\r\n\r\n![](/images/article/svm26.png)\r\n\r\n那么说明该数据点一定位于决策边界的左上方，即被分类为负样本。\r\n\r\n我们不妨带入一个点(0, 0),得到的值为-4.9，那么说明由特征向量(0, 0)生成的数据点为负样本，那么相应的函数间隔就为`-1 * -4.9 = 4.9 \u003e 0`，这也就说明已经正确分类了。\r\n\r\n为了行文顺利，我们再提供一个数据点(2, 1)，得到的值为-2.5，那么说明由特征向量(2, 1)生成的数据点也是负样本，那么相应的函数间隔就为`-1 * -2.5 = 2.5 \u003e 0`，与数据点(0, 0)相比较，这个数据点与决策边界的间隔更近。这就方便我们度量最小间隔。\r\n\r\n函数间隔数学形式简洁，但是存在不可避免的问题，即：w和b被同时缩小或放大M倍后，超平面并没有变化，但是函数间隔却变化了。所以，需要将w的大小固定，从而使得函数间隔固定，那么此时的间隔也就是几何间隔。\r\n\r\n支持向量机的**几何间隔**定义如下：\r\n\r\n![](/images/article/svm27.png)\r\n\r\n事实上，几何间隔就是点到超平面的距离。那么超平面关于所有样本点的几何间隔的最小值就定义为\r\n\r\n![](/images/article/svm28.png)\r\n\r\n那么这个距离就是所谓的支持向量到决策边界的距离。\r\n\r\n那么根据以上定义，支持向量机的求解最大分割超平面问题可以表示为如下约束最优化问题\r\n\r\n![](/images/article/svm29.png)\r\n\r\n将约束条件两边同除以r，那么就得到\r\n\r\n![](/images/article/svm30.png)\r\n\r\n由于`||w||`与`r`都是标量，所以可以通过如下方式简化约束条件\r\n\r\n![](/images/article/svm31.png)\r\n\r\n那么简化后的约束条件为\r\n\r\n![](/images/article/svm32.png)\r\n\r\n又因为最大化`r`，就等于最大化最小间隔`1 / ||w||`，同理，由于`1 / ||w||`为自变量为`(0, +∞)`的反比例函数，让反比例函数值最大，也就意味着`||w||`最小，如果`(||w||)^2`的值最小，那么`||w||`的值自然最小。\r\n\r\n那么，支持向量机模型的求解最大分割超平面问题又可以表示为如下约束最优化问题：\r\n\r\n![](/images/article/svm33.png)\r\n\r\n## 三、软间隔支持向量\r\n\r\n硬间隔支持向量机要求训练样本是线性可分的，但是实际应用中并不是很常见。软间隔支持向量机的基本思路是：允许在间隔的计算中出现少许的误差，误差定义为\r\n\r\n![](/images/article/svm34.png)\r\n\r\n而在误差出现的情况下的**软间隔支持向量机**定义为：\r\n\r\n![](/images/article/svm35.png)\r\n\r\n上式中，C \u003e 0是用来控制间隔误差的调谐参数。间隔误差在优化中也称为松弛变量。C越大，间隔误差越接近于0，即\r\n\r\n![](/images/article/svm36.png)\r\n\r\n那么软间隔支持向量机越接近于硬间隔支持向量机，即\r\n\r\n![](/images/article/svm37.png)\r\n\r\n## 四、使用核技巧处理非线性问题\r\n\r\n硬间隔支持向量要所有的样本都是线性可分的，软间隔支持向量允许间隔计算中出现少许的误差，但二者的基础都是由n维特征空间定义的数据点都是线性可分的，只是程度不同。\r\n\r\n但是并非n维特征向量定义的数据点一定线性可分，比如\r\n\r\n![](/images/article/svm38.png)\r\n\r\n明显无法线性分离，支持向量机通过使用一种被称为“核技巧”的处理方式就可以将问题映射到一个更高维度的空间中，比如上图我们根据之前的特征定义第三个维度(特征)为`z = x ^ 2 + y ^ 2`，那么就会如下图所示\r\n\r\n![](/images/article/svm39.png)\r\n\r\n这样就又线性可分了。\r\n\r\n具有非线性核的支持向量机通过对数据添加额外的维度，就可以实现线性可分。**本质上讲，核技巧就是添加能够表述度量特征之间数学关系的新特征的过程**。常用的核函数如下:\r\n\r\n+ 线性核函数(linear kernel)：该核函数不需要转换数据，因此可以表示为特征的点积：\r\n\r\n![](/images/article/svm40.png)\r\n\r\n+ 次数为d的多项式核函数(polynomial kernel)：该核函数添加了一个简单的非线性数据变换：\r\n\r\n![](/images/article/svm41.png)\r\n\r\n+ S形核函数(sigmoid kernel)：该核函数产生的支持向量机模型，类似于神经网络使用S形激活函数，使用希腊字母kappa和delta作为核参数：\r\n\r\n![](/images/article/svm42.png)\r\n\r\n+ 高斯RBF核函数(Gaussian RBF kernel)：该核函数类似于RBF神经网络，且对于许多类型的数据都运行的很好，而且被认为是用于许多学习任务的一个合理的开始：\r\n\r\n![](/images/article/svm43.png)\r\n\r\n需要注意的是，对于特定的任务，没有可以依赖的规则用于匹配核函数。在很大程度上拟合取决于要学习的概念以及训练数据的量与特征之间的关系。在许多情况下，一个良好的支持向量机模型可能需要在评估多个核函数的情况下产生。\r\n\r\n## 五、R语言中支持向量机函数及应用\r\n\r\n### 5.1 R语言中支持向量机函数\r\n\r\n使用kernlab添加包的`ksvm()`函数来使用支持向量机，函数原型为\r\n\r\n先创建模型\r\n\r\n```\r\nm \u003c- ksvm(target ~ predictors, data = mydata, kernel = \"rbfdot\", c = 1)\r\n```\r\n\r\n参数解释如下\r\n\r\n+ target：数据框mydata需要建模的输出变量；\r\n+ predictors：要预测的输出变量关于mydata数据框中的特征集；\r\n+ data：训练集数据框；\r\n+ kernel：核函数，包括rbfdot(径向基函数)、polydot(多项式函数)、tanhdot(双曲正切函数)、vanilladot(线性函数)等；\r\n+ c：用于给出违反约束条件时的惩罚，即对于**软边界**的惩罚的大小。较大的c值将导致较窄的边界。\r\n\r\n该函数返回一个可用于预测的支持向量机对象。\r\n\r\n再进行预测\r\n\r\n```\r\np \u003c- predict(m, test, type = \"response\")\r\n```\r\n\r\n参数解释如下\r\n\r\n+ m：由`ksvm()`函数得到的SVM对象；\r\n+ test：测试集数据框；\r\n+ type：当值为response时表明输出为预测类别，当值为probabilities时，表明输出为对应的预测概率。\r\n\r\n该函数根据type参数返回预测类或者预测类概率。\r\n\r\n### 5.2 R语言中支持向量机函数应用\r\n\r\n以光学字符识别案例为例，说明该函数的使用。\r\n\r\n```\r\n\u003e getwd()\r\n[1] \"C:/Users/Administrator/Documents\"\r\n\u003e setwd(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\docs\\\\Machine-Learning-with-R-datasets-master\")\r\n\u003e letters \u003c- read.csv(\"letterdata.csv\")\r\n\u003e str(letters)\r\n'data.frame':\t20000 obs. of  17 variables:\r\n $ letter: Factor w/ 26 levels \"A\",\"B\",\"C\",\"D\",..: 20 9 4 14 7 19 2 1 10 13 ...\r\n $ xbox  : int  2 5 4 7 2 4 4 1 2 11 ...\r\n $ ybox  : int  8 12 11 11 1 11 2 1 2 15 ...\r\n $ width : int  3 3 6 6 3 5 5 3 4 13 ...\r\n $ height: int  5 7 8 6 1 8 4 2 4 9 ...\r\n $ onpix : int  1 2 6 3 1 3 4 1 2 7 ...\r\n $ xbar  : int  8 10 10 5 8 8 8 8 10 13 ...\r\n $ ybar  : int  13 5 6 9 6 8 7 2 6 2 ...\r\n $ x2bar : int  0 5 2 4 6 6 6 2 2 6 ...\r\n $ y2bar : int  6 4 6 6 6 9 6 2 6 2 ...\r\n $ xybar : int  6 13 10 4 6 5 7 8 12 12 ...\r\n $ x2ybar: int  10 3 3 4 5 6 6 2 4 1 ...\r\n $ xy2bar: int  8 9 7 10 9 6 6 8 8 9 ...\r\n $ xedge : int  0 2 3 6 1 0 2 1 1 8 ...\r\n $ xedgey: int  8 8 7 10 7 8 8 6 6 1 ...\r\n $ yedge : int  0 4 3 2 5 9 7 2 1 1 ...\r\n $ yedgex: int  8 10 9 8 10 7 10 7 7 8 ...\r\n\u003e letters_train \u003c- letters[1 : 16000, ]\r\n\u003e letters_test \u003c- letters[16001 : 20000, ]\r\n\u003e library(kernlab)\r\n\u003e letters_model \u003c- ksvm(letter ~ ., data = letters_train, kernel = \"vanilladot\")\r\n Setting default kernel parameters  \r\n```\r\n\r\n可以通过键入SVM模型名称查看关于训练参数和模型拟合度的一些基本信息，如下\r\n\r\n```\r\n\u003e letters_model\r\nSupport Vector Machine object of class \"ksvm\" \r\n\r\nSV type: C-svc  (classification) \r\n parameter : cost C = 1 \r\n\r\nLinear (vanilla) kernel function. \r\n\r\nNumber of Support Vectors : 7037 \r\n\r\nObjective Function Value : -14.1746 -20.0072 -23.5628 -6.2009 -7.5524 -32.7694 -49.9786 -18.1824 -62.1111 -32.7284 -16.2209 ...\r\nTraining error : 0.130062 \r\n```\r\n\r\n可以看出支持向量的类型为分类任务，且惩罚因子C为1，共有7037个支持向量。\r\n\r\n然后进行预测并评估模型性能\r\n\r\n```\r\n\u003e letters_pre \u003c- predict(letters_model, letters_test)\r\n\u003e prop.table(table(letters_pre == letters_test$letter))\r\n\r\n  FALSE    TRUE \r\n0.16075 0.83925 \r\n```\r\n\r\n正确率大概为84%，还是不错的。再试着提升一下模型性能。\r\n\r\n### 5.3 提升模型性能\r\n\r\n提升模型性能主要是通过更换核函数来实现，我们分别试一下常见的核函数，如下\r\n\r\n```\r\n\u003e letters_model \u003c- ksvm(letter ~ ., data = letters_train, kernel = \"rbfdot\")\r\n\u003e letters_pre \u003c- predict(letters_model, letters_test)\r\n\u003e prop.table(table(letters_pre == letters_test$letter))\r\n\r\n FALSE   TRUE \r\n0.0695 0.9305 \r\n\u003e letters_model \u003c- ksvm(letter ~ ., data = letters_train, kernel = \"polydot\")\r\n Setting default kernel parameters  \r\n\u003e letters_pre \u003c- predict(letters_model, letters_test)\r\n\u003e prop.table(table(letters_pre == letters_test$letter))\r\n\r\n  FALSE    TRUE \r\n0.16075 0.83925 \r\n\u003e letters_model \u003c- ksvm(letter ~ ., data = letters_train, kernel = \"tanhdot\")\r\n Setting default kernel parameters  \r\n\u003e letters_pre \u003c- predict(letters_model, letters_test)\r\n\u003e prop.table(table(letters_pre == letters_test$letter))\r\n\r\n FALSE   TRUE \r\n0.9155 0.0845 \r\n```\r\n\r\n可见，当核函数为径向基函数时性能最好，相反，当核函数为双曲正切函数时性能最差。\r\n\r\n全文完！\r\n\r\n###### 参考文献\r\n\r\n1. Introduction to statistical machine learning.\r\n2. Machine Learning With R.\r\n3. https://www.analyticsvidhya.com/blog/2017/09/understaing-support-vector-machine-example-code/","cover":"/images/svm.jpg","link":"support-vector-machine.html","preview":"\u003cp\u003e支持向量机基于间隔最大化原理，以严格的数学理论为基础，以寻找特征空间最优超平面为目标，以内积的回旋巧妙地构造核函数，适用于数值预测以及分类任务。\u003c/p\u003e\n","title":"转导推理——支持向量机"},{"content":"\r\n\r\n## 一、从生物神经网络到人工神经网络\r\n如同人脑使用一个被称为神经元的相互连接的细胞网络来创建一个巨大的并行处理器一样，人工神经网络使用人工神经元或节点的网络来解决学习问题。既然，人工神经网络基于生物神经网络，那么有必要了解一下生物神经细胞或神经元的组成。\r\n\r\n### 1.1 生物神经网络\r\n\r\n![神经元结构图](/images/article/shenjingyuan.jpg)\r\n\r\n如上图所示，每个神经元由包含一个细胞核的一个细胞体组成。从细胞体分支扩展出许多被称为**树突**的神经纤维和一根长的称为**轴突**的神经纤维。其中，树突接受神经冲动作为神经元的输入信号，但神经元并非对所有的神经冲动进行处理，而是在神经冲动信号达到一个阈值后才会处理并将输出信号通过轴突传递给下层神经元。**突触**则是神经元的连接，与轴突相区分，突触包含以下三种：\r\n\r\n+ 轴突-树突突触：一个神经元的轴突与下一个神经元的树突相连；\r\n+ 轴突-胞体突触：一个神经元的轴突与下一个神经元的胞体相连；\r\n+ 轴突-轴突突触：一个神经元的轴突与下一个神经元的轴突相连；\r\n\r\n![突触示意图](/images/article/tuchu.jpg)\r\n\r\n神经元对神经信号的处理是有条件的，即必须达到一个阈值。如何判断呢？答案是通过神经冲动相对重要性或频率的加权和。如果加权和达到该阈值，那么神经元将会处理(激活)该神经信号，否则不予理会。事实上，每个神经元都是这么干的。那么直观上，神经元的功能就是**求和**与**激活**。\r\n\r\n### 1.2 人工神经网络\r\n人工神经网络作为生物神经网络的仿真，那么将概念迁移过来，首先图示如下\r\n\r\n![神经元对比示意图](/images/article/artificial-neural.png)\r\n\r\n可以看出，一个有向网络图定义了神经元对输入信号(变量X)的接收，每个特征对应一个输入，每个输入连向神经元的有向线段上表明了该信号的权重，那么众多输入信号在每个神经元处首先被加权求和，然后将加权和结果作为神经元激活函数的自变量就可以得到该神经元的输出，该输出将会作为下一个神经元的输入，下一个神经元仍然会进行同样的加权求和和激活操作。\r\n\r\n一个典型的具有n个输入树突的神经元可以用如下公式来表示\r\n\r\n![具备n个输入的神经元](/images/article/sum-function.png)\r\n\r\n其中，权重w可以控制n个输入(x)中的每个输入对输入信号之和所做出贡献的大小。激活函数f(x)使用净总和，结果信号y(x)就是输出轴突。\r\n\r\n### 1.3 神经网络的三个特征\r\n定义一个人工神经网络，需要具备三个概念，如下\r\n\r\n+ **激活函数**：将神经元的净输入(加权和)信号转化为单一的输出信号，以便进一步在网络中传播；\r\n+ **网络拓扑**：描述神经网络中神经元的数目及层数以及它们之间的连接方式；\r\n+ **训练算法**：指定如何设置连接权重，以便抑制或者增加神经元在输入信号中的比重。\r\n\r\n它们之间的关系为，**网络拓扑**由一层层神经元组成，每层包含若干个神经元，这些(不同层)神经元组成了人工神经网络的基本骨架；其中每个神经元都会进行加权求和与激活操作，实质上就是每个神经元通过自己的**激活函数**将净输入转化为输出(如上面的公式所示)，以便进一步传播。而**训练算法**则是对神经网络的调整，即通过后向传播算法进行神经元权重的修正。\r\n\r\n## 二、激活函数\r\n激活函数是神经元处理信号的一个过程，涉及对总的输入信号进行求和，然后确定加权和是否满足阈值，如果满足，就产生输出，否则不进行任何操作。\r\n\r\n这里只介绍带0/1输出的硬阈值激活函数(图a)和logistic激活函数(图b)，图像如下\r\n\r\n![激活函数](/images/article/active-function.png)\r\n\r\n### 2.1 带0/1输出的硬阈值激活函数\r\n带0/1输出的硬阈值激活函数只适合问题线性可分的情况，即训练集属性组成的n维空间可以被n-1维超平面二分类。我们以训练集只有两个输入的样本为例，试说明带0/1输出的硬阈值激活函数的实际情况\r\n\r\n下图显示了两个输入x1(横轴)和x2(纵轴)，分别代表了地震的深层和表层的震级\r\n\r\n![地震与地下爆炸](/images/article/geogebra-export.png)\r\n\r\n其中，红点代表核爆，蓝点代表真正的地震，我们可以看出，如果我们对属性x1-x2进行线性回归，那么我们会得到一条直线，直线上下方分别是分类的结果，上方为地震，下方为核爆，我们先求直线的方程式，如下\r\n\r\n![直线方程](/images/article/fangchengshi.png)\r\n\r\n那么也就是说如果直线方程求解大于0那么就属于核爆，如果小于0就属于地震。我们观察一下直线方程，可以看出1.7是变量x1的系数，也可以说是x1的**权重**，同理，-1则是x2的**权重**，而截距-4.9我们称之为**偏置**。\r\n\r\n那么我们就可以这样定义上面的方程式\r\n\r\n![直线方程转带权求和形式](/images/article/sum.png)\r\n\r\n那么就成了，如果X大于0那么就是核爆，如果小于0就是地震，明显是个二分类问题，不妨用1代表核爆，用0代表地震，那么就有如下关系式\r\n\r\n![带0/1输出的硬阈值激活函数表达式](/images/article/0-1.png)\r\n\r\n上述关系式正是带0/1输出的硬阈值激活函数的表达式。\r\n\r\n到这里我们可以看出，激活函数实际上屏蔽了线性回归求权重与偏置的过程。由于神经网络伊始不包含先验知识，所以刚开始随机设置权重(而不是像我们一样通过拟合方程求权重)，然后将最终的输出信号与训练集的真实目标值进行比较，如果不同，则通过后向传播算法通过梯度下降修正权重，最终得到合理的输出结果(即与训练集目标值的误差最小)。\r\n\r\n但是实际应用当中，很少使用带0/1输出的硬阈值激活函数，因为该激活函数在X = 0处是不可微的，而且在X != 0处导数处处为0，这就导致无法在后向传播中通过梯度下降来修正权重。对于这样的分类器而言，模型的调整(权重的修正)总是会受该激活函数输出值的两个极端(0或者1)的影响,而且模型的调整(几何上就是那条一刀切的直线的调整，对应的就是权重的修正)显得困难重重而低效。而且对于线性不可分的问题无能为力，因为无法一刀切！\r\n\r\n那么我们就需要找一个可微的激活函数，这样，在后向传播中就可以充分利用梯度下降算法来修正神经元权重。\r\n\r\n### 2.2 logistic激活函数\r\n该激活函数的图像如上图所示，可以看出，该激活函数是可微的，这样对于创建高效的人工神经网络优化算法是至关重要的。与带0/1输出的硬阈值激活函数比较，区别主要在\r\n\r\n+ 带0/1输出的硬阈值激活函数的输出是二分类，不是0就是1；但是logistic激活函数输出的则是0或1的概率；\r\n+ 带0/1输出的硬阈值激活函数是不可微的，只适合处理线性可分问题；但是logistic激活函数是可微的，可以通过梯度下降来修正神经元权重，这样模型的调整非常高效。\r\n\r\nlogistic激活函数对于线性可分的情况，回归收敛速度较慢但表现得更加可预期；对于数据含噪音，且非线性可分的情况，logistic激活函数回归收敛速度明显更快且更稳定。\r\n\r\n## 三、网络拓扑\r\n### 3.1 层的数目\r\n单层网络只有一组连接权重，适用于基本的模式分类，特别适用于线性可分的问题；\r\n\r\n多层网络添加了一个或者多个隐藏层，它们(隐藏层)在信号到达输出节点之前处理来自节点的信号。\r\n\r\n### 3.2 信息传播方向\r\n\r\n![前馈网络](/images/article/qiankuiwangluo.jpg)\r\n\r\n前馈网络：神经网络中的信号在一个方向上从一个节点到另一个节点连续的传送，直至到达输出层；\r\n\r\n![递归网络](/images/article/diguiwangluo.gif)\r\n\r\n递归网络：允许信号使用循环在两个方向上传播；\r\n\r\n![多层前馈网络](/images/article/duocengwangluo.jpg)\r\n\r\n多层前馈网络：或称为多层感知器，有一个输入层，中间有一个或多个隐含层，有一个输出层，是人工神经网络拓扑结构中的事实标准。\r\n\r\n### 3.3 每一层节点数\r\n输入节点的个数由训练集数据的特征数量而定。而输出节点的个数由结果中分类水平数目而定，但是隐藏层节点的个数确定起来则没有这么容易，要根据输入节点的个数、训练数据的数量、噪声数据的数量，以及许多其他因素的影响而定。\r\n\r\n需要注意的是，过多的隐藏层神经元有理由训练出更严格的模型，但也可能会有过度拟合的风险。一般情况下，至少有一个多神经元隐藏层。\r\n\r\n## 四、训练算法(梯度下降与后向传播)\r\n\r\n### 4.1 后向传播算法\r\n该算法通过两个过程的多次循环进行迭代，每次迭代称为一个**新纪元**。由于初始的神经网络里面不包含先验知识，所以在开始之前先随机设定网络拓扑中每个输入的权重，然后算法通过过程循环，直到达到一个停止准则。该循环过程包括：\r\n\r\n+ 在前向阶段中，神经元在输入层到输出层的序列中被激活，沿途应用每一个神经元的权重和激活函数，一旦到达最后一层，就产生一个输出信号。\r\n+ 在后向阶段中，由前向阶段产生的网络输出信号与训练数据中的真实目标值进行比较，网络的输出信号与真实目标值之间的差异产生的误差在网络中向后传播，从而来修正神经元之间的连接权重，从而减少神经网络最终输出值与训练集数据目标值的误差。\r\n\r\n但是，每个神经元的输入与输出之间的关系很复杂，我们又如何确定神经元的权重该改变多少呢？\r\n\r\n答案是通过**梯度下降算法**来实现。\r\n\r\n### 4.2 梯度下降算法\r\n首先看一下什么是梯度下降算法。\r\n\r\n### 4.2.1 一个例子\r\n首先我们有一个可微的函数，假设这个函数代表一座山，一个人因为大雾被困在山顶，由于山上浓雾很大，他想下山应该怎么做？注意，由于大雾的影响他只能看见较近的地方，这样他每次只能走最陡峭的地方，因为下降的幅度更大，更容易接近山底(虽然现实当中很危险，但是这里是在解释算法，不必较真)，他每走一步都选择最陡峭的地方走，这样就会很快下山。\r\n\r\n![慢慢就会走到山底](/images/article/valley.png)\r\n\r\n这座山的前提是一个可微函数，那么最陡峭也就意味着斜率最大，由于是下山，那么斜率必然是负数，那么就可以用如下数学形式定义这个人的下次落脚点\r\n\r\n![下一步的位置](/images/article/luojiaodian.png)\r\n\r\n其中Θ1表示下一次的位置，Θ0表明本次的位置，α表示步长，最后一个参数表示我们山的陡峭程度，如果我们的山越陡峭，同时这个人的步长α越大，那么他走的肯定很快，但是同样的，他有可能会错过最佳的山底位置，因为他看不到。如果步长小，那么他会走的慢一点，这样他就不会错过最佳的山底位置。\r\n\r\n以上是梯度下降法在下山上的应用，你只需要记住一点，就是**步长(学习率)的大小决定了下山的快慢以及与目标的接近程度**。\r\n\r\n我们回过头来再看梯度下降法的数学定义。\r\n\r\n梯度实际上就是多变量微分的一般化，即对每个变量分别微分，然后组合在一起，形成一个向量，那么必然的有以下结论：\r\n\r\n+ **在单变量函数中，梯度其实就是函数的微分，代表着函数在某个给定点的切线的斜率，即变化率**；\r\n+ **在多变量函数中，梯度是一个向量，梯度的方向就指出了函数在给定点的上升(或下降，因符号而异)最快的方向**。\r\n\r\n### 4.2.2 单变量函数梯度\r\n那么在单变量情况下，我们求一下单变量函数的梯度下降，假定我们有如下单变量函数\r\n\r\n![单变量函数](/images/article/danbianliangtidu.png)\r\n\r\n初始化起点θ0 = 1，学习率α = 0.4，然后进行梯度下降计算\r\n\r\n![计算单变量梯度](/images/article/tidudanbianliang.png)\r\n\r\n如果这个人登山的函数就是这个单变量函数的话，那么也就意味着他只需要四次就可以下山(到达函数最低点)\r\n\r\n![单变量梯度下降](/images/article/jieguotidu.png)\r\n\r\n### 4.2.3 多变量函数梯度\r\n现假设有如下多变量函数\r\n\r\n![多变量函数](/images/article/duobianliangtidu.png)\r\n\r\n初始化起点与步长Θ0 = (1,3)，α = 0.1，该多变量函数梯度如下\r\n\r\n![多变量函数梯度](/images/article/tidu.png)\r\n\r\n然后进行梯度下降计算\r\n\r\n![计算多变量梯度](/images/article/duobianliangtidujisuan.png)\r\n\r\n然后，随着梯度下降，我们发现，实际上已经慢慢的到达了多变量函数的最小值点\r\n\r\n![多变量梯度下降](/images/article/resultduobianliang.png)\r\n\r\n### 4.2.4 回到后向传播算法\r\n上述通过对激活函数的阐述，我们可以知道，影响神经网络输出值与训练集目标值之间误差大小的参数就是各神经元的权重以及偏置，若各神经元权重与偏置构成的多变量成本函数**J(w, b)**越大，最终神经网络输出值与训练集目标值之间的误差越大，那么相应的，我们如果求多变量成本函数**J(w, b)**最小值，那么也就意味着神经网络输出值与训练集目标值之间的误差越小。\r\n\r\n![成本函数最小值](/images/article/chengbenhanshu.png)\r\n\r\n所以，在后向传播算法的后向阶段，我们修正神经元的核心技术就是通过梯度下降算法最小化我们的成本函数**J(w, b)**,对应的就是求由w、b以及目标成本函数J(w, b)间关系构成的二次曲面的最低点，也就是成本函数的最小值。\r\n\r\n那么运用梯度下降，以此来修正神经元权重与偏置\r\n\r\n![梯度下降](/images/article/luojiaodian.png)\r\n\r\n事实上，在后向传播中与学习率α(步长)相乘的成本函数的梯度就是总误差对相邻节点(神经元)权重的导数，这里需要通过链式求导来计算，因为神经网络输出的神经元还进行了一次求加权和的操作，然后将此加权和作为当前节点(或神经元)的激活函数的输入最终产生输出。\r\n\r\n### 4.3 通过梯度下降法更新神经元权重\r\n\r\n我们考虑一个全新的例子，这里基本上将会综合上述所有内容。假定有如下神经网络拓扑\r\n\r\n![神经网络拓扑](/images/article/example0.png)\r\n\r\n我们给输入赋初值，并加上权重以及偏置，并对输出再赋值以进行比较确定误差\r\n\r\n![带权重、偏置与初值的神经网络拓扑](/images/article/neural_network-9.png)\r\n\r\n接下来**前向传播**\r\n\r\n计算h1神经元的输入加权和以及以logistic作为激活函数的输出\r\n\r\n![h1神经元加权和](/images/article/example1.png)\r\n\r\n![h1神经元激活函数输出](/images/article/example2.png)\r\n\r\n同样的方法计算h2神经元的激活函数输出\r\n\r\n![h2神经元激活函数输出](/images/article/example3.png)\r\n\r\n同样的方法再计算o1和o2的激活函数输出\r\n\r\n![o1加权和与激活函数输出](/images/article/example4.png)\r\n\r\n![o2激活函数输出](/images/article/example5.png)\r\n\r\n前向传播中我们得到的目标输入为[0.75136079 , 0.772928465]，但是训练集目标值为[0.01 , 0.99]，可见误差还很大。接下来，我们通过后向传播来训练神经网络，修正神经元权重，降低误差\r\n\r\n\r\n接下来就是**后向传播**并通过梯度下降法修正权重，其中成本函数的梯度就是总误差对某神经元链式求导。首先计算它们的总误差，公式为\r\n\r\n![o2激活函数输出](/images/article/latex.png)\r\n\r\n先分别计算o1与o2对应训练集目标值的误差，然后加总\r\n\r\n![o1相对于训练集目标值误差](/images/article/latex (1).png)\r\n\r\n![o2相对于训练集目标值误差](/images/article/latex (2).png)\r\n\r\n![总误差](/images/article/latex (3).png)\r\n\r\n先求成本函数的梯度，即总误差关于神经元h1上权重w5的导数，这是一个链式求导的过程，如下图所示\r\n\r\n![链式求导](/images/article/output_1_backprop-4.png)\r\n\r\n开始求导，分别求各部分\r\n\r\n![第一部分](/images/article/example6.png)\r\n\r\n![第二部分](/images/article/examle7.png)\r\n\r\n![第三部分](/images/article/example8.png)\r\n\r\n然后各部分相乘\r\n\r\n![三部分相乘](/images/article/example9.png)\r\n\r\n然后我们就可以更新权重w5的值了，如下\r\n\r\n![更新w5权重](/images/article/latex (4).png)\r\n\r\n类似的方式我们可以更新其余权重，如下\r\n\r\n![更新其余权重](/images/article/example10.png)\r\n\r\n以上是与总误差最关联的输出层的权重更新，对于隐含层而言，更新权重示意图及公式如下\r\n\r\n![更新隐藏层神经元权重示意图](/images/article/nn-calculation.png)\r\n\r\n可见链式传导路径为`out(h1) ——\u003e net(h1) ——\u003e w1`, 在前向传播中out(h1)会影响out(o1)和out(o2), 那么对应的在后向传播中计算E(total)关于out(h1)的导数必然要考虑out(h1)它对两个输出神经元的影响，那么E(total)关于out(h1)的导数如下计算\r\n\r\n![E(total)关于out(h1)的导数计算方式](/images/article/latex (5).png)\r\n\r\n下面开始梯度下降更新w1的权重\r\n\r\n![](/images/article/latex (6).png)\r\n\r\n![](/images/article/latex (7).png)\r\n\r\n![](/images/article/latex (8).png)\r\n\r\n![](/images/article/latex (9).png)\r\n\r\n![](/images/article/latex (10).png)\r\n\r\n以上计算出了E(o1)关于out(h1)的导数，下面用同样的方式计算E(o2)关于out(h1)的导数，过程略\r\n\r\n![](/images/article/latex (11).png)\r\n\r\n根据公式，二者相加，得到E(total)关于out(h1)的导数\r\n\r\n![](/images/article/latex (12).png)\r\n\r\n下面就简单了，计算out(h1)关于net(h1)的导数\r\n\r\n![](/images/article/latex (13).png)\r\n\r\n![](/images/article/latex (14).png)\r\n\r\n然后再计算net(h1)关于w1的导数，如下\r\n\r\n![](/images/article/latex (15).png)\r\n\r\n![](/images/article/latex (16).png)\r\n\r\n最终三者相乘链式求导得到E(total)关于w1的导数\r\n\r\n![](/images/article/latex (17).png)\r\n\r\n![](/images/article/latex (18).png)\r\n\r\n然后就可以根据梯度下降公式更新w1的权重\r\n\r\n![](/images/article/latex (19).png)\r\n\r\n同样的方式更新w2、w3、w4的权重，如下，过程略\r\n\r\n![](/images/article/latex (20).png)\r\n\r\n![](/images/article/latex (21).png)\r\n\r\n![](/images/article/latex (22).png)\r\n\r\n这样，我们就梯度不断下降，最终已经找到了多变量成本函数**J(w, b)**的最小值，那么也就意味着神经网络输出节点与训练集目标值之间的误差已经最小了。\r\n\r\n我们再次通过训练后的神经网络重新计算，输出节点得到的值为[0.015912196,0.984065734]，而训练集目标值为[0.01 , 0.99], 可见，误差已经相当低了。\r\n\r\n## 五、R语言中神经网络实现与应用\r\n### 5.1 R语言中神经网络函数用法\r\n我们使用neuralnet添加包中的`neuralnet()`函数来实现神经网络，函数原型为\r\n\r\n首先建立模型\r\n```\r\nm \u003c- neuralnet(target ~ predictors, data = mydata, hidden = 1)\r\n```\r\n参数解释如下\r\n\r\n+ target：数据框mydata中需要建模的输出变量；\r\n+ predictors：是数据框mydata中用于预测的特征集(是一个公式)；\r\n+ data：训练集数据框；\r\n+ hidden：神经网络隐藏层神经元数目，默认为1。\r\n\r\n该函数返回一个神经网络模型对象\r\n\r\n然后进行预测\r\n```\r\np \u003c- compute(m, test)\r\n```\r\n\r\n参数解释如下\r\n\r\n+ m：`neuralnet()`函数创建的模型对象；\r\n+ test：测试集数据框。\r\n\r\n该函数返回一个二元素列表，名称分别是`$neurons`和`$net.result`，前者用于保存神经网络中每一层的神经元，后者用于保存模型的预测值。\r\n\r\n### 5.2 R语言中neuralnet()函数应用示例\r\n以《Machine Learning With R》一书中的根据混合物水分特征预测混凝土强度的数据集为例\r\n\r\n先读取数据，然后进行数据标准化操作，因为神经网络运行时最好的情况就是将输入数据缩放到0附近的狭窄范围内，我们使用离差标准化，将数据映射到[0, 1]区间，由于数据集已经是随机排列，那么直接提取训练集与测试集\r\n```\r\n\u003e getwd()\r\n[1] \"C:/Users/Administrator/Documents\"\r\n\u003e setwd(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\docs\\\\Machine-Learning-with-R-datasets-master\")\r\n\u003e concrete \u003c- read.csv(\"concrete.csv\")\r\n\u003e str(concrete)\r\n'data.frame':\t1030 obs. of  9 variables:\r\n $ cement      : num  540 540 332 332 199 ...\r\n $ slag        : num  0 0 142 142 132 ...\r\n $ ash         : num  0 0 0 0 0 0 0 0 0 0 ...\r\n $ water       : num  162 162 228 228 192 228 228 228 228 228 ...\r\n $ superplastic: num  2.5 2.5 0 0 0 0 0 0 0 0 ...\r\n $ coarseagg   : num  1040 1055 932 932 978 ...\r\n $ fineagg     : num  676 676 594 594 826 ...\r\n $ age         : int  28 28 270 365 360 90 365 28 28 28 ...\r\n $ strength    : num  80 61.9 40.3 41 44.3 ...\r\n\u003e normalize \u003c- function(x) {\r\n+     return ((x - min(x)) / (max(x) - min(x)))\r\n+ }\r\n\u003e concrete_norm \u003c- as.data.frame(lapply(concrete, normalize)) \r\n\u003e concrete_train \u003c- concrete_norm[1 : 700, ]\r\n\u003e concrete_test \u003c- concrete_norm[701 : 1030, ]\r\n```\r\n\r\n可以通过`summary()`函数查看标准前后的描述性统计量，可以发现已经成功标准化了\r\n```\r\n\u003e summary(concrete)\r\n     cement           slag            ash             water        superplastic   \r\n Min.   :102.0   Min.   :  0.0   Min.   :  0.00   Min.   :121.8   Min.   : 0.000  \r\n 1st Qu.:192.4   1st Qu.:  0.0   1st Qu.:  0.00   1st Qu.:164.9   1st Qu.: 0.000  \r\n Median :272.9   Median : 22.0   Median :  0.00   Median :185.0   Median : 6.400  \r\n Mean   :281.2   Mean   : 73.9   Mean   : 54.19   Mean   :181.6   Mean   : 6.205  \r\n 3rd Qu.:350.0   3rd Qu.:142.9   3rd Qu.:118.30   3rd Qu.:192.0   3rd Qu.:10.200  \r\n Max.   :540.0   Max.   :359.4   Max.   :200.10   Max.   :247.0   Max.   :32.200  \r\n   coarseagg         fineagg           age            strength    \r\n Min.   : 801.0   Min.   :594.0   Min.   :  1.00   Min.   : 2.33  \r\n 1st Qu.: 932.0   1st Qu.:731.0   1st Qu.:  7.00   1st Qu.:23.71  \r\n Median : 968.0   Median :779.5   Median : 28.00   Median :34.45  \r\n Mean   : 972.9   Mean   :773.6   Mean   : 45.66   Mean   :35.82  \r\n 3rd Qu.:1029.4   3rd Qu.:824.0   3rd Qu.: 56.00   3rd Qu.:46.13  \r\n Max.   :1145.0   Max.   :992.6   Max.   :365.00   Max.   :82.60  \r\n\r\n\u003e summary(concrete_norm)\r\n     cement            slag              ash             water       \r\n Min.   :0.0000   Min.   :0.00000   Min.   :0.0000   Min.   :0.0000  \r\n 1st Qu.:0.2063   1st Qu.:0.00000   1st Qu.:0.0000   1st Qu.:0.3442  \r\n Median :0.3902   Median :0.06121   Median :0.0000   Median :0.5048  \r\n Mean   :0.4091   Mean   :0.20561   Mean   :0.2708   Mean   :0.4774  \r\n 3rd Qu.:0.5662   3rd Qu.:0.39775   3rd Qu.:0.5912   3rd Qu.:0.5607  \r\n Max.   :1.0000   Max.   :1.00000   Max.   :1.0000   Max.   :1.0000  \r\n  superplastic      coarseagg         fineagg            age         \r\n Min.   :0.0000   Min.   :0.0000   Min.   :0.0000   Min.   :0.00000  \r\n 1st Qu.:0.0000   1st Qu.:0.3808   1st Qu.:0.3436   1st Qu.:0.01648  \r\n Median :0.1988   Median :0.4855   Median :0.4654   Median :0.07418  \r\n Mean   :0.1927   Mean   :0.4998   Mean   :0.4505   Mean   :0.12270  \r\n 3rd Qu.:0.3168   3rd Qu.:0.6640   3rd Qu.:0.5770   3rd Qu.:0.15110  \r\n Max.   :1.0000   Max.   :1.0000   Max.   :1.0000   Max.   :1.00000  \r\n    strength     \r\n Min.   :0.0000  \r\n 1st Qu.:0.2664  \r\n Median :0.4001  \r\n Mean   :0.4172  \r\n 3rd Qu.:0.5457  \r\n Max.   :1.0000 \r\n```\r\n\r\n然后建立神经网络模型，如下\r\n```\r\n\u003e library(neuralnet)\r\n\u003e concrete_model \u003c- neuralnet(strength ~ ., data = concrete_train)\r\n```\r\n可以通过`plot()`函数查看神经网络拓扑结构，如下\r\n```\r\n\u003e plot(concrete_model)\r\n```\r\n结构为\r\n\r\n![神经网络拓扑结构](/images/article/neuralnet-img.png)\r\n\r\n图中给出了训练的步数Steps为1230步，还给出了误差平方和Error为5.23158，这两个参数对于度量模型性能很重要。图中仍然给出了每个神经元连接处的权重还有偏差项。\r\n\r\n接下来进行预测\r\n```\r\n\u003e model_result \u003c- compute(concrete_model, concrete_test[1 : 8])\r\n\u003e predicted_strength \u003c- model_result$net.result\r\n\u003e cor(predicted_strength, concrete_test$strength)\r\n          [,1]\r\n[1,] 0.7811192\r\n```\r\n\r\n通过`cor()`函数获取神经网络预测值与测试集实际值的相关性，结果为0.7811192，可见具有很强的相关性，这意味着我们神经网络模型还是不错的。我们继续提升神经网络性能。\r\n\r\n### 5.3提升模型性能\r\n`neuralnet()`函数中还有一个参数没有使用，即`hidden`参数，该参数控制神经网络中隐藏层的神经元数目，刚开始默认为1，我们可以试着调整该参数。\r\n```\r\n\u003e concrete_model \u003c- neuralnet(strength ~ ., data = concrete_train, hidden = 5)\r\n\u003e plot(concrete_model)\r\n```\r\n我们设置隐藏层神经元数目为5，那么最终的网络拓扑如下\r\n\r\n![隐藏层多神经元神经网络拓扑结构](/images/article/neuralnet-img-hidden.png)\r\n\r\n明显复杂了很多。但是可以看出，我们的步数Steps变成了13950，而误差平方和Error变成了1.394552，也就是说神经网络复杂了，步数自然会上升，而误差则会下降，再预测一次，如下\r\n```\r\n\u003e model_result \u003c- compute(concrete_model, concrete_test[1 : 8])\r\n\u003e predicted_strength \u003c- model_result$net.result\r\n\u003e cor(predicted_strength, concrete_test$strength)\r\n          [,1]\r\n[1,] 0.7889097\r\n```\r\n从相关性来看，我们之前隐藏层为1个神经元的模型还是相当不错的，而隐藏层神经元调整为5之后降低了模型偏差，但是对预测结果的提升并没有改变多少。\r\n\r\n需要注意的是，过多的隐藏层是会提升模型的精度，但是也会有过度拟合的风险。\r\n\r\n全文完！\r\n\r\n###### 推荐阅读\r\n1. http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html\r\n\r\n###### 参考文献\r\n1. 《Artificial Intelligence: A Modern Approach》\r\n2. 《Machine Learning With R》\r\n3. https://towardsdatascience.com/gradient-descent-in-a-nutshell-eaf8c18212f0\r\n4. https://mattmazur.com/2015/03/17/a-step-by-step-backpropagation-example/","cover":"/images/article/shenjingyuan.jpg","link":"artificial-neural-network.html","preview":"\u003cp\u003e人工神经网络有监督学习算法，适用于数值预测以及分类任务。适合解决输入数据和输出数据都很好理解或简单，但是涉及输入与输出的过程却极其复杂。因此，适合黑箱操作。\u003c/p\u003e\n","title":"黑箱方法——人工神经网络"},{"content":"\r\n\r\n## 一、简介\r\n决策树学习算法以树形结构建立模型，类似于流程图，该模型本身包含一系列逻辑决策。几个概念如下\r\n\r\n+ 决策节点：根据某一特征(属性)作出决定；\r\n+ 决策分支：从决策节点引出的分支表示做出的选择；\r\n+ 终端节点(叶节点)：决策树由叶节点终止，叶节点表示遵循决策组合的结果。\r\n\r\n其运行过程为：数据的分类从根节点开始(根节点是第一个决策节点)，根据特征值遍历树上的各个决策节点。数据采用的是一个漏斗形的路径，它将每一条记录汇集到一个节点，在叶节点为该记录分配一个预测类。\r\n\r\n## 二、理论原理\r\n决策树是决策函数的可视化描述，决策函数是由训练集的特征空间训练出来的，不同属性的不同程度上的不同组合会形成不同的候选函数(或决策树)，拟合优度因函数(或者不同特征的不同程度上的不同组合)而异，有的明显性能出色，有的明显性能低劣，我们不可能将所有的候选函数全部生成然后一一测试，因为多数情况下随着特征的增加，候选函数呈指数级增长。我们的目的就是找到最优的候选函数，何为最优？浅显易懂的来说就是\r\n\r\n\u003e 通过较少的测试达到正确分类，即树中所有路径都较短，整棵树较浅。\r\n\r\n要做到路径较短，那么也就意味着每一次的分裂都要是高效的，即每次分裂都可以提高子集的同质性或者纯度，这样减少了不必要的分割，整棵树必然会变浅。那么专业的来说就是\r\n\r\n\u003e 每一次决策节点的分裂，得到的子集中的预测类的水平的比例与父集合中的预测类的水平的比例**最大程度上**更低。\r\n\r\n## 三、数学定义\r\n决策树算法对以上**最大程度上**的定义是通过**信息增益**实现的。要解释信息增益，先要解释**熵**与**条件熵**。\r\n\r\n熵：熵是随机变量的不确定性度量，信息的获取对应于熵的减少。熵越大说明信息量越大该事件内部越不同质，不确定性越大。熵越小说明信息量越小该事件内部越同质，不确定性越小。举个例子\r\n\r\n+ 明天早上太阳必然升起。这个事件，即随机变量或该事件没有不确定性，是完全同质的(因为只有这一种可能，还是必然的)；\r\n+ 抛一枚硬币，出现正反面朝上的概率皆为0.5。这个事件的熵为1，即随机变量或该事件具有不确定性，是不同质的(因为样本空间存在两种可能，而不是一种)。\r\n\r\n所以，我们可以通过事件的熵来定义该事件内部(样本空间)的同质性或混乱性。熵越大，说明该事件样本空间越不同质越杂乱，实验结果的不确定性更大；熵越小，说明事件样本空间越同质越不杂乱，实验的不确定性更小。其计算公式为\r\n![熵计算公式](/images/article/shang.png)\r\n\r\n条件熵：条件熵表示在已知随机变量X的条件下，随机变量Y的不确定性。将其定义为给定X的条件下Y的条件概率分布的熵对X的数学期望。其本质仍然是熵。其计算公式为\r\n![条件熵计算公式](/images/article/tiaojianshang.png)\r\n\r\n在决策树算法当中，使用熵值来计算由每一个可能特征的分割所引起的同质性(均匀性)变化，该计算称为信息增益。对于特征F，信息增益的计算方法是分割前的数据分区(S_1)的熵值减去由分割产生的数据分区(S_2)的熵值。其中S_1就是分裂前集合预测类水平的熵值，但是集合被通过该特征划分为了若干个子集，怎样计算它们的熵值呢？\r\n\r\n由于一次分割后，数据被划分到了多个分区中，因此计算S_2需要考虑所有分区的熵值总和，这并不意味着简单加总，而是求他们的期望，也就是在分割集合的条件下子集的熵对该次分割的数学期望，即S_2是分割后产生的若干个子集的预测类水平的熵值的期望(即从一个分割得到的总熵就是根据案例落入分区的比例加权的n个分区的熵值的总和)，这样就可以通过条件熵的方式来度量由分割产生的效果，即总熵减少到了多少(因为分割为了多个子集，所以总熵只能通过期望来计算)。这是一种度量方式，但是不够直观，最直观的度量方式就是计算信息增益，如下\r\n![信息增益计算公式](/images/article/information-gain.png)\r\n\r\n由于子集有且只有一个父集(可能会共享同一个父集，但是绝不会同时拥有两个或两个以上的直接父集)，那么也就意味着分割前的熵是相同的，那么分割后的子集的条件熵越小就越说明当前训练集在该选择该特征进行划分后效果最好，因为分割后的总熵(期望熵)越小，即内部越同质越均匀纯度越高。为了便于与其余的特征进行比较，通过计算信息增益，那么也就意味着对同一训练集根据不同特征进行分裂，哪个特征的信息增益越大那么划分的结果越好越同质越均匀越纯。\r\n\r\n到此为止，可以看到，决策树算法是通过**信息增益**来确定合理的或最好的分割点的，信息增益在此程度上意味着一次分割获得的信息多少，信息增益越大，那么得到的信息量越多，那么分割的越成功，分割的次数越少，最终树中的所有路径越短，整棵树越浅。\r\n\r\n简言之：\r\n\r\n**熵越小越说明当前训练集(或子集)内部纯度越高越同质，这是我们的最终目标。刚开始，熵肯定是很大的，我们的目的就是通过根据合适的特征的分裂降低子集的熵值以实现分类预测，而合适的特征的选择是通过信息增益来衡量的。**\r\n\r\n## 四、过度拟合与剪枝\r\n过度拟合的专业定义显得过于繁琐和难懂，不妨使用《Artificial Intelligence: A Modern Approach》一书中关于过度拟合的形象化描述，如下\r\n\r\n\u003e Consider the problem of trying to predict whether the roll of a die will come up as 6 or not Suppose that experiments are carried out with various dice and that the attributes describing each training example include the color of the die, its weight, the time when the roll was done, and whether the experimenters had their fingers crossed. If the dice are fair, the right thing to learn is a tree with a single node that says \"no,\" But the DECISION-TREE-LEARNING algorithm will seize on any pattern it can find in the input. If it turns out that there are 2 rolls of a 7-gram blue die with fingers crossed and they both come out 6, then the algorithm may construct a path that predicts 6 in that case. This problem is called overfitting. \r\n\r\n 对决策树而言，一种被称为**决策树剪枝**的技术可以减轻过度拟合。包括两种，分别是**预剪枝**和**后剪枝**。\r\n \r\n所谓**预剪枝**就是一旦决策树达到了一定数量的决策，或者说决策节点仅含有少量的案例，那么就停止树的生长，因为这样的继续生长是毫无意义的，决策节点只含有少量的案例是不具备一般性意义的。或者说当不存在可用于分裂的好属性时，就停止生长，这种情况就是允许该子集存在一定的不同质以防止过度拟合，因为再此基础上继续生长仍然不具备一般性意义，还是因为案例太少，不具备观测与分析价值。\r\n\r\n预剪枝的好处就是及时停止树的生长，而不是等树生长之后再修剪；简单而直接，适用于解决大规模问题，因为数据量很大的情况下生成被后剪的不必要决策节点是毫无意义的。但是要精确的实现决策树的修剪并不容易，如果修剪的过早那么预测分类不同质的可能性更大，影响决策树的优度；而如果修剪的过晚，又会造成一定程度的过度拟合。\r\n\r\n预剪枝的几种方法如下\r\n\r\n1. 定义一个高度，当决策树达到该高度时就停止决策树的生长，这是最简单的一种办法；\r\n2. 达到某叶节点的案例(或记录)具有相同的特征向量，即使这些案例不属于同一类，那么也可以停止决策树的生长，因为既然当前节点的案例集具备相同的特征向量，那么就有很大的可能性认为其与当前预测类同质，这个度还是要把握好，如果停止的过早仍然会使得叶节点预测类不同质可能性变大；\r\n3. 定义一个阈值，当达到某个节点的案例个数小于该阈值时就可以停止该决策树的生长，原因仍然是少量样本不具备观测与分析价值，对其分析(选择合适的分割点生成决策节点)容易造成过度拟合；\r\n4. 定义一个阈值，通过计算每次扩张对系统性能的增益，并比较增益值与该阈值的大小来决定是否停止决策树的生长。\r\n\r\n所谓**后剪枝**就是先构造完整的决策树，允许树过度拟合训练数据，然后对那些置信度不够的节点子树用叶节点来代替，该叶节点的预测类型为该节点子树中最频繁的类型。几种后剪枝方法如下\r\n\r\n1. Reduced-Error Pruning(REP, 错误率降低剪枝)\r\n2. Pessimistic Error Pruning(PEP, 悲观错误剪枝)\r\n3. Cost-Complexity Pruning(CCP, 代价复杂度剪枝)\r\n\r\n其中REP剪枝的原理与操作如下\r\n\r\n该方法将可用数据集合分为两个样例集合，一个训练集用于训练决策树，一个验证集用来评估修剪这个决策树后得到的预测分类的结果的精度以决定是否修剪相应子树。其操作方法如下\r\n\r\n1. 删除以此节点为根的子树；\r\n2. 使其成为叶子节点；\r\n3. 赋予该叶子节点关联的训练数据的最常见分类，即将原子树最最频繁的类型赋给该叶子节点；\r\n4. 当修建后的树对于验证集合的性能不会比原来的树差时，才真正删除该子树或者用叶节点替换该子树。\r\n\r\n由于使用独立的验证集，与原始决策树相比，修建后的决策树可能偏向于过度修剪。这是因为一些不会在验证集中出现的稀少的但是在训练集中出现的案例会被修剪，但是这并不意味着该案例在其后的测试集中不会在出现。如果训练集较小，不建议使用REP剪枝算法。\r\n\r\n## 五、R语言中C5.0决策树算法\r\nC5.0算法是C4.5的改进版，适用于大多数类型的问题。与其它机器学习模型相比，该算法建立的决策树一般都表现的与它们的模型几乎一模一样，且更容易理解与部署。该算法的优点之一就是它可以自动修剪，其总体策略就是后剪枝，它先生成一个过度拟合的决策树，然后删除对分类误差影响不大的节点和分枝。在某些情况下，整个分枝会被进一步向上移动或者被一些简单的决策所取代，这两个移植分枝的过程被称为子树提升和子树替换。C5.0算法的优点之一就是它很容易调整训练方案以提升决策树性能。\r\n\r\n该算法在C50添加包当中，其函数原型为\r\n\r\n先创建分类器\r\n```\r\nm \u003c- C5.0(train, class, trials = 1, costs = NULL)\r\n```\r\n+ train : 一个包含训练数据的数据框;\r\n+ class : 包含训练数据每一行的分类的一个因子向量;\r\n+ trials: 可选数值，用于控制自助法循环次数(默认为1)，可用于提升模型性能;\r\n+ costs : 可选矩阵，用于给出与各种类型错误相对应的成本，可用于提升模型性能。\r\n\r\n该函数返回一个C5.0模型对象，该对象能够用于预测。\r\n\r\n进行预测\r\n```\r\np \u003c- predict(m, test, type = \"class\")\r\n```\r\n+ m : 由C5.0函数得到的训练模型;\r\n+ test : 一个包含测试数据的数据框，该数据框和用来创建分类器的训练数据有同样的特征;\r\n+ type : 取值为class或者prob, 标识预测是最有可能的类别值或者原始的预测概率;\r\n\r\n该函数返回一个向量，对应test测试集的每一个案例的预测分类结果或概率值(由type决定)。\r\n\r\n## 六、R语言C5.0算法应用示例\r\n以《Machine Learning With R》一书中的根据银行贷款数据来建立模型来预测贷款是否违约为例来说明C5.0算法\r\n```\r\n\u003e getwd()\r\n[1] \"C:/Users/Administrator/Documents\"\r\n\u003e setwd(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\docs\\\\Machine-Learning-with-R-datasets-master\")\r\n\u003e credit \u003c- read.csv(\"credit.csv\")\r\n\u003e str(credit$default)\r\n int [1:1000] 1 2 1 1 2 1 1 1 1 2 ...\r\n\u003e table(credit$default)\r\n\r\n  1   2 \r\n700 300 \r\n\u003e credit$default \u003c- factor(credit$default, levels = c(1, 2), labels = c(\"no\", \"yes\"))\r\n\u003e table(credit$default)\r\n\r\n no yes \r\n700 300 \r\n\u003e set.seed(12345)\r\n\u003e credit_rand \u003c- credit[order(runif(1000)), ]\r\n\u003e credit_train \u003c- credit_rand[1 : 900, ]\r\n\u003e credit_test \u003c- credit_rand[901 : 1000, ]\r\n\u003e prop.table(table(credit_train$default))\r\n\r\n       no       yes \r\n0.7022222 0.2977778 \r\n\u003e prop.table(table(credit_test$default))\r\n\r\n  no  yes \r\n0.68 0.32 \r\n```\r\n上述将数据框credit按照均匀分布的1000个随机数重组，最终为credit_rand，然后分别分割为训练集credit_train和测试集credit_test，通过校验其分布发现基本上与原数据框分布无异。\r\n然后应用C5.0算法创建分类器\r\n```\r\n\u003e library(C50)\r\nWarning message:\r\n程辑包‘C50’是用R版本3.5.3 来建造的 \r\n\u003e credit_model \u003c- C5.0(credit_train[-17], credit_train$default)\r\n```\r\n我们可以通过输出分类器名称来查看关于决策树的一些基本数据\r\n```\r\n\u003e credit_model\r\n\r\nCall:\r\nC5.0.default(x = credit_train[-17], y = credit_train$default)\r\n\r\nClassification Tree\r\nNumber of samples: 900 \r\nNumber of predictors: 20 \r\n\r\nTree size: 57 \r\n\r\nNon-standard options: attempt to group attributes\r\n```\r\n前面的文字反映了关于该决策树的一些基本情况，包括生成决策树的函数调用、特征数(predictors)、用于决策树增长的案例(Samples)。同时列出了树的大小是57，表明该决策树包含57个决策。\r\n如果要查看决策树，可以通过`summary()`函数来实现，部分输出为\r\n```\r\n\u003e summary(credit_model)\r\n\r\nCall:\r\nC5.0.default(x = credit_train[-17], y = credit_train$default)\r\n\r\n\r\nC5.0 [Release 2.07 GPL Edition]  \tSat Mar 23 20:33:44 2019\r\n-------------------------------\r\n\r\nClass specified by attribute `outcome'\r\n\r\nRead 900 cases (21 attributes) from undefined.data\r\n\r\nDecision tree:\r\n\r\nchecking_balance = unknown: no (358/44)\r\nchecking_balance in {\u003c 0 DM,\u003e 200 DM,1 - 200 DM}:\r\n:...foreign_worker = no:\r\n    :...installment_plan in {none,stores}: no (17/1)\r\n    :   installment_plan = bank:\r\n    :   :...residence_history \u003c= 3: yes (2)\r\n    :       residence_history \u003e 3: no (2)\r\n    foreign_worker = yes:\r\n\r\n\r\nEvaluation on training data (900 cases):\r\n\r\n\t    Decision Tree   \r\n\t  ----------------  \r\n\t  Size      Errors  \r\n\r\n\t    57  127(14.1%)   \u003c\u003c\r\n\r\n\r\n\t   (a)   (b)    \u003c-classified as\r\n\t  ----  ----\r\n\t   590    42    (a): class no\r\n\t    85   183    (b): class yes\r\n\r\n\r\n\tAttribute usage:\r\n\r\n\t100.00%\tchecking_balance\r\n\t 60.22%\tforeign_worker\r\n\t 57.89%\tcredit_history\r\n\t 51.11%\tmonths_loan_duration\r\n\t 42.67%\tsavings_balance\r\n\t 30.44%\tother_debtors\r\n\t 17.78%\tjob\r\n\t 15.56%\tinstallment_plan\r\n\t 14.89%\tpurpose\r\n\t 12.89%\temployment_length\r\n\t 10.22%\tamount\r\n\t  6.78%\tresidence_history\r\n\t  5.78%\thousing\r\n\t  3.89%\tdependents\r\n\t  3.56%\tinstallment_rate\r\n\t  3.44%\tpersonal_status\r\n\t  2.78%\tage\r\n\t  1.56%\tproperty\r\n\t  1.33%\texisting_credits\r\n\r\n\r\nTime: 0.0 secs\r\n```\r\n该输出包含一个混淆矩阵，是一个交叉列表，表示模型对训练数据错误分类的记录数。可以看出共有42个原本是no的案例被预测为yes，共有85个原本是yes的案例被预测为no。即该决策树对训练集中127个案例错误的分类了，占比为14.1%\r\n\r\n现在有了分类器，我们可以用于预测，如下\r\n```\r\n\u003e credit_prediction \u003c- predict(credit_model, credit_test)\r\n```\r\n预测的结果向量为\r\n```\r\n\u003e credit_prediction\r\n  [1] no  yes no  no  no  yes no  no  yes yes no  no  no  yes yes yes no  no  yes\r\n [20] no  yes no  yes no  yes no  yes no  no  no  yes yes no  yes no  no  no  no \r\n [39] yes yes no  no  no  yes yes yes yes no  yes no  no  no  yes no  no  no  no \r\n [58] yes no  no  no  yes no  yes no  no  yes no  no  no  no  no  no  yes yes no \r\n [77] no  yes no  no  no  no  no  no  no  no  no  no  yes yes yes no  no  no  no \r\n [96] yes no  yes no  no \r\nLevels: no yes\r\n```\r\n可以通过如下方法查看测试集的预测成功程度，以评估模型性能\r\n```\r\n\u003e table(credit_prediction == credit_test$default)\r\n\r\nFALSE  TRUE \r\n   25    75 \r\n\r\n\u003e prop.table(table(credit_prediction == credit_test$default))\r\n\r\nFALSE  TRUE \r\n 0.25  0.75 \r\n```\r\n可见，正确率为75%。\r\n\r\n如何提高模型性能呢？\r\n\r\n## 七、提高C5.0算法的分类器性能\r\n之前在创建分类器的时候有两个参数没有使用，分别是trials和costs参数。\r\n\r\n对C5.0算法性能的提升可以通过**自适应增强(adaptive boosting)算法**，具体做法是在决策树的构建过程中，这些决策树通过投票表决的方法为每个案例选择最佳的分类。C5.0算法通过trials参数来引入该算法(boosting算法), 该参数的值表示在模型增强团队中使用到的独立决策树的数量，参数trials设置了一个上限，如果该算法识别出额外的实验似乎并没有提高模型的准确性，那么它将停止添加决策树。一般设置为10\r\n```\r\n\u003e credit_model \u003c- C5.0(credit_train[-17], credit_train$default, trials = 10)\r\n\u003e credit_prediction \u003c- predict(credit_model, credit_test)\r\n\u003e prop.table(table(credit_prediction == credit_test$default))\r\n\r\nFALSE  TRUE \r\n 0.21  0.79 \r\n```\r\n可以看到明显提升了模型精度。\r\n\r\n还有一个办法是通过costs参数，该参数是一个代价矩阵，用于指定每种错误相对于其它任何错误有多少倍的严重性。假如评估模型精度的双向交叉表为\r\n```\r\n\u003e library(gmodels)\r\nWarning message:\r\n程辑包‘gmodels’是用R版本3.5.3 来建造的 \r\n\u003e CrossTable(credit_test$default, credit_prediction, prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE, dnn = c(\"actual default\", \"predicted default\"))\r\n\r\n \r\n   Cell Contents\r\n|-------------------------|\r\n|                       N |\r\n|         N / Table Total |\r\n|-------------------------|\r\n\r\n \r\nTotal Observations in Table:  100 \r\n\r\n \r\n               | predicted default \r\nactual default |        no |       yes | Row Total | \r\n---------------|-----------|-----------|-----------|\r\n            no |        63 |         5 |        68 | \r\n               |     0.630 |     0.050 |           | \r\n---------------|-----------|-----------|-----------|\r\n           yes |        16 |        16 |        32 | \r\n               |     0.160 |     0.160 |           | \r\n---------------|-----------|-----------|-----------|\r\n  Column Total |        79 |        21 |       100 | \r\n---------------|-----------|-----------|-----------|\r\n\r\n```\r\n那么我们定义如下代价矩阵\r\n```\r\n\u003e error_cost \u003c- matrix(c(0, 4, 1, 0), nrow = 2)\r\n\u003e error_cost\r\n     [,1] [,2]\r\n[1,]    0    1\r\n[2,]    4    0\r\n```\r\n该代价矩阵用来说明双向交叉表中落入对应[2, 1]的元素的错误更加严重，那么分类器就会极力避免这种情况发生，再创建一个分类器试试\r\n```\r\n\u003e credit_model \u003c- C5.0(credit_train[-17], credit_train$default, costs = error_cost)\r\nWarning message:\r\nno dimnames were given for the cost matrix; the factor levels will be used \r\n\u003e credit_prediction \u003c- predict(credit_model, credit_test)\r\n\u003e prop.table(table(credit_prediction == credit_test$default))\r\n\r\nFALSE  TRUE \r\n 0.32  0.68 \r\n\u003e CrossTable(credit_test$default, credit_prediction, prop.chisq = FALSE, prop.c = FALSE, prop.r = FALSE, dnn = c(\"actual default\", \"predicted default\"))\r\n\r\n \r\n   Cell Contents\r\n|-------------------------|\r\n|                       N |\r\n|         N / Table Total |\r\n|-------------------------|\r\n\r\n \r\nTotal Observations in Table:  100 \r\n\r\n \r\n                    | credit_prediction \r\ncredit_test$default |        no | Row Total | \r\n--------------------|-----------|-----------|\r\n                 no |        68 |        68 | \r\n                    |     0.680 |           | \r\n--------------------|-----------|-----------|\r\n                yes |        32 |        32 | \r\n                    |     0.320 |           | \r\n--------------------|-----------|-----------|\r\n       Column Total |       100 |       100 | \r\n--------------------|-----------|-----------|\r\n```\r\n可见，与之前的模型相比，该模型的精度更低。但是这不失为一种调整模型性能的方法，需要根据实际情况来调整。","cover":"/images/decision-tree.jpg","link":"decision-tree-learning.html","preview":"\u003cp\u003e决策树学习算法以树形结构建立模型，类似于流程图，该模型本身包含一系列逻辑决策。\u003c/p\u003e\n","title":"分而治之——决策树学习算法"},{"content":"\r\n\r\n现在有一幅地图，如下\r\n\r\n![](/images/article/map-color.png)\r\n\r\n需要进行着色，为了区分A, B, C, D, E五个区域，要求相邻区域颜色不一样，并且颜色只有红绿蓝三种，那么要怎样定义事实描述和规则约束呢？\r\n\r\n我们先定义事实描述，就是用到的三种颜色,同样是使用常量进行具体的定义\r\n```\r\ncolor(red).\r\ncolor(green).\r\ncolor(blue).\r\n```\r\n满足结论的约束规则是红绿蓝三种颜色且相邻区域颜色不一样。同样是使用大写变量进行笼统的定义\r\n\r\n我们先定义结论和红绿蓝的关系，如下\r\n```\r\ncolorify(A, B, C, D, E) :-\r\n    color(A), color(B), color(C), color(D), color(E).\r\n```\r\n以上代码的含义是A、B、C、D、E分别代表各区域的颜色(即代表了区域也代表了颜色)，取值是red、blue、green的其中一种，分别代表5个区域的地图颜色。\r\n\r\n以上代码只是解决了地图有颜色的问题，但是并没有解决颜色对不对的问题。我们接下来要解决这个问题。\r\n\r\n通过观察地图我们发现\r\n\r\n\t- 区域A与区域B、C、D、E相接壤，那么也就是说A的颜色与B、C、D、E的颜色不一样，即\\+ A = B, \\+ A = C, \\+ A = D, \\+ A = E,\r\n\t- 区域B和C相接壤，也就是B和C的颜色不一样，即\\+B = C,\r\n\t- 区域C和D相接壤，也就是C和D的颜色不一样，即\\+C = D,\r\n\t- 区域D和E相接壤，也就是D和E的颜色不一样，即\\+E = E.\r\n\r\n那么现在综合以上规则，如下\r\n```\r\ncolorify(A,B,C,D,E) :-\r\n    color(A), color(B), color(C), color(D), color(E),\r\n    \\+ A = B, \\+ A = C, \\+ A = D, \\+ A = E,\r\n    \\+ B = C, \\+ C = D, \\+ D = E.\r\n```\r\n再综合事实描述，代码为\r\n```\r\ncolor(red).\r\ncolor(green).\r\ncolor(blue).\r\n\r\ncolorify(A,B,C,D,E) :-\r\n    color(A), color(B), color(C), color(D), color(E),\r\n    \\+ A = B, \\+ A = C, \\+ A = D, \\+ A = E,\r\n    \\+ B = C, \\+ C = D, \\+ D = E.\r\n```\r\nshell运行，不断追问，有如下输出\r\n```\r\nWelcome to SWI-Prolog (threaded, 64 bits, version 8.0.1)\r\nSWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.\r\nPlease run ?- license. for legal details.\r\n\r\nFor online help and background, visit http://www.swi-prolog.org\r\nFor built-in help, use ?- help(Topic). or ?- apropos(Word).\r\n\r\n?- colorify(A, B, C, D, E).\r\nA = red,\r\nB = D, D = green,\r\nC = E, E = blue ;\r\nA = red,\r\nB = D, D = blue,\r\nC = E, E = green ;\r\nA = green,\r\nB = D, D = red,\r\nC = E, E = blue ;\r\nA = green,\r\nB = D, D = blue,\r\nC = E, E = red ;\r\nA = blue,\r\nB = D, D = red,\r\nC = E, E = green ;\r\nA = blue,\r\nB = D, D = green,\r\nC = E, E = red ;\r\nfalse.\r\n\r\n?- \r\n```\r\n可见Prolog共给出了6种结论。\r\n\r\n其实，不难发现，结论也是一种事实，结论这种事实是原有事实在规则约束下得到的。这个过程就是推论","cover":"/images/article/map-color.png","link":"map-coloring.html","preview":"\u003cp\u003e现在有一幅地图，需要进行着色，为了区分A, B, C, D, E五个区域，要求相邻区域颜色不一样，并且颜色只有红绿蓝三种，那么要怎样定义事实描述和规则约束呢？\u003c/p\u003e\n","title":"地图着色问题"},{"content":"\r\n\r\n我们先看一组父子关系\r\n\r\n```\r\nfather(zeb, john_boy_sr).\r\nfather(john_boy_sr, john_boy_jr).\r\n```\r\n\r\n以上代码描述，zeb是john_boy_sr的父亲，而john_boy_sr又是john_boy_jr的父亲，我们可以直观的发现上述关系存在三组祖先关系，如下\r\n\r\n+ zeb是john_boy_sr的祖先\r\n+ john_boy_sr是john_boy_jr的祖先\r\n+ zeb是john_boy_jr的祖先\r\n\r\n如果我们用Prolog来推理这三组祖先关系会怎么样呢？我们先写第一个推理规则，使得以上事实在该规则约束下得到祖先关系的结论，如下\r\n\r\n```\r\nancestor(X, Y) :-\r\n    father(X, Y).\r\n```\r\n\r\n推理结果为\r\n\r\n```\r\n?- ancestor(Who1, Who2).\r\nWho1 = zeb,\r\nWho2 = john_boy_sr ;\r\nWho1 = john_boy_sr,\r\nWho2 = john_boy_jr.\r\n```\r\n\r\n可见只推理出了两组直观的祖先关系，就是我们的原有事实，但是并未推理出两组事实的传递关系。纳闷我们再改一下规则约束，让祖先关系可以传递，如下\r\n\r\n```\r\nancestor(X, Y) :-\r\n    father(X, Z), father(Z, Y).\r\n```\r\n\r\n以上规则表明如果X是Z的祖先，Z是Y的祖先，那么X就是Y的祖先(就是推理结论)，推理结果如下\r\n\r\n```\r\n?- ancestor(Who1, Who2).\r\nWho1 = zeb,\r\nWho2 = john_boy_jr ;\r\nfalse.\r\n```\r\n\r\n这次传递关系出来了，但是第一次的最直观的两组祖先关系又不见了。\r\n\r\n现在可以得出，我们最终的结果应该是第一条规则和第二条规则的并集，那么我们只需要这样写规则即可\r\n\r\n```\r\nancestor(X, Y) :-\r\n    father(X, Y).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Z), father(Z, Y).\r\n```\r\n\r\n推理结果为\r\n\r\n```\r\n?- ancestor(Who1, Who2).\r\nWho1 = zeb,\r\nWho2 = john_boy_sr ;\r\nWho1 = john_boy_sr,\r\nWho2 = john_boy_jr ;\r\nWho1 = zeb,\r\nWho2 = john_boy_jr ;\r\nfalse.\r\n```\r\n\r\n这次推理结果全部出来了。可喜可贺。但是如果我们再增加一层传递关系呢(直接的关系肯定可以得出结论，因为本身就满足father关系)？我们的规则还能原封不动的推理出所有的结论吗？不妨试试,代码如下\r\n\r\n```\r\nfather(zeb, john_boy_sr).\r\nfather(john_boy_sr, john_boy_jr).\r\nfather(john_boy_jr, john_boy_br).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Y).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Z), father(Z, Y).\r\n```\r\n\r\n推理结果为\r\n\r\n```\r\n?- ancestor(Who1, Who2).\r\nWho1 = zeb,\r\nWho2 = john_boy_sr ;\r\nWho1 = john_boy_sr,\r\nWho2 = john_boy_jr ;\r\nWho1 = john_boy_jr,\r\nWho2 = john_boy_br ;\r\nWho1 = zeb,\r\nWho2 = john_boy_jr ;\r\nWho1 = john_boy_sr,\r\nWho2 = john_boy_br ;\r\nfalse.\r\n```\r\n\r\n可以看出，这种传递关系我们的推理不完备的，还缺一个结论，即\r\n\r\n```\r\nWho1 = zeb,\r\nWho2 = john_boy_br ;\r\n```\r\n\r\n这是因为我们的规则并没有体现出这样的关系，想要体现这样的关系，那么我们还需要并集一下另一个规则，如下\r\n\r\n\r\n```\r\nfather(zeb, john_boy_sr).\r\nfather(john_boy_sr, john_boy_jr).\r\nfather(john_boy_jr, john_boy_br).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Y).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Z), father(Z, Y).\r\n\t\r\nancestor(X, Y) :-\r\n    father(X, Z), father(Z, B), father(B, Y).\r\n```\r\n\r\n这样，我们的推论就是完全的，为\r\n\r\n```\r\n?- ancestor(Who1, Who2).\r\nWho1 = zeb,\r\nWho2 = john_boy_sr ;\r\nWho1 = john_boy_sr,\r\nWho2 = john_boy_jr ;\r\nWho1 = john_boy_jr,\r\nWho2 = john_boy_br ;\r\nWho1 = zeb,\r\nWho2 = john_boy_jr ;\r\nWho1 = john_boy_sr,\r\nWho2 = john_boy_br ;\r\nWho1 = zeb,\r\nWho2 = john_boy_br ;\r\nfalse.\r\n```\r\n\r\n上述示例是一种直接的传递关系,即首尾相连，我们得出的结论是关系的增加也就意味着我们的规则也要做出相应的改变，不然推论就是不完全的。\r\n\r\n其实还有另一种传递关系，即部分首尾不相连，关系如下\r\n\r\n```\r\nfather(zeb, john_boy_sr).\r\nfather(john_boy_sr, john_boy_jr).\r\nfather(zeb, john_boy_br).\r\nfather(john_boy_br, john_boy_sr).\r\n```\r\n\r\n相应的代码如下\r\n\r\n```\r\nfather(zeb, john_boy_sr).\r\nfather(john_boy_sr, john_boy_jr).\r\nfather(zeb, john_boy_br).\r\nfather(john_boy_br, john_boy_sr).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Y).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Z), father(Z, Y).\r\n```\r\n\r\n推理结果为\r\n\r\n```\r\n?- ancestor(Who1, Who2).\r\nWho1 = zeb,\r\nWho2 = john_boy_sr ;\r\nWho1 = john_boy_sr,\r\nWho2 = john_boy_jr ;\r\nWho1 = zeb,\r\nWho2 = john_boy_br ;\r\nWho1 = john_boy_br,\r\nWho2 = john_boy_sr ;\r\nWho1 = zeb,\r\nWho2 = john_boy_jr ;\r\nWho1 = zeb,\r\nWho2 = john_boy_sr ;\r\nWho1 = john_boy_br,\r\nWho2 = john_boy_jr.\r\n```\r\n\r\n我们的推理结果没毛病。因为我们我们的规则已经囊括了所有的可能性。如果我们越增加关系的复杂程度，那么我们现在的程序就不是健壮的，就无法推理出所有的结论。\r\n\r\n我们必须找到一个合适的办法才行，保证我们不管怎样增加关系，我们的规则约束同样适用。实际上，递归是很好的解决办法。我们再回顾一下我们的代码，如下\r\n\r\n```\r\nfather(zeb, john_boy_sr).\r\nfather(john_boy_sr, john_boy_jr).\r\nfather(zeb, john_boy_br).\r\nfather(john_boy_br, john_boy_sr).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Y).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Z), father(Z, Y).\r\n```\r\n\r\n在第二个ancestor中，我们用且关系链接了两个father，如果我们把第二个father用ancestor()替换，那么就是一个递归的例子，因为father(X, Y)的推论是ancestor(X, Y)。而我们最终的推论也是推ancestor（X, Y）,所以两个ancestor的方向是一致的，代码如下\r\n\r\n```\r\nfather(zeb, john_boy_sr).\r\nfather(john_boy_sr, john_boy_jr).\r\nfather(zeb, john_boy_br).\r\nfather(john_boy_br, john_boy_sr).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Y).\r\n\r\nancestor(X, Y) :-\r\n    father(X, Z), ancestor(Z, Y).\r\n```\r\n\r\n推理结果为\r\n\r\n```\r\n?- ancestor(Who1, Who2).\r\nWho1 = zeb,\r\nWho2 = john_boy_sr ;\r\nWho1 = john_boy_sr,\r\nWho2 = john_boy_jr ;\r\nWho1 = zeb,\r\nWho2 = john_boy_br ;\r\nWho1 = john_boy_br,\r\nWho2 = john_boy_sr ;\r\nWho1 = zeb,\r\nWho2 = john_boy_jr ;\r\nWho1 = zeb,\r\nWho2 = john_boy_sr ;\r\nWho1 = zeb,\r\nWho2 = john_boy_jr ;\r\nWho1 = john_boy_br,\r\nWho2 = john_boy_jr ;\r\nfalse.\r\n```\r\n\r\n其实有一组结果推理了两次，但是结果是完备的。\r\n\r\n那么能不能将第二个ancestor的第一个father()改成ancestor或者将两个father全部改了呢？不可以。改了之后推理过程中会栈溢出\r\n\r\n```\r\n?- ancestor(Who1, Who2).\r\nWho1 = zeb,\r\nWho2 = john_boy_sr ;\r\nWho1 = john_boy_sr,\r\nWho2 = john_boy_jr ;\r\nWho1 = zeb,\r\nWho2 = john_boy_br ;\r\nWho1 = john_boy_br,\r\nWho2 = john_boy_sr ;\r\nWho1 = zeb,\r\nWho2 = john_boy_jr ;\r\n;ERROR: Stack limit (1.0Gb) exceeded\r\nERROR:   Stack sizes: local: 1.0Gb, global: 15Kb, trail: 2Kb\r\nERROR:   Stack depth: 12,200,666, last-call: 0%, Choice points: 6\r\nERROR:   Probable infinite recursion (cycle):\r\nERROR:     [12,200,666] user:ancestor(john_boy_jr, _3912)\r\nERROR:     [12,200,665] user:ancestor(john_boy_jr, _3932)\r\n```\r\n\r\n因为每个递归的子目标都会使用栈空间，最终就有可能耗尽栈空间。但是为什么递归语句放到最后不存在问题呢？\r\n\r\n声明式编程语言通常是用一种称为“尾递归优化”的技术来解决递归调用引起栈溢出的问题。也就是说如果你将一个递归的子目标放到递归规则的末尾，Prolog会通过丢弃调用栈来优化这次调用，并保持内存占用不变。所以我们的ancestor(Z, Y)递归子目标是放在递归规则的末尾的。","cover":"/images/swipl.png","link":"introducing-prolog-recursion-from-ancestor-relations.html","preview":"\u003cp\u003e声明式编程语言通常是用一种称为“尾递归优化”的技术来解决递归调用引起栈溢出的问题。也就是说如果你将一个递归的子目标放到递归规则的末尾，Prolog会通过丢弃调用栈来优化这次调用，并保持内存占用不变。所以我们的ancestor(Z, Y)递归子目标是放在递归规则的末尾的。\u003c/p\u003e\n","title":"由祖先关系引入Prolog递归"},{"content":"\r\n\r\n前面的文章只是对Prolog一些直观上的简单应用，有必要深入了解一下这门语言的运行机制。\r\n\r\n我们从以前的例子说起,对其进行简单改造\r\n\r\n```\r\nlove(zhangsan, lisi).\r\nlove(zhangsan,wangwu).\r\nmale(zhangsan).\r\nmale(wangwu).\r\nfemale(lisi).\r\nstillLove(B, A) :- love(A,B), male(A), female(B).\r\n```\r\n\r\n将其保存为love1.pl,执行这段代码，我们可以得到下面的结论\r\n\r\n```\r\n?- stillLove(Who1, Who2).\r\nWho1 = lisi,\r\nWho2 = zhangsan ;\r\nfalse.\r\n```\r\n\r\n那么Prolog到底是怎么运行的呢？\r\n\r\n我们前面说过，结论stillLove(B, A)也可以看做事实，特殊之处在于该事实是由原先的事实推论出来的，也就是说应该从:-符号的右边开始读，然后得到左边的事实结论。\r\n\r\nstillLove(Who1, Who2)相当于提问谁和谁满足这样的事实。那么既然结论事实是由符号:-右边的推论得出的，该stillLove(Who1, Who2)表达式就会`传递`到love(A,B), male(A), female(B)上面进行提问。具体操作过程如下\r\n\r\n+ love(A, B)就回去匹配原先的事实，看`谁和谁符合love关系`，那么就会得到如下结论：\r\n\t- A = zhangsan;\r\n\t- B = {lisi, wangwu};\r\n+ male(A)也会去匹配原先的事实，看`谁的属性是male`，那么会得到如下结论：\r\n\t- A = {zhangsan, wangwu}；\r\n+ female(B)也会去匹配原先的事实，看`谁的属性是female`，那么会得到如下结论：\r\n\t- B = lisi\r\n\r\n好了，到此为止符号:-右边的变量A,B所代表的常量已经找到了，那么接下来只需要综合一下就好了，即关系和相对应的属性取交集，如下\r\n\r\n+ 关系love中的A的值与属性male中的A的值的交集是zhangsan，那么现在就找到了A是zhangsan;\r\n+ 关系love中的B的值与属性female中的B的值的交集是lisi，那么现在也找到了B是lisi。\r\n\r\n现在综合上述结论，即A = zhangsan, B = lisi，这就是符号:-右边的规则约束原有事实得出的结论，由于stillLove(Who1, Who2)是将查询传递到符号:-右边的规则约束上的，那么自然该结论也就是stillLove(Who1, Who2)的结论。\r\n\r\n需要注意的是，这里还会有一个参数对应关系，即源程序中stillLove表达式中B对应的是shell中的Who1，A对应的是Who2，那么现在得出的最终结论就是\r\n\r\n+ Who1 = lisi,\r\n+ Who2 = zhangsan;","cover":"/images/swipl.png","link":"deeply-understanding-the-operating-mechanism-of-prolog.html","preview":"\u003cp\u003e前面的文章只是对Prolog一些直观上的简单应用，有必要深入了解一下这门语言的运行机制。\u003c/p\u003e\n","title":"深入理解Prolog的运行机制"},{"content":"\r\n\r\n## 一、写在前面\r\n\r\n今天闲来无事，就上网搜了搜有哪些小众冷门但却实用的编程语言，毫无疑问，Prolog脱颖而出。平时总是在写结构化的逻辑代码，似乎只要知道顺序、选择、循环三种结构，再加上常用的算法和数据结构就能解决绝大多数问题，不免觉得无趣。所以对这门以逻辑标榜的编程语言甚是钟情。\r\n\r\n国内网上关于Prolog的资料和文档寥寥无几，在[阮一峰老师的博客](http://www.ruanyifeng.com/blog/2019/01/prolog.html?hmsr=toutiao.io\u0026utm_medium=toutiao.io\u0026utm_source=toutiao.io)中倒是发现一篇文章足以入门Prolog，甚是开心，本文结合阮一峰老师的文章和原文出处[Solving murder with Prolog](https://xmonader.github.io/prolog/2018/12/21/solving-murder-prolog.html)，再加上本人实践，综合而成，感谢两位的无私奉献。\r\n\r\n## 二、Prolog运行环境SWI-Prolog的安装\r\n\r\n在官网下载相应操作系统的二进制安装包，然后安装，一定要将安装路径加入环境变量，一般在安装的时候会提示，勾选即可。\r\n\r\n在命令行键入`swipl`命令即可进入Prolog的shell\r\n\r\n```\r\nC:\\Users\\Administrator\u003eswipl\r\nWelcome to SWI-Prolog (threaded, 64 bits, version 8.0.1)\r\nSWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.\r\nPlease run ?- license. for legal details.\r\n\r\nFor online help and background, visit http://www.swi-prolog.org\r\nFor built-in help, use ?- help(Topic). or ?- apropos(Word).\r\n\r\n1 ?- \r\n```\r\n\r\n这就进入了Prolog的运行环境，键入以下命令退出shell(别忘了最后的.)\r\n\r\n```\r\nhalt.\r\n```\r\n\r\nProlog运行环境和源文件下每条语句是以`.`符号结束的，相当于Java中`;`符号的作用。\r\n\r\nProlog标准输出函数为`write()`. hello, world输出如下\r\n\r\n```\r\n1 ?- write('hello, world').\r\nhello, world\r\ntrue.\r\n```\r\n\r\n其中`true.`为返回结果，代表加载成功！\r\n\r\n## 三、基本语法\r\n\r\n### 3.1 常量和变量\r\n\r\n常量是以小写字母开头，变量则是以大写字母开头，示例如下\r\n\r\n```\r\n3 ?- write(name).\r\nname\r\ntrue.\r\n\r\n4 ?- write(Name).\r\n_4042\r\ntrue.\r\n```\r\n\r\nname是常量，那么会直接输出自身，Name是变量，那么输出的就是该变量的值。\r\n\r\n### 3.2 关系和属性\r\n\r\n关系肯定是两个事物时间的关系，方向从左到右，如下\r\n\r\n```\r\nfriend(jack, peter).\r\n```\r\n\r\n意为jack的朋友是peter，即jack与peter是朋友关系，由于方向是从左到右，那么peter的朋友不一定是jack，如果我们想表达jack与peter互为朋友，那么如下表示\r\n\r\n```\r\nfriend(jack, peter).\r\nfriend(peter, jack).\r\n```\r\n\r\n属性是一个事物所具有的，比如jack是男的，男的就是peter的一个属性，如下表示\r\n\r\n```\r\nmale(jack)\r\n```\r\n\r\n简言之，括号里面有两个参数，那么指的就是关系，有一个参数，那么指的就是属性。\r\n\r\n### 3.3 规则以及建立在属性、关系和规则上面程序的提问\r\n\r\n规则是推理的依据，即如何从一个论断得到另一个论断。\r\n\r\n我们定义一条规则：**所有的曾经的喜欢关系是相互的，即一方曾经喜欢过另一方，那么另一方也曾经喜欢过一方，即一方曾经也被另一方喜欢过**\r\n\r\n首先我们需要定义关系，其次再利用规则，我们暂时认为关系的定义必须是具体的，即只能用小写的常量，而规则的定义必须是笼统的，即规则用大写的变量\r\n\r\n```\r\nlove(zhangsan, lisi).\r\nstillLove(B, A) :- love(A,B).\r\n```\r\n\r\n将上述代码保存在一个名为love.pl的文件中，然后用swipl-win.exe打开，显示如下\r\n\r\n```\r\nWelcome to SWI-Prolog (threaded, 64 bits, version 8.0.1)\r\nSWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software.\r\nPlease run ?- license. for legal details.\r\n\r\nFor online help and background, visit http://www.swi-prolog.org\r\nFor built-in help, use ?- help(Topic). or ?- apropos(Word).\r\n\r\n?-\r\n```\r\n\r\n然后我们可以根据规则来进行提问。\r\n\r\n我们在源文件中描述了具体的人物关系是张三爱过李四，我们想根据规则得出推论：如果A爱过B，那么B仍然爱过A。有三种提问方式，如下\r\n\r\n第一种，我们直接使用双变量进行查询，含义为谁曾经还喜欢过谁，如下\r\n\r\n```\r\n?- stillLove(Who1, Who2).\r\nWho1 = lisi,\r\nWho2 = zhangsan.\r\n```\r\n\r\n我们设置了两个变量Who1和Who2，进行提问，结果显示Who1 = lisi, Who2 = zhangsan。这表示如果从zhangsan和lisi的关系出发，根据我们定义的规则，可以得出lisi曾经爱过zhangsan。\r\n\r\n第二种，左单变量进行查询，含义为lisi曾经还喜欢过谁，如下\r\n\r\n```\r\n?- stillLove(lisi, Who).\r\nWho = zhangsan.\r\n```\r\n\r\n仍然可以得出张三曾经喜欢过李四\r\n\r\n第三种，右单变量查询，含义为zhangsan曾经被谁喜欢过，如下\r\n\r\n```\r\n?- stillLove(Who, zhangsan).\r\nWho = lisi.\r\n```\r\n\r\n仍然可以得出张三曾经喜欢过李四\r\n\r\n我们再定义一个规则：**所有的曾经的喜欢关系是相互的，即一方曾经喜欢过另一方，那么另一方也曾经喜欢过一方，即一方曾经也被另一方喜欢过，且双方必须是异性**\r\n\r\n那么我们需要修改一下源程序,如下\r\n\r\n```\r\nlove(zhangsan, lisi).\r\nmale(zhangsan).\r\nfemale(lisi).\r\nstillLove(B, A) :- love(A,B), male(A), female(B).\r\n```\r\n\r\n我们通过定义属性的形式具体的指出了zhangsan是男性，lisi是女性；并且通过笼统的在规则中增加定义A是男性，B是女性，来达到我们的目的。可以看出表示\"且\"这一概念的符号是英文逗号。同样的三种提问方式，得到的结果和上面一致。如果我们如下提问\r\n\r\n同样的三种提问方式，得到的结果和上面一致。如果我们如下提问\r\n\r\n```\r\n?- stillLove(Who1, lisi).\r\nfalse.\r\n```\r\n\r\n那么得出的结果是false，即zhangsan从未喜欢过lisi。很扎心吧，因为我们定义的A是男性，但是我们给的A是女性lisi，那么势必会推理出false.\r\n\r\n**规则中还有一个符号是` \\+ `,表示\"不是\"的意思**，我们再次改造一下上面的程序，如下\r\n\r\n```\r\nlove(zhangsan, lisi).\r\nlove(zhangsan,wangwu).\r\nmale(zhangsan).\r\nmale(wangwu).\r\nfemale(lisi).\r\nstillLove(B, A) :- love(A,B), \\+female(B).\r\n```\r\n\r\n在上述程序中我们假定男性张三爱过女性李四、男性张三爱过男性王五，如果根据我们上述第一个规则那么我们可以得出女性李四也喜欢过男性张三、男性王五也喜欢过男性张三；如果根据第二条规则，那么我们得出的结论是只有女性李四喜欢过张三，王五被排除在外了，为什么？因为我们的且条件是B是女性，但是王五是男性。王五很无辜，如果我们想把王五纳入把李四排除，那么我们需要修改一下条件，就是第三个规则(添加了` \\+ `符号的规则)，即让B不为女性，即男性。演示为\r\n\r\n```\r\n?- stillLove(Who1, Who2).\r\nWho1 = wangwu,\r\nWho2 = zhangsan.\r\n```\r\n### 四、总结\r\n\r\n**总体而言，Prolog的编程逻辑为：通过关系和属性进行事实描述 -\u003e 添加推论的规则约束 -\u003e shell提问得出结论**\r\n\r\n而shell中可以使用单变量/双变量进行查询追问。","cover":"/images/swipl.png","link":"introduction-to-prolog-language.html","preview":"\u003cp\u003e今天闲来无事，就上网搜了搜有哪些小众冷门但却实用的编程语言，毫无疑问，Prolog脱颖而出。平时总是在写结构化的逻辑代码，似乎只要知道顺序、选择、循环三种结构，再加上常用的算法和数据结构就能解决绝大多数问题，不免觉得无趣。所以对这门以逻辑标榜的编程语言甚是钟情。\u003c/p\u003e\n","title":"Prolog 语言入门"},{"content":"\r\n\r\nCPU比RAM的速度快得多，通常差距达上千倍，在极端情况下有上万倍的差距，那么为了协调RAM与CPU之间的速度矛盾提高CPU资源利用率，一般在CPU与RAM之间增设Cache，CPU访Cache的速度远高于访RAM的速度。\r\n\r\n这实际上基于程序的局部性原理，在程序运行时，将运算所需要的数据从主内存中复制一份到CPU Cache中，这样CPU是直接对Cache进行数据的读出与写入的，当运算结束后，再将Cache中的数据刷回内存中。那么这样就会出现CPU缓存一致性问题。\r\n\r\n## 一、CPU缓存一致性问题\r\n\r\nCPU缓存一致性问题在单线程下是不存在的，因为对数据的操作始终是一个线程，但是在多线程高并发环境下就会出现线程不安全问题。因为每个线程都会有自己的工作内存，每次对内存中的数据操作时是把内存中的数据复制到自己工作内存中而不是直接对内存操作，以i++为例：\r\n\r\n1. 假设存在记录访问数量的字段i的初始值为0；\r\n2. 假定存在两个线程，分别对同一个i进行操作；\r\n3. 由于对i的操作分为以下几步：\r\n  1. 读取主内存的i到CPU Cache中；\r\n  2. 对i进行+1操作；\r\n  3. 将结果写回CPU Cache中；\r\n  4. 最终将结果刷回RAM中。\r\n4. 如果一个线程读取了i的值到自己的工作内存中还没来得及加1也就还没来得及刷回主内存，那么恰好丧失了对CPU的控制被调度到就绪队列，那么另一个线程获得对CPU的控制权再次读取i到自己的工作内存；\r\n5. 那么两个线程分别加1都刷回主内存，最终结果仍然是1，但是我们的预期结果是2\r\n\r\n这样就会造成线程不安全问题。究其缘由，造成线程不安全问题的原因是一线程对共享数据的修改对另一线程不可见。\r\n\r\n举个例子，如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class VolatileFoo {\r\n    final static int MAX = 5;\r\n    static int init_value = 0;\r\n    public static void main(String[] args) {\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                int localValue = init_value;\r\n                while (localValue \u003c MAX) {\r\n                    if (init_value != localValue) {\r\n                        System.out.printf(\"The init_value is update to [%d]\\n\", init_value);\r\n                        localValue = init_value;\r\n                    }\r\n                }\r\n            }\r\n            \r\n        },\"Reader\").start();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                int localValue = init_value;\r\n                while (localValue \u003c MAX) {\r\n                    System.out.printf(\"The init_value will be changed to [%d]\\n\" , ++localValue);\r\n                    init_value = localValue;\r\n                    try {\r\n                        TimeUnit.MICROSECONDS.sleep(2);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n            \r\n        },\"Updater\").start();\r\n    }\r\n\r\n}\r\n```\r\n\r\nUpdater线程对init_value进行修改，Reader线程检测这种修改，一旦修改，那么就打印出来，结果呢？如下\r\n\r\n```\r\nThe init_value will be changed to [1]\r\nThe init_value will be changed to [2]\r\nThe init_value will be changed to [3]\r\nThe init_value will be changed to [4]\r\nThe init_value will be changed to [5]\r\n```\r\n\r\n可以看到，修改不断进行，但是Reader线程并没有检测到这种修改，这就是init_value的修改对Reader不可见，什么原因呢？\r\n\r\nUpdater线程缓存init_value为0进入自己的工作内存，Reader也缓存init_value为0进入自己的工作内存，由于线程的工作内存都是独立的，那么Reader线程自然无法感知Updater线程对init_value的变动。\r\n\r\n## 二、volatile关键字\r\n\r\n如果我们给共享的变量加上volatile关键字，那么就能保证多线程间共享变量修改的可见性，如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class VolatileFoo {\r\n    final static int MAX = 5;\r\n    static volatile int init_value = 0;\r\n    public static void main(String[] args) {\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                int localValue = init_value;\r\n                while (localValue \u003c MAX) {\r\n                    if (init_value != localValue) {\r\n                        System.out.printf(\"The init_value is update to [%d]\\n\", init_value);\r\n                        localValue = init_value;\r\n                    }\r\n                }\r\n            }\r\n            \r\n        },\"Reader\").start();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                int localValue = init_value;\r\n                while (localValue \u003c MAX) {\r\n                    System.out.printf(\"The init_value will be changed to [%d]\\n\" , ++localValue);\r\n                    init_value = localValue;\r\n                    try {\r\n                        TimeUnit.MICROSECONDS.sleep(2);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n            \r\n        },\"Updater\").start();\r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nThe init_value will be changed to [1]\r\nThe init_value is update to [1]\r\nThe init_value will be changed to [2]\r\nThe init_value is update to [2]\r\nThe init_value will be changed to [3]\r\nThe init_value is update to [3]\r\nThe init_value will be changed to [4]\r\nThe init_value is update to [4]\r\nThe init_value will be changed to [5]\r\nThe init_value is update to [5]\r\n```\r\n\r\nvolatile是怎样保证可见性的呢？这要了解一下Java内存模型\r\n\r\n## 三、Java内存模型\r\n\r\nJava内存模型(JMM)规定了Java虚拟机(JVM)如果与计算机的主存(RAM)进行工作,其决定了一个线程对共享变量的写入何时对其它线程可见，JMM定义的JVM与RAM之间的抽象关系，具体如下\r\n\r\n1. 共享变量存储于主内存之中，每个线程都可以访问；\r\n2. 每个线程都有私有的工作内存或者称为本地内存；\r\n3. 工作内存只存储该线程对共享变量的副本；\r\n4. 线程不能直接操作主内存，只有先操作了工作内存之后才能写回主内存；\r\n\r\n举个例子，假设主内存的共享变量为0，线程1和线程2分别读取共享变量的副本进入自己的工作内存，假设线程1此时将共享变量修改为1同时刷回主内存中，当线程2想要去使用自己本地内存中共享变量的副本时就会发现该缓存的变量失效了，就不得不重新回到主存中重新缓存共享变量进自己的工作内存。\r\n\r\n那么上述的例子就很好理解了，Updater和Reader线程分别缓存init_value进入自己的工作内存，Updater对init_value进行+1操作并立即刷回主内存中，同时Reader线程本地内存中的init_value失效，Reader重新缓存init_value，然后判断是否发生变化。\r\n\r\n这就是volatile的作用，即保证共享变量对线程的可见性。\r\n\r\nvolatile与synchronized的区别如下\r\n\r\n1. volatile只能作用于变量，synchronized作用在方法和代码块上；\r\n2. volatile能保证可见性与有序性，但是无法保证原子性，synchronized不仅可以保证可见性还可以保证原子性；\r\n3. volatile不会造成线程阻塞那么就不能用于同步线程，synchronized可以阻塞线程可以用于同步\r\n4. volatile修饰的变量可以为null，synchronized关键字同步的monitor对象不能为null。","cover":"/images/java.jpg","link":"cache-model-and-java-memory-model-and-volatile-keyword.html","preview":"\u003cp\u003eCPU比RAM的速度快得多，通常差距达上千倍，在极端情况下有上万倍的差距，那么为了协调RAM与CPU之间的速度矛盾提高CPU资源利用率，一般在CPU与RAM之间增设Cache，CPU访Cache的速度远高于访RAM的速度。\u003c/p\u003e\n","title":"Cache模型与Java内存模型及volatile关键字"},{"content":"\r\n\r\n对共享变量的操作有三种方式：\r\n\r\n+ 多线程不同runnable实例类变量实现，通过类变量实现多线程对不同runnable实例间共享变量的操作\r\n+ 多线程相同runnable实例成员变量实现，通过相同runnable实例实现多线程对共享变量的操作\r\n+ 多线程相同类实例成员变量实现，通过相同类实例多线程调用类实例方法实现多线程对共享变量的操作\r\n\r\n但是对共享变量的操作会存在线程安全问题，通过加锁可以解决，那么线程安全的对共享变量的操作三种方式如下\r\n\r\n+ 多线程不同runnable实例类变量实现，通过类变量实现多线程对不同runnable实例间共享变量的操作，加锁实现线程安全\r\n+ 多线程相同runnable实例成员变量实现，通过相同runnable实例实现多线程对共享变量的操作，加锁实现线程安全\r\n+ 多线程相同类实例成员变量实现，通过相同类实例多线程调用类实例方法实现多线程对共享变量的操作，加锁实现线程安全\r\n\r\n以上涉及的是多线程对共享变量的同类型操作，不会涉及到线程间的通信，如果是多线程对共享变量的不同类型的操作，那么就要涉及到线程间的通信，比如典型的生产者与消费者问题，生产队列为空那么就无法消费，生产队列为满，那么无法生产。\r\n\r\n假定有两个线程，分别是生产线程与消费线程，那么二者就需要通信，用第三种对共享变量操作的方法更好，共享变量就是队列，通过将操作抽象为一个共享成员与两个队共享成员操作的方法，分别是生产与消费，那么生产者线程与消费者线程分别使用相同的类实例，一个调用生产方法，一个调用消费方法即可\r\n\r\n如果生产者有多个线程，那么也需要调度，notifyAll与while、wait。\r\n\r\n如果多线程不涉及对共享资源的操作，那么就不存在线程安全问题，可能也不需要通信，但是如果线程间有依赖关系(比如生产者消费者问题)，那么必然需要线程间通信(调度)，通过Thread的相关API调度，一个线程阻塞另一个线程运行并相互通知，那么肯定是第三种方法更好。","cover":"/images/java.jpg","link":"summary-of-previous-multithreading-foundations.html","preview":"\u003cp\u003e如果多线程不涉及对共享资源的操作，那么就不存在线程安全问题，可能也不需要通信，但是如果线程间有依赖关系(比如生产者消费者问题)，那么必然需要线程间通信(调度)，通过Thread的相关API调度，一个线程阻塞另一个线程运行并相互通知，那么肯定是(本文)第三种方法更好。\u003c/p\u003e\n","title":"对前面多线程基础的总结"},{"content":"\r\n\r\n## 一、捕获线程运行时异常信息\r\n\r\n线程在运行时是不允许抛出checked异常的，而且线程运行在自己的上下文中，派生它的线程无法直接获得它运行时出现的异常信息。但是，Java提供了UncaughtExceptionHandler接口，当线程在运行过程中出现异常时，会回掉UncaughtExceptionHandler接口，从而就可以知道哪个线程在运行时出错了以及出现了什么样的错误。\r\n\r\n在Thread类当中，关于处理运行时异常的API共有四个，如下\r\n\r\n```\r\npublic void setUncaughtExceptionHandler(UncaughtExceptionHandler eh)：为某个特定线程指定UncaughtExceptionHandler\r\npublic static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh)：设置全局的UncaughtExceptionHandler\r\npublic UncaughtExceptionHandler getUncaughtExceptionHandler()：获取特定线程的UncaughtExceptionHandler\r\npublic static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler()：获取全局的UncaughtExceptionHandler\r\n```\r\n\r\n示例如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class CaptrureThreadException {\r\n\r\n    public static void main(String[] args) {\r\n        Thread.setDefaultUncaughtExceptionHandler((t, e) -\u003e {\r\n            System.out.println(t.getName() + \" occur exception\");\r\n            e.printStackTrace();\r\n        });\r\n        final Thread thread = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    TimeUnit.SECONDS.sleep(2);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                // 这里会出现unchecked异常\r\n                System.out.println(1 / 0);\r\n            }\r\n        }, \"Test-Thread\");\r\n        thread.start();\r\n    }\r\n\r\n}\r\n```\r\n\r\n我们通过`Thread.setDefaultUncaughtExceptionHandler`为线程设置全局的异常捕获回调。该示例输出为\r\n\r\n```\r\nTest-Thread occur exception\r\njava.lang.ArithmeticException: / by zero\r\n\tat CaptrureThreadException$1.run(CaptrureThreadException.java:19)\r\n\tat java.lang.Thread.run(Unknown Source)\r\n```\r\n\r\n可以看出，明显捕获出现异常的线程和原因。\r\n\r\n## 二、注入钩子线程\r\n\r\nJVM进程的退出，是由于JVM进程中没有活跃的非守护线程或者收到了系统的中断信号。向JVM程序注入一个Hook线程，那么在JVM进程退出的时候，Hook线程就会启动执行，通过Runtime可以为JVM注入多个Hook线程，示例代码如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class ThreadHook {\r\n\r\n    public static void main(String[] args) {\r\n        Runtime.getRuntime().addShutdownHook(new Thread() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    System.out.println(\"The hook thread 1 is running.\");\r\n                    TimeUnit.SECONDS.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(\"The hook thread 1 will exit.\");\r\n            }\r\n        });\r\n        Runtime.getRuntime().addShutdownHook(new Thread() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    System.out.println(\"The hook thread 2 is running.\");\r\n                    TimeUnit.SECONDS.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                System.out.println(\"The hook thread 2 will exit.\");\r\n            }\r\n        });\r\n        System.out.println(\"The main thread will is stopping.\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nThe main thread will is stopping.\r\nThe hook thread 1 is running.\r\nThe hook thread 2 is running.\r\nThe hook thread 2 will exit.\r\nThe hook thread 1 will exit.\r\n```\r\n\r\n可见，在主线程退出后Hook线程就会运行，待Hook线程运行结束后，整个JVM进程退出。\r\n\r\nHook的实际意义在哪？比如为了防止某个程序被重复启动，在进程启动时会创建一个lock文件，在又一次启动程序时，程序会检查是否存在lock文件，如果存在，那么说明程序已经启动不能重复启动，如果不存在那么就启动。但是为了下一次正常启动程序，我们得在程序关闭的时候删除掉lock文件，那么Hook线程就派上用场了。\r\n\r\n事实上，在MySQL服务器、zookeeper、kafka等系统中都能看到lock文件的存在。","cover":"/images/java.jpg","link":"capturing-thread-runtime-exception-information-and-injecting-hook-threads.html","preview":"\u003cp\u003e线程在运行时是不允许抛出checked异常的，而且线程运行在自己的上下文中，派生它的线程无法直接获得它运行时出现的异常信息。但是，Java提供了UncaughtExceptionHandler接口，当线程在运行过程中出现异常时，会回掉UncaughtExceptionHandler接口，从而就可以知道哪个线程在运行时出错了以及出现了什么样的错误。\u003c/p\u003e\n","title":"捕获线程运行时异常信息与注入钩子线程"},{"content":"\r\n\r\n每个线程都会有ThreadGroup，如果在启动的时候没有在构造方法Thread显式的指明ThreadGroup，那么该线程就会自动的被加入与父线程相同的ThreadGroup当中，启动该线程的线程就是该线程的父线程。\r\n\r\n不仅仅Thread存在父子关系，ThreadGroup也存在父子关系，ThreadGroup中可以有子线程，也可以有子ThreadGroup。\r\n\r\n创建ThreadGroup的语法如下\r\n\r\n```\r\npublic ThreadGroup(String name);\t//name指定ThreadGroup的名字，但是该ThreadGroup的父ThreadGroup是创建它的线程所在的ThreadGroup\r\npublic ThreadGroup(ThreadGroup parent, String name)\t//parent指明了该ThreadGroup的父ThreadGroup，name指明名字\r\n```\r\n\r\n示例代码如下\r\n\r\n```\r\npublic class ThreadGroupTest {\r\n\r\n    public static void main(String[] args) {\r\n        // 获取当前线程(主线程)所在的ThreadGroup\r\n        ThreadGroup currentGroup = Thread.currentThread().getThreadGroup();\r\n        // 没有显式的指明该ThreadGroup的父ThreadGroup，所以其父ThreadGroup为创建它的线程(主线程)的ThreadGroup，即currentGroup\r\n        ThreadGroup group1 = new ThreadGroup(\"Group1\");\r\n        System.out.println(currentGroup == group1.getParent()); //true\r\n        // 指明该ThreadGroup的父ThreadGroup为group1\r\n        ThreadGroup group2 = new ThreadGroup(group1, \"Group2\");\r\n        System.out.println(group2.getParent() == group1);   //true\r\n        System.out.println(group2.getParent().getParent() == group1.getParent());   //true\r\n        System.out.println(group2.getParent() == group1.getParent());   //false\r\n    }\r\n\r\n}\r\n```\r\n\r\n都很容易理解，不解释\r\n\r\n那么该示例的ThreadGroup结构如下\r\n\r\n![](/images/article/1549881446369-1daf81e3-77e2-4dbc-a839-63d2016f55f1.png)\r\n\r\n\u003ca name=\"59d3d021\"\u003e\u003c/a\u003e\r\n## 一、Thread数组\r\n\r\n顾名思义，Thread数组中的元素是Thread，我们可以通过ThreadGroup的以下方法将该ThreadGroup中的active状态的线程全部复制到Thread数组中\r\n\r\n```\r\npublic int enumerate(Thread[] list)\r\npublic int enumerate(Thread[] list, boolean recurse)\r\n```\r\n\r\n如果recurse为true，那么会递归当前ThreadGroup的子ThreadGroup中的active状态的线程到list中。\r\n\r\n演示一下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class ThreadGroupEnumerateThreads {\r\n\r\n    public static void main(String[] args) throws InterruptedException {\r\n        ThreadGroup myGroup = new ThreadGroup(\"MyGroup\");\r\n        Thread thread = new Thread(myGroup, new Runnable() {\r\n\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    try {\r\n                        TimeUnit.SECONDS.sleep(1);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n            \r\n        }, \"MyThread\");\r\n        thread.start();\r\n        TimeUnit.MICROSECONDS.sleep(2);\r\n        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();\r\n        Thread[] list = new Thread[mainGroup.activeCount()];\r\n        int recurseSize = mainGroup.enumerate(list, false);\r\n        System.out.println(recurseSize);    //1\r\n        recurseSize = mainGroup.enumerate(list, true);\r\n        System.out.println(recurseSize);    //2\r\n    }\r\n\r\n}\r\n```\r\n\r\n第一个输出为1，这是因为mainGroup有一个main线程，一个myGroup，由于boolean为false，那么没有递归myGroup中的Thread，所以为1。那么第二个为2就不难理解了。\r\n\r\n## 二、ThreadGroup数组\r\n\r\n顾名思义，ThreadGroup数组存放的元素为ThreadGroup，可以用ThreadGroup的以下方法将当前ThreadGroup的子ThreadGroup复制进去。\r\n\r\n```\r\npublic int enumerate(ThreadGroup[] list)\r\npublic int enumerate(ThreadGroup[] list, boolean recurse)\r\n```\r\n\r\n仍然是recurse为true递归复制当前ThreadGroup的子ThreadGroup中的ThreadGroup。示例如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class ThreadGroupEnumerateThreadGroups {\r\n\r\n    public static void main(String[] args) throws InterruptedException {\r\n        ThreadGroup group1 = new ThreadGroup(\"Group1\");\r\n        ThreadGroup group2 = new ThreadGroup(group1, \"Group2\");\r\n        TimeUnit.MILLISECONDS.sleep(2);\r\n        ThreadGroup mainGroup = Thread.currentThread().getThreadGroup();\r\n        ThreadGroup[] list = new ThreadGroup[mainGroup.activeGroupCount()];\r\n        int recurseSize = mainGroup.enumerate(list, false);\r\n        System.out.println(recurseSize);    //1\r\n        recurseSize = mainGroup.enumerate(list, true);\r\n        System.out.println(recurseSize);    //2\r\n    }\r\n\r\n}\r\n```\r\n\r\n都很简单，不用解释。\r\n\r\n## 三、ThreadGroup操作\r\n\r\nThreadGroup并不能提供对线程的管理，ThreadGroup的主要功能是对线程进行组织，其主要方法如下\r\n\r\n+ `activeCount()`用于获取group中活跃的线程数量，只是一个估计值；\r\n+ `activeGroupCount()`用于获取group中活跃的子group的线程数量，也是一个估计值；\r\n+ `getMaxPriority()`用于获取group的优先级，不会大于父group的最大优先级；\r\n+ `getName()`用于获取该group的名字；\r\n+ `getParent()`用于获取该group的父ThreadGroup，如果不存在则返回null；\r\n+ `list()`没有返回值，直接将group中活跃的线程信息全部输出到控制台；\r\n+ `parentOf(ThreadGroup g)`会判断当前group是不是给定group的父group，如果给定的group是本身，那么也会返回true；\r\n+ `setMaxPriority(int pri)`会指定group的最大优先级，最大优先级不能超过父ThreadGroup的最大优先级，执行该方法不仅会改变当前group的最大优先级，还会改变当前group的子group的最大优先级；\r\n+ `interrupt()`方法会导致该group中所有的active线程被interrupt，也就是该group中所有的线程的interrupt标识都会被设置为true；\r\n+ `destroy()`方法用于销毁ThreadGroup，该方法只是针对一个没有任何active线程的group进行一次destroy标记，调用该方法的直接结果就是在父group中将自己移除；\r\n+ `isDestroy()`方法判断当前ThreadGroup线程是否被destroy了；\r\n+ `setDaemon()`方法将当前ThreadGroup设置为守护ThreadGroup，那么在group中没有任何active线程的时候该group将自动destroy。","cover":"/images/java.jpg","link":"threadgroup-detailed-explanation.html","preview":"\u003cp\u003e每个线程都会有ThreadGroup，如果在启动的时候没有在构造方法Thread显式的指明ThreadGroup，那么该线程就会自动的被加入与父线程相同的ThreadGroup当中，启动该线程的线程就是该线程的父线程。\u003c/p\u003e\n","title":"ThreadGroup详解"},{"content":"\r\n\r\n前文的叫号机示例为保证线程安全引入了synchronized关键字(获得锁保证同一时间只能有一个线程对共享资源操作)，而为了解决synchorized关键字的不可中断不可超时问题，我们引入了显式锁，显式锁通过wait关键字和closed标志为true来实现加锁让欲获得锁的线程进入阻塞状态以等待，通过notify关键字和closed为false来实现释放锁让阻塞状态的线程竞争锁，实际上这就涉及到了进程间的调度，synchronized关键字不仅仅是加锁保证对共享变量访问的互斥性，还可以配合某些策略或者关键实现进程调度。\r\n\r\n## 一、单线程间通信\r\n\r\n### 1.1 同步阻塞\r\n\r\n假定有这样一个系统功能，客户端提交Event到服务器，服务器接收客户请求之后开辟线程处理请求，在经过较为复杂的业务计算后将结果返回给客户端。如果采用同步式阻塞消息处理的话，那么处理流程为\r\n\r\n![](/images/article/1549881238354-5d8d1e3b-cc90-4be7-8ed1-0cf9f9c80dd9.png)\r\n\r\n缺陷如下：\r\n\r\n+ 同步Event提交，客户端等待时间过长(提交Event时长+接受Event创建Thread时长+业务处理时长+返回结果时长)会陷入阻塞，导致二次提交Event耗时过长；\r\n+ 由于客户端提交的Event数量不多，导致系统同时受理业务数量有限，也就是系统的整体吞吐量不高；\r\n+ 这种一个线程处理一个Event的方式，会导致频繁的创建开启和销毁，从而增加系统额外开销；\r\n+ 在业务达到峰值的时候，大量的业务处理线程阻塞会导致频繁的CPU上下文切换，从而降低系统性能。\r\n\r\n### 1.2 异步非阻塞\r\n\r\n而与之相对应的是异步式非阻塞消息处理，具体做法：由于接受Event与处理Event的线程的操作对象都是Event，那么我们可以定义一个类，将对Event的操作(接受与处理操作)都封装起来，该类内部通过synchronized关键字保证线程安全即接受操作与处理操作在同一时间是能有一个对Event队列进行操作。但是我们的Event队列应该有一个上限，以增加系统的稳定性。\r\n\r\n我们首先想到如下策略，就是只利用synchronized关键字，如果放Event的线程获得锁之后先判断Event队列时候满了，如果满了就不能再放了，这个时候该线程应该释放锁，因为取Event的线程还在阻塞着呢，应该让取Event的线程从Event队列中取出一部分再让放线程把Event放进去。那么我们就有了一个思路\r\n\r\n+ 如果放Event的线程获得锁判断队列已经满了，那么什么都不做，那么就会释放锁，如果没满，那么放进队列里面再释放锁；\r\n+ 如果取Event的线程获得锁判断队列是空的，那么什么也不做，那么也会释放锁，如果非空，那么就取出来进一步处理。代码如下\r\n\r\n```\r\nimport java.util.LinkedList;\r\n\r\npublic class EventQueue {\r\n    private final int max;\r\n    static class Event {\r\n        \r\n    }\r\n    private final LinkedList eventQueue = new LinkedList\u003c\u003e();\r\n    private final static int DEFAULT_MAX_EVENT = 10;\r\n    public EventQueue() {\r\n        this(DEFAULT_MAX_EVENT);\r\n    }\r\n    public EventQueue(int max) {\r\n        this.max = max;\r\n    }\r\n    public void produce(Event zhuan) {\r\n        synchronized(eventQueue) {\r\n            if (eventQueue.size() \u003e= max) {\r\n                // 队列满了，什么也不做，就会执行逻辑释放锁(什么逻辑也没有直接释放)\r\n            } else {\r\n                // 队列没满，就会执行逻辑后再释放锁\r\n                System.out.println(\"The new Event is submitted.\");\r\n                eventQueue.addLast(zhuan);\r\n            }\r\n        }\r\n    }\r\n    public Event consume() {\r\n        synchronized(eventQueue) {\r\n            Event event = null;\r\n            if (eventQueue.isEmpty()) {\r\n                // 队列为空，什么也不做，就会执行逻辑释放锁(什么逻辑也没有直接释放)\r\n            } else {\r\n                // 队列没满，就会执行逻辑后再释放锁\r\n                event = eventQueue.removeFirst();\r\n                System.out.println(\"The Event in queue that name is \" + event + \" is taked.\");\r\n            }\r\n            return event;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n测试文件为\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class ZhuanMain {\r\n\r\n    public static void main(String[] args) {\r\n        final EventQueue eventQueue = new EventQueue();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    eventQueue.produce(new EventQueue.Event());\r\n                }\r\n            }\r\n        }, \"Producer\").start();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    eventQueue.consume();\r\n                    try {\r\n                        TimeUnit.MICROSECONDS.sleep(10);  \r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        }, \"Consumer\").start();\r\n    }\r\n\r\n}\r\n```\r\n\r\n部分输出如下\r\n\r\n```\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe Event in queue that name is EventQueue$Event@137f5133 is taked.\r\nThe new Event is submitted.\r\nThe Event in queue that name is EventQueue$Event@1db8bd2c is taked.\r\nThe new Event is submitted.\r\nThe Event in queue that name is EventQueue$Event@19873a43 is taked.\r\nThe new Event is submitted.\r\nThe Event in queue that name is EventQueue$Event@5c85b717 is taked.\r\nThe new Event is submitted.\r\nThe Event in queue that name is EventQueue$Event@351a837d is taked.\r\nThe new Event is submitted.\r\nThe Event in queue that name is EventQueue$Event@6d93092f is taked.\r\nThe new Event is submitted.\r\n```\r\n\r\n可见，需求实现了，满了就不再放，空了就不再取。但是这种方式很落后，完全是两个线程在不断轮询，即无时无刻都在检查队列中是否用Event，再进一步操作，很浪费系统资源啊。我们得改造一下，用通知的办法，即队列满了的时候就把自己阻塞，相当于只要队列满了放Event的线程就歇歇，那么由于wait方法阻塞自己不会独占锁，也就意味着取Event的线程可以获得锁去取Event；如果Event没满，那么放Event的线程就把Event放进去并且通知取Event的线程现在有活干了，等我释放锁之后你就可以去拿了。\r\n\r\n也很简单，只需要在produce中的if中让当前线程wait进入阻塞状态，那么取Event的线程就会获得锁退出阻塞状态去运行；然后在else分支中增加唤醒其余线程的notify方法，通知其余线程起来干活。\r\n\r\nconsume也是同理，代码如下\r\n\r\n```\r\nimport java.util.LinkedList;\r\n\r\npublic class EventQueue {\r\n    private final int max;\r\n    static class Event {\r\n        \r\n    }\r\n    private final LinkedList eventQueue = new LinkedList\u003c\u003e();\r\n    private final static int DEFAULT_MAX_EVENT = 10;\r\n    public EventQueue() {\r\n        this(DEFAULT_MAX_EVENT);\r\n    }\r\n    public EventQueue(int max) {\r\n        this.max = max;\r\n    }\r\n    public void produce(Event zhuan) {\r\n        synchronized(eventQueue) {\r\n            if (eventQueue.size() \u003e= max) {\r\n                try {\r\n                    System.out.println(\"The queue is full.\");\r\n                    eventQueue.wait();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            System.out.println(\"The new Event is submitted.\");\r\n            eventQueue.addLast(zhuan);\r\n            eventQueue.notify();\r\n        }\r\n    }\r\n    public Event consume() {\r\n        synchronized(eventQueue) {\r\n            if (eventQueue.isEmpty()) {\r\n                try {\r\n                    System.out.println(\"The queue is empty.\");\r\n                    eventQueue.wait();\r\n                } catch (InterruptedException e) {\r\n                   e.printStackTrace();\r\n                }\r\n            }\r\n            Event event = eventQueue.removeFirst();\r\n            System.out.println(\"The Event in queue that name is \" + event + \" is taked.\");\r\n            this.eventQueue.notify();\r\n            return event;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n主文件不变，结果为\r\n\r\n```\r\nThe queue is empty.\r\nThe new Event is submitted.\r\nThe Event in queue that name is EventQueue$Event@6900a9fc is taked.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe new Event is submitted.\r\nThe queue is full.\r\nThe Event in queue that name is EventQueue$Event@67c74aac is taked.\r\nThe new Event is submitted.\r\nThe queue is full.\r\nThe Event in queue that name is EventQueue$Event@63f8c28c is taked.\r\nThe new Event is submitted.\r\nThe queue is full.\r\nThe Event in queue that name is EventQueue$Event@26fa4097 is taked.\r\nThe new Event is submitted.\r\nThe queue is full.\r\nThe Event in queue that name is EventQueue$Event@4a5942fd is taked.\r\nThe new Event is submitted.\r\nThe queue is full.\r\n```\r\n\r\n可见，两种方法都可以，只是第二种更“智能”一点。\r\n\r\n既然wait和notify方法这么优秀，有必要看一下它的签名\r\n\r\nwait的签名为\r\n\r\n```\r\npublic final void wait() throws InterruptedException\t//等价于wait(0)，即永不超时进入阻塞状态，调用了该方法的Object只能被notify唤醒\r\npublic final void wait(long timeout) throws InterruptedException\t//timeout时间过后进入脱离阻塞进入就绪状态\r\npublic final void wait(long timeout, int nanos) throws InterruptedException\r\n```\r\n\r\n需要注意的是wait方法必须拥有该对象的monitor，也就是该方法只能在同步方法中使用，即被synchronized关键字修饰的方法或者代码块中使用。\r\n\r\n再唠叨一下，当前线程执行了该对象的wait方法后，将会放弃对该monitor的所有权并且进入与该对象关联的wait set(线程休息室，等待notify通知，就不用轮询这种低级的办法)中，即调用wait方法后会释放对monitor线程的所有权，其他线程就有机会争抢对该monitor线程的所有权。\r\n\r\nnotify的相关签名为\r\n\r\n```\r\npublic final native void notify()\t//唤醒单个正在执行该对象wait方法的线程\r\npublic final native void notifyAll()\t//唤醒wait set中所有的正在执行该对象wait方法的线程\r\n```\r\n\r\n## 二、多线程间通信\r\n\r\n指的是取Event和放Event分别有多个线程再干，那么线程间就需要通信\r\n\r\n如果在上述代码的基础上增加取或者放Event线程的数量，(为了区分线程，给上述代码加上线程名)如下\r\n\r\n```\r\nimport java.util.LinkedList;\r\n\r\npublic class EventQueue {\r\n    private final int max;\r\n    static class Event {\r\n        \r\n    }\r\n    private final LinkedList eventQueue = new LinkedList\u003c\u003e();\r\n    private final static int DEFAULT_MAX_EVENT = 10;\r\n    public EventQueue() {\r\n        this(DEFAULT_MAX_EVENT);\r\n    }\r\n    public EventQueue(int max) {\r\n        this.max = max;\r\n    }\r\n    public void produce(Event zhuan) {\r\n        synchronized(eventQueue) {\r\n            if (eventQueue.size() \u003e= max) {\r\n                try {\r\n                    System.out.println(Thread.currentThread().getName()+ \" : The queue is full.\");\r\n                    eventQueue.wait();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            System.out.println(Thread.currentThread().getName()+ \" : The new Event is submitted.\");\r\n            eventQueue.addLast(zhuan);\r\n            eventQueue.notify();\r\n        }\r\n    }\r\n    public Event consume() {\r\n        synchronized(eventQueue) {\r\n            if (eventQueue.isEmpty()) {\r\n                try {\r\n                    System.out.println(Thread.currentThread().getName()+ \" : The queue is empty.\");\r\n                    eventQueue.wait();\r\n                } catch (InterruptedException e) {\r\n                   e.printStackTrace();\r\n                }\r\n            }\r\n            Event event = eventQueue.removeFirst();\r\n            System.out.println(Thread.currentThread().getName()+ \" : The Event in queue that name is \" + event + \" is taked.\");\r\n            this.eventQueue.notify();\r\n            return event;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n主文件为\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class ZhuanMain {\r\n\r\n    public static void main(String[] args) {\r\n        final EventQueue eventQueue = new EventQueue();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    eventQueue.produce(new EventQueue.Event());\r\n                }\r\n            }\r\n        }, \"Producer\").start();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    eventQueue.consume();\r\n                    try {\r\n                        TimeUnit.MICROSECONDS.sleep(10);  \r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        }, \"Consumer - 1\").start();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    eventQueue.consume();\r\n                    try {\r\n                        TimeUnit.MICROSECONDS.sleep(10);  \r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        }, \"Consumer - 2\").start();\r\n    }\r\n\r\n}\r\n```\r\n\r\n如果你多运行几次，那么就会发现以下问题\r\n\r\n+ LinkedList为空时执行removeFirst方法\r\n+ LinkedList元素为10时执行addLast方法\r\n\r\n存在数据不一致的情况，那么解决的办法(实现多线程间通信的办法)是将if改为while，将notify改为notifyAll(一次性唤醒所有的wait set中的阻塞的线程，他们就会争抢monitor锁，这正是并发的优势)。\r\n\r\n最终的EventQueue代码为：\r\n\r\n```\r\nimport java.util.LinkedList;\r\n\r\npublic class EventQueue {\r\n    private final int max;\r\n    static class Event {\r\n        \r\n    }\r\n    private final LinkedList eventQueue = new LinkedList\u003c\u003e();\r\n    private final static int DEFAULT_MAX_EVENT = 10;\r\n    public EventQueue() {\r\n        this(DEFAULT_MAX_EVENT);\r\n    }\r\n    public EventQueue(int max) {\r\n        this.max = max;\r\n    }\r\n    public void produce(Event zhuan) {\r\n        synchronized(eventQueue) {\r\n            while (eventQueue.size() \u003e= max) {\r\n                try {\r\n                    System.out.println(Thread.currentThread().getName()+ \" : The queue is full.\");\r\n                    eventQueue.wait();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n            System.out.println(Thread.currentThread().getName()+ \" : The new Event is submitted.\");\r\n            eventQueue.addLast(zhuan);\r\n            eventQueue.notifyAll();\r\n        }\r\n    }\r\n    public Event consume() {\r\n        synchronized(eventQueue) {\r\n            while (eventQueue.isEmpty()) {\r\n                try {\r\n                    System.out.println(Thread.currentThread().getName()+ \" : The queue is empty.\");\r\n                    eventQueue.wait();\r\n                } catch (InterruptedException e) {\r\n                   e.printStackTrace();\r\n                }\r\n            }\r\n            Event event = eventQueue.removeFirst();\r\n            System.out.println(Thread.currentThread().getName()+ \" : The Event in queue that name is \" + event + \" is taked.\");\r\n            this.eventQueue.notifyAll();\r\n            return event;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n综上，线程间通信，通过synchronized关键字(monitor锁)、wait、notify、notifyAll来实现，synchronized关键字本身实现的是一种轮询式的调度，耗费系统资源，如果它配合其余三个方法，那么真正就会利用通知机制，只会在有必要的时候运行。","cover":"/images/java.jpg","link":"inter-thread-communication.html","preview":"\u003cp\u003e前文的叫号机示例为保证线程安全引入了synchronized关键字(获得锁保证同一时间只能有一个线程对共享资源操作)，而为了解决synchorized关键字的不可中断不可超时问题，我们引入了显式锁，显式锁通过wait关键字和closed标志为true来实现加锁让欲获得锁的线程进入阻塞状态以等待，通过notify关键字和closed为false来实现释放锁让阻塞状态的线程竞争锁，实际上这就涉及到了进程间的调度，synchronized关键字不仅仅是加锁保证对共享变量访问的互斥性，还可以配合某些策略或者关键实现进程调度。\u003c/p\u003e\n","title":"线程间通信"},{"content":"\r\n\r\n## 一、synchronized关键字初识\r\n\r\n在《线程间共享变量与synchronized关键字解决线程不安全问题》一文当中的叫号机程序由于多线程对共享变量(共享资源)的访问导致数据不一致问题，我们是通过synchronized关键字来解决的。\r\n\r\n如果用synchronized关键字修饰一个方法或者代码块，那么就可以防止因多线程作用共享资源而导致的数据不一致或者线程安全问题，该关键字只会保证其作用的方法或者代码块在同一时间只会被一个线程使用，即被修饰对象只对获得锁的线程可见，其余线程只能阻塞等待锁的释放。其具体表现如下\r\n\r\n+ synchronized关键字提供了一种锁机制，能够保证多线程对共享变量的互斥访问，从而避免了数据不一致(线程不安全)的情况；\r\n+ synchronized关键字包括monitor enter和monitor exit两个JVM指令，成对出现，他们能够保证在任何时候任何线程执行到monitor enter成功之前即获得锁之时都必须从主内存中获取数据，而不是从缓存中获取数据，在monitor exit运行成功之后即释放锁之后，共享变量被更新后的值必须刷u入主内存之中;\r\n+ synchronized关键字的指令严格按照java happens-before 规则，一个monitor exit指令之前必须要有一个monitor enter。\r\n\r\nsynchronized关键字的用法如下\r\n\r\n一种是修饰在方法上，此时方法就会变成同步方法，即多个线程只能一个一个进入，且一个进入另一个只能等待，如下\r\n\r\n```\r\n[default|public|private|protected] synchronized [static] type method() {\r\n    \r\n}\r\n```\r\n\r\n另一种是修饰在同步代码块上，如下\r\n\r\n```\r\nprivate final Object MUTEX = new Object();\r\npublic void sync() {\r\n    synchronized(MUTEX) {\r\n        //设计共享变量的相关逻辑\r\n    }\r\n}\r\n```\r\n\r\n## 二、synchronized关键字的注意问题\r\n\r\n**第一个注意的是，与monitor关联的对象不能为空，**如下\r\n\r\n```\r\nprivate final Object MUTEX= null;\r\npublic void sync() {\r\n    synchronized(MUTEX) {\r\n        //\r\n    }\r\n}\r\n```\r\n\r\n以上是不对的，应该实例化MUTEX，否则就等于没加锁\r\n\r\n**第二个应该注意的是，synchronized的粒度不能过大，否则就会失去并发的优势。**\r\n\r\n因为多线程在多核处理器下本来是并行运行的，所以速度快，但是到涉及到共享变量的被synchronized修饰的同步代码块时，就会变成串行执行，如果粒度过大，那么串行执行的代码越多，就会丧失并发的优势。\r\n\r\n所以，尽可能锁涉及共享变量操作的代码块，而尽可能不锁方法。\r\n\r\n**第三个应该注意的是，不同的monitor企图锁相同的方法，这也是不对的**\r\n\r\n简单的说，锁存在的意义就是多线程之间必须涉及到对共享变量的操作，如果每个线程都构造一个有着相同代码(或者相同方法)的Runnable实例，那么实例只会存在于线程的私有作用域，压根不会涉及到对共享变量的操作，举个例子，就用之前的叫号机，如下\r\n\r\n```\r\npublic class TicketWindow implements Runnable {\r\n    private int num = 1;\r\n    private static final int maxNum = 10;\r\n    private static final Object MUTEX = new Object();\r\n    @Override\r\n    public void run() {\r\n        while (num \u003c= maxNum) {\r\n            synchronized(MUTEX) {\r\n                if (num \u003c= maxNum) {\r\n                    System.out.println(Thread.currentThread() + \" current number is \" + (num++));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npublic class TicketWindowMain {\r\n\r\n    public static void main(String[] args) {\r\n        //TicketWindow tw = new TicketWindow();\r\n        Thread t1 = new Thread(new TicketWindow(), \"First\");\r\n        Thread t2 = new Thread(new TicketWindow(), \"Second\");\r\n        Thread t3 = new Thread(new TicketWindow(), \"Third\");\r\n        t1.start();\r\n        t2.start();\r\n        t3.start();\r\n        \r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nThread[First,5,main] current number is 1\r\nThread[First,5,main] current number is 2\r\nThread[Third,5,main] current number is 1\r\nThread[Third,5,main] current number is 2\r\nThread[Third,5,main] current number is 3\r\nThread[Third,5,main] current number is 4\r\nThread[Third,5,main] current number is 5\r\nThread[Third,5,main] current number is 6\r\nThread[Third,5,main] current number is 7\r\nThread[Third,5,main] current number is 8\r\nThread[Second,5,main] current number is 1\r\nThread[Second,5,main] current number is 2\r\nThread[Second,5,main] current number is 3\r\nThread[Second,5,main] current number is 4\r\nThread[Second,5,main] current number is 5\r\nThread[Second,5,main] current number is 6\r\nThread[Second,5,main] current number is 7\r\nThread[Second,5,main] current number is 8\r\nThread[Second,5,main] current number is 9\r\nThread[Second,5,main] current number is 10\r\nThread[Third,5,main] current number is 9\r\nThread[Third,5,main] current number is 10\r\nThread[First,5,main] current number is 3\r\nThread[First,5,main] current number is 4\r\nThread[First,5,main] current number is 5\r\nThread[First,5,main] current number is 6\r\nThread[First,5,main] current number is 7\r\nThread[First,5,main] current number is 8\r\nThread[First,5,main] current number is 9\r\nThread[First,5,main] current number is 10\r\n```\r\n\r\n可见，由于每个线程都有了变量num，使得num不再是共享变量，就会导致加锁失败。解决问题的方法就是让诸线程使用同一个对象实例，即让多线程使用同一个包含共享变量方法的类实例，如下改动主文件\r\n\r\n```\r\npublic class TicketWindowMain {\r\n\r\n    public static void main(String[] args) {\r\n        TicketWindow tw = new TicketWindow();\r\n        Thread t1 = new Thread(tw, \"First\");\r\n        Thread t2 = new Thread(tw, \"Second\");\r\n        Thread t3 = new Thread(tw, \"Third\");\r\n        t1.start();\r\n        t2.start();\r\n        t3.start();\r\n        \r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nThread[Second,5,main] current number is 1\r\nThread[Second,5,main] current number is 2\r\nThread[Second,5,main] current number is 3\r\nThread[Second,5,main] current number is 4\r\nThread[Second,5,main] current number is 5\r\nThread[First,5,main] current number is 6\r\nThread[First,5,main] current number is 7\r\nThread[First,5,main] current number is 8\r\nThread[First,5,main] current number is 9\r\nThread[First,5,main] current number is 10\r\n```\r\n\r\n**第四个应该注意的是，多个锁交叉导致的死锁**\r\n\r\n如果A线程持有R1的锁而等待R2的锁，B线程正好持有R2的锁而等待R1的锁，那么就会形成死锁。示例如下\r\n\r\n```\r\npublic class DeadLock {\r\n    private final Object READ_MUTEX = new Object();\r\n    private final Object WRITE_MUTEX = new Object();\r\n    \r\n    public void read() {\r\n        synchronized(READ_MUTEX) {\r\n            System.out.println(Thread.currentThread().getName() + \"get READ lock\");\r\n            synchronized(WRITE_MUTEX) {\r\n                System.out.println(Thread.currentThread().getName() + \"get WRITE lock\");\r\n            }\r\n            System.out.println(Thread.currentThread().getName() + \"release WRITE lock\");\r\n        }\r\n        System.out.println(Thread.currentThread().getName() + \"release READ lock\");\r\n    }\r\n    \r\n    public void write() {\r\n        synchronized(WRITE_MUTEX) {\r\n            System.out.println(Thread.currentThread().getName() + \"get WRITE lock\");\r\n            synchronized(READ_MUTEX) {\r\n                System.out.println(Thread.currentThread().getName() + \"get READ lock\");\r\n            }\r\n            System.out.println(Thread.currentThread().getName() + \"release READ lock\");\r\n        }\r\n        System.out.println(Thread.currentThread().getName() + \"release WRITE lock\");\r\n    }\r\n    \r\n    public static void main(String[] args) {\r\n        final DeadLock dl = new DeadLock();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    dl.read();\r\n                }\r\n            }\r\n            \r\n        }, \"READ_Thread \").start();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    dl.write();\r\n                }\r\n            }\r\n            \r\n        }, \"WRITE_Thread \").start();\r\n    }\r\n}\r\n```\r\n\r\n多运行几次，就会有如下输出\r\n\r\n```\r\nREAD_Thread get READ lock\r\nWRITE_Thread get WRITE lock\r\n```\r\n\r\n可见READ_Thread已经获得READ_LOCK等待获得WRITE_LOCK,而WRITE_Thread已经获得WRITE_LOCK,等待获得READ_LOCK，双方同时拥有对方所需要的资源导致死锁，所以一定要注意不能多个锁交叉。\r\n\r\n另外，使用锁的前提是存在共享资源，那么势必多个线程只用一个RUNNABLE实例，如果把上述代码改动一下，如下\r\n\r\n```\r\npublic class DeadLock {\r\n    private final Object READ_MUTEX = new Object();\r\n    private final Object WRITE_MUTEX = new Object();\r\n    \r\n    public void read() {\r\n        synchronized(READ_MUTEX) {\r\n            System.out.println(Thread.currentThread().getName() + \"get READ lock\");\r\n            synchronized(WRITE_MUTEX) {\r\n                System.out.println(Thread.currentThread().getName() + \"get WRITE lock\");\r\n            }\r\n            System.out.println(Thread.currentThread().getName() + \"release WRITE lock\");\r\n        }\r\n        System.out.println(Thread.currentThread().getName() + \"release READ lock\");\r\n    }\r\n    \r\n    public void write() {\r\n        synchronized(WRITE_MUTEX) {\r\n            System.out.println(Thread.currentThread().getName() + \"get WRITE lock\");\r\n            synchronized(READ_MUTEX) {\r\n                System.out.println(Thread.currentThread().getName() + \"get READ lock\");\r\n            }\r\n            System.out.println(Thread.currentThread().getName() + \"release READ lock\");\r\n        }\r\n        System.out.println(Thread.currentThread().getName() + \"release WRITE lock\");\r\n    }\r\n    \r\n    public static void main(String[] args) {\r\n        final DeadLock dl = new DeadLock();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    new DeadLock().read();\r\n                }\r\n            }\r\n            \r\n        }, \"READ_Thread \").start();\r\n        new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    new DeadLock().write();\r\n                }\r\n            }\r\n            \r\n        }, \"WRITE_Thread \").start();\r\n    }\r\n}\r\n```\r\n\r\n那么就会产生不同的monitor企图锁相同的方法的问题，一定要注意\r\n\r\n## 三、自定义显式锁BooleanLock\r\n\r\nsynchronized关键字存在缺陷，第一个缺陷是无法控制阻塞时长，即锁被另一个线程占用，那么当前线程试图获取锁那么就会进入阻塞状态，如果占用锁的线程占用时间很长，那么也就意味着当前线程阻塞的时间就很长，很显然，synchronized关键字无法控制阻塞时长，另一个缺点是阻塞不可被中断，即如果当前线程因争夺monitor锁而进入阻塞主公你太，那么进入阻塞状态的线程是无法中断的，虽然可以使用interrupt进行中断，但是synchronized关键字不像sleep和wait方法一样可以捕获中断信号，所以这个缺点问题也是很大的。\r\n\r\n先演示第一个问题\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class SynchronizedDefect {\r\n    public synchronized void syncMethod() {\r\n        try {\r\n            TimeUnit.HOURS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public static void main(String[] args) throws InterruptedException {\r\n        SynchronizedDefect sd = new SynchronizedDefect();\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                sd.syncMethod();\r\n            }\r\n        });\r\n        t1.start();\r\n        TimeUnit.MICROSECONDS.sleep(2);\r\n        Thread t2 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                sd.syncMethod();\r\n            }\r\n        });\r\n        t2.start();\r\n    }\r\n}\r\n```\r\n\r\n一定要注意，多线程对锁的操作涉及到共享变量，一定要使用同一个Runnable实例。\r\n\r\n我们在被锁住的方法中让当前线程睡眠1h，先启动t1线程，为了保证t1线程最进入同步方法，我们让主线程睡眠2ms再启动t2线程，那么由于t1线程占用锁休眠期间并不会释放锁，那么t2线程就要无限等待1h等t1释放锁之后才能获得锁，这样也就是说synchronized关键字无法控制阻塞时长，即超过阻塞时间就放弃锁进入就绪状态而不是等待锁在阻塞状态。\r\n\r\n再演示第二个问题\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class SynchronizedDefect {\r\n    public synchronized void syncMethod() {\r\n        try {\r\n            TimeUnit.HOURS.sleep(1);\r\n        } catch (InterruptedException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    public static void main(String[] args) throws InterruptedException {\r\n        SynchronizedDefect sd = new SynchronizedDefect();\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                sd.syncMethod();\r\n            }\r\n        });\r\n        t1.start();\r\n        TimeUnit.MICROSECONDS.sleep(2);\r\n        Thread t2 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                sd.syncMethod();\r\n            }\r\n        });\r\n        t2.start();\r\n        t2.interrupt();\r\n        System.out.println(t2.isInterrupted());\t//true\r\n        System.out.println(t2.getState());\t//BLOCKED\r\n    }\r\n}\r\n```\r\n\r\nt2进入阻塞状态，那么主线程运行，主线程试图通过t2的interrupt方法打断t2的阻塞状态使其进入就绪状态，但是很稀罕，从输出来看interrupt确实中断过t2线程，但是失败了，其状态仍然为BLOCKED，这就说明了Synchronized关键字无法被中断。\r\n\r\n面对Synchronized的这两个缺陷，我们可以通过java.util.concurrent包中的显式锁ReentrantLock来实现，主要方法如下\r\n\r\n```\r\nReentrantLock lock = new ReentrantLock();\r\n \r\n// 获取锁，这是跟synchronized关键字对应的用法。\r\nlock.lock();\r\ntry{\r\n  // your code\r\n}finally{\r\n  lock.unlock();\r\n}\r\n \r\n// 可定时，超过指定时间没得到锁就放弃\r\ntry {\r\n  lock.tryLock(10, TimeUnit.SECONDS);\r\n  try {\r\n    // your code\r\n  }finally {\r\n    lock.unlock();\r\n  }\r\n} catch (InterruptedException e1) {\r\n  // exception handling\r\n}\r\n \r\n// 可中断，等待获取锁的过程中线程线程可被中断\r\ntry {\r\n  lock.lockInterruptibly();\r\n  try {\r\n    // your code\r\n  }finally {\r\n    lock.unlock();\r\n  }\r\n} catch (InterruptedException e) {\r\n  // exception handling\r\n}\r\n```\r\n\r\n另外，也可以自定义显式锁BooleanLock来实现，如下\r\n\r\n我们先定义锁的接口(当然，也可以不定义直接写，规范嘛，易拓展和理清思路)\r\n\r\n```\r\nimport java.util.List;\r\nimport java.util.concurrent.TimeoutException;\r\n\r\npublic interface Lock {\r\n    public abstract void lock() throws InterruptedException;\r\n    public abstract void lock(long mills) throws InterruptedException, TimeoutException;\r\n    public abstract void unlock();\r\n    List getBlockThreads();\r\n}\r\n```\r\n\r\n实现了该接口的代码为\r\n\r\n```\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\nimport java.util.concurrent.TimeoutException;\r\nimport static java.lang.Thread.currentThread;\r\n\r\npublic class BooleanLock implements Lock {\r\n    // 当前拥有锁的线程，一般是调用过lock等方法后获得锁的线程\r\n    private Thread currentHasThread;\r\n    // 当前锁是否被获取\r\n    private boolean locked = false;\r\n    // 阻塞的线程列表\r\n    private final List blockedThreads = new ArrayList\u003c\u003e();\r\n    @Override\r\n    public void lock() throws InterruptedException {\r\n        synchronized (this) {\r\n            // 如果当前锁已经被获取且阻塞列表中没有自己，那么将当前线程加入到阻塞列表中，并调用wait方法让当前线程进入阻塞状态等待锁的释放\r\n            while (locked) {\r\n                if (!blockedThreads.contains(currentThread())) {\r\n                    blockedThreads.add(currentThread());\r\n                }\r\n                this.wait();\r\n            }\r\n            // 该线程获得锁之后while判断无效，继续从这里执行\r\n            // 由于当前线程已经获得锁，那么将自身从阻塞列表中移除\r\n            // 并将标记locked设置为true代表自己已经拿到了锁，其余线程想要拿锁只能阻塞等待，然后将当前拥有锁的线程设置为自己\r\n            blockedThreads.remove(currentThread());\r\n            this.locked = true;\r\n            this.currentHasThread = currentThread();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void lock(long mills) throws InterruptedException, TimeoutException {\r\n        synchronized (this) {\r\n            // 如果mills小于0，那么自动调用lock方法处理\r\n            if (mills \u003c= 0) {\r\n                this.lock();\r\n            } else {\r\n                //  经过一系列时间判断之后再决定是否超时放弃获得锁\r\n                long remainingMills = mills;\r\n                long endMills = System.currentTimeMillis() + remainingMills;\r\n                while (locked) {\r\n                    if (remainingMills \u003c= 0) {\r\n                        throw new TimeoutException(\"can not get the lock during \" + mills + \" ms.\");\r\n                    }\r\n                    if (!blockedThreads.contains(currentThread())) {\r\n                        blockedThreads.add(currentThread());\r\n                    }\r\n                    this.wait(remainingMills);\r\n                    remainingMills = endMills - System.currentTimeMillis();\r\n                }\r\n                blockedThreads.remove(currentThread());\r\n                this.locked = true;\r\n                this.currentHasThread = currentThread();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void unlock() {\r\n        synchronized (this) {\r\n            // 如果是自己拿着锁，那么直接将状态设置为true，并通知所有的阻塞线程抢占锁\r\n            if (currentHasThread == currentThread()) {\r\n                this.locked = false;\r\n                this.notifyAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public List getBlockThreads() {\r\n        return Collections.unmodifiableList(blockedThreads);\r\n    }\r\n\r\n}\r\n```\r\n\r\n可以测试一下\r\n\r\n```\r\nimport static java.lang.Thread.currentThread;\r\nimport static java.util.concurrent.ThreadLocalRandom.current;\r\n\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\nimport java.util.stream.IntStream;\r\npublic class BooleanLockTest {\r\n    private final ReentrantLock lock = new ReentrantLock();\r\n    public void syncMethod() {\r\n        lock.lock();\r\n        try {\r\n            int randomInt = current().nextInt(5);\r\n            System.out.println(currentThread() + \"get the lock.\");\r\n            try {\r\n                TimeUnit.SECONDS.sleep(randomInt);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(currentThread() + \"will release the lock monitor.\");\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n    public static void main(String[] args) {\r\n        BooleanLockTest bt = new BooleanLockTest();/*\r\n        for (int i = 0; i \u003c 10; i++) {\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    bt.syncMethod();\r\n                }\r\n            }, \"My-Thread-\" + i).start();\r\n        }*/\r\n        IntStream.range(0, 10).mapToObj(i -\u003e new Thread(bt::syncMethod)).forEach(Thread::start);\r\n    }\r\n}\r\n```\r\n\r\n这是current包内显式锁的测试，也可以改为我们自定义的，如下\r\n\r\n```\r\nimport static java.lang.Thread.currentThread;\r\nimport static java.util.concurrent.ThreadLocalRandom.current;\r\n\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.stream.IntStream;\r\npublic class BooleanLockTest {\r\n    private final Lock lock = new BooleanLock();\r\n    public void syncMethod() throws InterruptedException {\r\n        lock.lock();\r\n        try {\r\n            int randomInt = current().nextInt(5);\r\n            System.out.println(currentThread() + \"get the lock.\");\r\n            try {\r\n                TimeUnit.SECONDS.sleep(randomInt);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(currentThread() + \"will release the lock monitor.\");\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n    public static void main(String[] args) {\r\n        BooleanLockTest bt = new BooleanLockTest();/*\r\n        for (int i = 0; i \u003c 10; i++) {\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    bt.syncMethod();\r\n                }\r\n            }, \"My-Thread-\" + i).start();\r\n        }*/\r\n        IntStream.range(0, 10).mapToObj(i -\u003e new Thread(() -\u003e {\r\n            try {\r\n                bt.syncMethod();\r\n            } catch (InterruptedException e) {\r\n                // TODO Auto-generated catch block\r\n                e.printStackTrace();\r\n            }\r\n        })).forEach(Thread::start);\r\n    }\r\n}\r\n```\r\n\r\n```\r\nThread[Thread-0,5,main]get the lock.\r\nThread[Thread-0,5,main]will release the lock monitor.\r\nThread[Thread-9,5,main]get the lock.\r\nThread[Thread-9,5,main]will release the lock monitor.\r\nThread[Thread-1,5,main]get the lock.\r\nThread[Thread-1,5,main]will release the lock monitor.\r\nThread[Thread-8,5,main]get the lock.\r\nThread[Thread-8,5,main]will release the lock monitor.\r\nThread[Thread-2,5,main]get the lock.\r\nThread[Thread-2,5,main]will release the lock monitor.\r\nThread[Thread-7,5,main]get the lock.\r\nThread[Thread-7,5,main]will release the lock monitor.\r\nThread[Thread-3,5,main]get the lock.\r\nThread[Thread-3,5,main]will release the lock monitor.\r\nThread[Thread-6,5,main]get the lock.\r\nThread[Thread-6,5,main]will release the lock monitor.\r\nThread[Thread-4,5,main]get the lock.\r\nThread[Thread-4,5,main]will release the lock monitor.\r\nThread[Thread-5,5,main]get the lock.\r\nThread[Thread-5,5,main]will release the lock monitor.\r\n```\r\n\r\n`lock()`与`unluck()`的组合就相当于`synchronized`关键字的作用。我们可以看到输出结果是一个释放了锁另一个才能获得锁\r\n\r\n我们再看一下`lock(long mills)`的用法，如下\r\n\r\n```\r\nimport static java.lang.Thread.currentThread;\r\nimport static java.util.concurrent.ThreadLocalRandom.current;\r\n\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\npublic class BooleanLockTest {\r\n    private final Lock lock = new BooleanLock();\r\n    public void syncMethod() throws InterruptedException {\r\n        try {\r\n            lock.lock(1000);\r\n            int randomInt = current().nextInt(10);\r\n            System.out.println(currentThread() + \"get the lock.\");\r\n            try {\r\n                TimeUnit.SECONDS.sleep(randomInt);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(currentThread() + \"will release the lock monitor.\");\r\n        } catch (TimeoutException e1) {\r\n            // TODO Auto-generated catch block\r\n            e1.printStackTrace();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n    public static void main(String[] args) throws InterruptedException {\r\n        BooleanLockTest bt = new BooleanLockTest();\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    bt.syncMethod();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n        Thread t2 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    bt.syncMethod();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n        t1.start();\r\n        TimeUnit.MICROSECONDS.sleep(2);\r\n        t2.start();\r\n       // TimeUnit.MICROSECONDS.sleep(10);\r\n        t2.interrupt();\r\n    }\r\n}\r\n```\r\n\r\n输出如下\r\n\r\n```\r\nThread[Thread-0,5,main]get the lock.\r\njava.lang.InterruptedException\r\n\tat java.lang.Object.wait(Native Method)\r\n\tat BooleanLock.lock(BooleanLock.java:50)\r\n\tat BooleanLockTest.syncMethod(BooleanLockTest.java:10)\r\n\tat BooleanLockTest$2.run(BooleanLockTest.java:42)\r\n\tat java.lang.Thread.run(Unknown Source)\r\nThread[Thread-0,5,main]will release the lock monitor.\r\n```\r\n\r\n我们在启动t1之后让主线程休眠2ms，这样能保证t1先参与CPU竞争，然后启动t2再休眠10ms，保证t2尽快参与CPU竞争，那么我们从输出可以看到主线程中断了t2的信号可以被t2线程接收到，那么自动抛出异常放弃锁不再阻塞。\r\n\r\n以上分别是类似于synchronized的用途和可中断synchronized变体，我们如果去掉主线程对t2的中断指令那么就是可超时线程，如下示例\r\n\r\n```\r\nimport static java.lang.Thread.currentThread;\r\nimport static java.util.concurrent.ThreadLocalRandom.current;\r\n\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\npublic class BooleanLockTest {\r\n    private final Lock lock = new BooleanLock();\r\n    public void syncMethod() throws InterruptedException {\r\n        try {\r\n            lock.lock(1000);\r\n            int randomInt = current().nextInt(10);\r\n            System.out.println(currentThread() + \"get the lock.\");\r\n            try {\r\n                TimeUnit.SECONDS.sleep(randomInt);\r\n            } catch (InterruptedException e) {\r\n                e.printStackTrace();\r\n            }\r\n            System.out.println(currentThread() + \"will release the lock monitor.\");\r\n        } catch (TimeoutException e1) {\r\n            // TODO Auto-generated catch block\r\n            e1.printStackTrace();\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n    public static void main(String[] args) throws InterruptedException {\r\n        BooleanLockTest bt = new BooleanLockTest();\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    bt.syncMethod();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n        Thread t2 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    bt.syncMethod();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            }\r\n        });\r\n        t1.start();\r\n        TimeUnit.MICROSECONDS.sleep(2);\r\n        t2.start();\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nThread[Thread-0,5,main]get the lock.\r\njava.util.concurrent.TimeoutException: can not get the lock during 1000 ms.\r\n\tat BooleanLock.lock(BooleanLock.java:45)\r\n\tat BooleanLockTest.syncMethod(BooleanLockTest.java:10)\r\n\tat BooleanLockTest$2.run(BooleanLockTest.java:42)\r\n\tat java.lang.Thread.run(Unknown Source)\r\nThread[Thread-0,5,main]will release the lock monitor.\r\n```","cover":"/images/java.jpg","link":"thread-safety-and-data-synchronization.html","preview":"\u003cp\u003e如果用synchronized关键字修饰一个方法或者代码块，那么就可以防止因多线程作用共享资源而导致的数据不一致或者线程安全问题，该关键字只会保证其作用的方法或者代码块在同一时间只会被一个线程使用，即被修饰对象只对获得锁的线程可见，其余线程只能阻塞等待锁的释放。\u003c/p\u003e\n","title":"线程安全与数据同步"},{"content":"\r\n\r\n## 一、`sleep()`方法\r\n\r\nsleep()方法的签名如下\r\n\r\n```\r\npublic static void sleep(long millis) throws InterruptedException\r\npublic static void sleep(long millis, int nanos) throws InterruptedException\r\n```\r\n\r\n该方法会使当前线程睡眠millis毫秒后重新进入就绪状态参与CPU竞争，但是需要注意的是该方法即时休眠也不会放弃monitor锁(前提是获得该锁)，示例代码如下\r\n\r\n```\r\npublic class TestMain {\r\n    public static int shareVar = 10;\r\n    public static final Object MUTEX = new Object();\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i \u003c 3; i++) {\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    System.out.println(Thread.currentThread().getName() + \": I will sleep\");\r\n                    synchronized(MUTEX) {\r\n                        try {\r\n                            Thread.sleep(5000);\r\n                        } catch (InterruptedException e) {\r\n                            e.printStackTrace();\r\n                        }\r\n                        System.out.println(Thread.currentThread().getName() + \": \" + (shareVar++));\r\n                    }\r\n                    System.out.println(Thread.currentThread().getName() + \": Finish\");\r\n                } \r\n            }).start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nThread-0: I will sleep\r\nThread-2: I will sleep\r\nThread-1: I will sleep\r\nThread-0: 10\r\nThread-0: Finish\r\nThread-1: 11\r\nThread-1: Finish\r\nThread-2: 12\r\nThread-2: Finish\r\n```\r\n\r\n我们启动了3个线程，每个线程在进入同步代码块后休眠5s，从输出可以看出，线程Thread-0首先获得了调度并首先进入同步代码块，然后休眠。由于获得锁然后休眠的线程是不释放锁的，也就是说一直退出同步代码块之后才会释放锁，那么我们可以确定一定是Thread-0先打印输出10\r\n\r\n需要注意的是一定是获得共享变量所在锁之后睡眠的话才不会释放锁，如果在获得锁之前或者释放锁之后睡眠，那么是不会独占锁的(锁存在的意义是保证数据的一致性),那么对共享变量的操作不会因为谁先睡眠而先操作，还是以CPU调度下哪个线程先进入同步代码块获得锁为准。\r\n\r\n示例如下，第一个线程在获得锁之前就睡眠，那么待苏醒后首先对共享变量操作的不一定是该线程\r\n\r\n```\r\npublic class TestMain {\r\n    public static int shareVar = 10;\r\n    public static final Object MUTEX = new Object();\r\n    public static void main(String[] args) {\r\n        for (int i = 0; i \u003c 3; i++) {\r\n            new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    System.out.println(Thread.currentThread().getName() + \": I will sleep\");\r\n                    try {\r\n                        Thread.sleep(5000);\r\n                    } catch (InterruptedException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                    synchronized(MUTEX) {\r\n                        System.out.println(Thread.currentThread().getName() + \": \" + (shareVar++));\r\n                    }\r\n                    System.out.println(Thread.currentThread().getName() + \": Finish\");\r\n                } \r\n            }).start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nThread-0: I will sleep\r\nThread-2: I will sleep\r\nThread-1: I will sleep\r\nThread-2: 10\r\nThread-2: Finish\r\nThread-1: 11\r\nThread-1: Finish\r\nThread-0: 12\r\nThread-0: Finish\r\n```\r\n\r\n显而易见！\r\n\r\n所以想睡眠独占锁，必须先进入锁再睡眠！\r\n\r\n## 二、`yield()`方法\r\n\r\n该方法会自动让出对CPU的使用权，但是CPU不一定受理，即不一定有作用，如果CPU资源不紧张，那么就会忽略这种提醒。\r\n\r\n由于是让出CPU使用权，所以该方法的调用会使当前线程从RUNNING状态(运行状态)切换到RUNNABLE状态(就绪状态)。\r\n\r\n## 三、`yield()`方法与`sleep()`方法的比较\r\n\r\n在JDK1.5之前的版本，yield()方法实际上是调用了sleep(0)方法，即让当前线程休眠0毫秒直接进入就绪队列，那么很自然地就是将CPU控制权交给了下一个线程，但是二者其实存在着本质的差别：\r\n\r\n+ `sleep()`方法会导致当前线程暂停指定时间，没有CPU时间片的消耗；\r\n+ `yield()`方法只是对CPU调度器的一个提示，如果CPU调度器没有忽略这个提示，那么就会导致线程上下文的切换(即切换到下一个线程，本线程让出CPU控制权)；\r\n+ `sleep()`会导致线程短暂的block，会在给定时间内释放CPU资源；\r\n+ `yield()`会使线程由运行状态进入就绪状态，前提是CPU没有忽略这个提示；\r\n+ `sleep()`方法几乎百分百完成了给定时间的休眠，但是`yield()`则不一定；\r\n+ 一个线程`sleep()`，另一个线程调用`interrupt()`会捕捉到中断信号，而`yield()`不会。\r\n\r\n## 四、设置线程的优先级\r\n\r\n```\r\npublic final void setPrioity(int newPrioity); //设置线程优先级\r\npublic final int getPrioity() //获取线程优先级\r\n```\r\n\r\n线程优先级是一个1-10的int型数字，默认为5，数字越大优先级越高，但是因平台的差异性，优先级不可过分依赖，平台可能会忽视优先级。\r\n\r\n```\r\npublic class TestMain {\r\n    public static int shareVar = 10;\r\n    public static final Object MUTEX = new Object();\r\n    public static void main(String[] args) {\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                int i = 0;\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread());\r\n                    i++;\r\n                }\r\n            }\r\n        }, \"t1\");\r\n        Thread t2 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                int i = 0;\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread());\r\n                    i++;\r\n                }\r\n            }\r\n        }, \"t2\");\r\n        t1.setPriority(1);\r\n        t2.setPriority(10);\r\n        t1.start();\r\n        t2.start();\r\n    }\r\n}\r\n```\r\n\r\n以上代码设置t1线程的优先级为1，t2的优先级为10，按理说，t2的输出次数应该高于t1，但是实际情况并不是这样，可能就是平台忽视了优先级，我的平台为win8\r\n\r\n## 五、线程interrupt\r\n\r\n共有以下三个方法\r\n\r\n```\r\npublic void interrupt()\r\npublic static boolean interrupted()\r\npublic boolean isInterrupted()\r\n```\r\n\r\ninterrupt()方法可以打断以下方法调用引起的线程阻塞\r\n\r\n```\r\nObject的wait方法；\r\nObject的wait(long)方法；\r\nObject的wait(long, int)方法；\r\nThread的sleep(long)方法；\r\nThread的sleep(long, int)方法；\r\nThread的join方法；\r\nThread的join(long)方法；\r\nThread的join(long, int)方法；\r\nInterruptibleChannel的io操作；\r\nSelector的wakeup方法\r\n其它方法。\r\n```\r\n\r\n上述方法的执行都会使线程进入阻塞状态，若另外一个线程调用被阻塞线程的interrupt方法时就会打断这种阻塞。一个线程在阻塞情况下被打断都会抛出一个TnterruptedException的异常，这个异常就像一个信号一样通知当前线程被打断了。\r\n\r\n示例如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    public static int shareVar = 10;\r\n    public static final Object MUTEX = new Object();\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                long start = System.currentTimeMillis();\r\n                System.out.println(\"SubThread : I will sleep 1 minutes\");\r\n                try {\r\n                    TimeUnit.MINUTES.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    System.out.println(\"oh, I am be interrupted\");\r\n                }\r\n                if (System.currentTimeMillis() - start \u003c= 60000) {\r\n                    System.out.println(\"SubThread : I wake up, oh, I didn't sleep enough. I was sleepy.\");\r\n                } else {\r\n                    System.out.println(\"SubThread : I wake up, oh, I've had enough sleep.\");\r\n                }\r\n            }\r\n        }, \"t1\");\r\n        t1.start();\r\n        TimeUnit.MICROSECONDS.sleep(2);\r\n        t1.interrupt();\r\n    }\r\n}\r\n```\r\n\r\n线程t1在运行时打算睡眠1分钟，在t1启动后，先将主线程休眠2毫秒，这是为了让t1线程处于就绪状态，然后主线程调用t1的interrupt方法打断睡眠，强制叫醒了t1线程，输出为\r\n\r\n```\r\nSubThread : I will sleep 1 minutes\r\noh, I am be interrupted\r\nSubThread : I wake up, oh, I didn't sleep enough. I was sleepy.\r\n```\r\n\r\n`isInterrupted`用于判断当前线程是否被中断，那我们就可以如下改造上述程序\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    public static int shareVar = 10;\r\n    public static final Object MUTEX = new Object();\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                long start = System.currentTimeMillis();\r\n                System.out.println(\"SubThread : I will sleep 1 minutes\");\r\n                try {\r\n                    TimeUnit.MINUTES.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    System.out.println(\"oh, I am be interrupted\");\r\n                }\r\n                if (System.currentTimeMillis() - start \u003c= 60000) {\r\n                    System.out.println(\"SubThread : I wake up, oh, I didn't sleep enough. I was sleepy.\");\r\n                } else {\r\n                    System.out.println(\"SubThread : I wake up, oh, I've had enough sleep.\");\r\n                }\r\n            }\r\n        }, \"t1\");\r\n        t1.start();\r\n        TimeUnit.MICROSECONDS.sleep(2);\r\n        if (!t1.isInterrupted()) {\r\n            t1.interrupt();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n有同样的输出，主线程判断t1线程时候被中断，如果被中断则什么也不干，如果没有则中断它，把它从睡眠中叫醒进入进入就绪状态，实际上sleep会捕获到interrupt的中断信号，从而就会擦除interrupt标识，什么意思呢？就是一个线程被interrupt中断一次，那么其isInterrupted为true，如果被sleep捕获的话(即该线程中有sleep方法被interrupt中断)，sleep被苏醒后就会擦除掉isInterrupted标识，即为false，这样就能保证下次能够合理的中断(控制)，演示如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    public static int shareVar = 10;\r\n    public static final Object MUTEX = new Object();\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                long start = System.currentTimeMillis();\r\n                System.out.println(\"SubThread : I will sleep 1 minutes\");\r\n                try {\r\n                    TimeUnit.MINUTES.sleep(1);\r\n                } catch (InterruptedException e) {\r\n                    System.out.println(\"oh, I am be interrupted\");\r\n                }\r\n                if (System.currentTimeMillis() - start \u003c= 60000) {\r\n                    System.out.println(\"SubThread : I wake up, oh, I didn't sleep enough. I was sleepy.\");\r\n                } else {\r\n                    System.out.println(\"SubThread : I wake up, oh, I've had enough sleep.\");\r\n                }\r\n            }\r\n        }, \"t1\");\r\n        t1.start();\r\n        System.out.println(t1.isInterrupted());\r\n        TimeUnit.MICROSECONDS.sleep(2);\r\n        t1.interrupt();\r\n        System.out.println(t1.isInterrupted());\r\n        System.out.println(t1.isInterrupted());\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nfalse\r\nSubThread : I will sleep 1 minutes\r\nfalse\r\noh, I am be interrupted\r\nSubThread : I wake up, oh, I didn't sleep enough. I was sleepy.\r\nfalse\r\n```\r\n\r\n在`t1.interrupt()`方法执行之前输出为false可以理解，在该方法执行之后还输出false，这是因为在sleep擦除掉了该标识。当然了，如果没有sleep方法在t1线程中，直接中断也就意味着该标识不会被擦除，演示如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    public static int shareVar = 10;\r\n    public static final Object MUTEX = new Object();\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    //System.out.println(\"I am t1 Thread, \" + isInterrupted());\r\n                }\r\n            }\r\n        }, \"t1\");\r\n        t1.setDaemon(true);\r\n        t1.start();\r\n        TimeUnit.MICROSECONDS.sleep(2);\r\n        System.out.println(\"Thread is interrupted? \" + t1.isInterrupted());\r\n        t1.interrupt();\r\n        System.out.println(\"Thread is interrupted? \" + t1.isInterrupted());\r\n        System.out.println(\"Thread is interrupted? \" + t1.isInterrupted());\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nThread is interrupted? false\r\nThread is interrupted? true\r\nThread is interrupted? true\r\n```\r\n\r\n可以看出，中断标识并没有被擦除。\r\n\r\n`interrupted()`方法是一个静态方法，也就意味着可以在run方法中通过Thread调用，与isInterrupted()不同的是，isInterrupted()方法会因是否有sleep方法而被是否擦除标识，interrupted方法在run中调用会直接擦除标识，演示如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    public static int shareVar = 10;\r\n    public static final Object MUTEX = new Object();\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (true) {\r\n                    System.out.println(Thread.interrupted());\r\n                }\r\n            }\r\n        }, \"t1\");\r\n        t1.setDaemon(true);\r\n        t1.start();\r\n        TimeUnit.MICROSECONDS.sleep(2);\r\n        t1.interrupt();\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n...\r\nfalse\r\nfalse\r\nfalse\r\ntrue\r\nfalse\r\nfalse\r\n...\r\n```\r\n\r\n即很多次输出中只有一个true，这个true就是被主线程调用t1的interrupt方法之后输出的，但随后被Thread.interrupted()方法直接擦除掉了标识，所以输出为false\r\n\r\n## 六、join()方法\r\n\r\njoin与sleep一样，会被interrupt中断，同样也会擦除interrupt标识。join某个线程之后，当前线程会进入阻塞状态(比如main线程执行t1.join()方法，那么main线程进入阻塞状态，直至t1线程执行完毕或者被其余线程中断或者时间到main线程才会进入就绪状态)，测试如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread t1 = new Thread(new Runnable() {\r\n            int i = 0;\r\n            @Override\r\n            public void run() {\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread() + \" : \" + (i++));\r\n                }\r\n            }\r\n        }, \"t1\");\r\n        Thread t2 = new Thread(new Runnable() {\r\n            int i = 0;\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    t1.join();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread() + \" : \" + (i++));\r\n                }\r\n            }\r\n        }, \"t2\");\r\n        t1.start();\r\n        t2.start();\r\n        //t1.join();\r\n        //TimeUnit.MICROSECONDS.sleep(2);\r\n        //t1.interrupt();\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nThread[t1,5,main] : 0\r\nThread[t1,5,main] : 1\r\nThread[t1,5,main] : 2\r\nThread[t1,5,main] : 3\r\nThread[t1,5,main] : 4\r\nThread[t2,5,main] : 0\r\nThread[t2,5,main] : 1\r\nThread[t2,5,main] : 2\r\nThread[t2,5,main] : 3\r\nThread[t2,5,main] : 4\r\n```\r\n\r\n很明显，t2调用`t1.join()`阻塞了自己一直等到t1执行完毕(结束完整声明周期)才执行，如果给join方法加上时间那么输出就又不一样\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread t1 = new Thread(new Runnable() {\r\n            int i = 0;\r\n            @Override\r\n            public void run() {\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread() + \" : \" + (i++));\r\n                }\r\n            }\r\n        }, \"t1\");\r\n        Thread t2 = new Thread(new Runnable() {\r\n            int i = 0;\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    t1.join();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread() + \" : \" + (i++));\r\n                }\r\n            }\r\n        }, \"t2\");\r\n        t1.start();\r\n        t2.start();\r\n        //t1.join();\r\n        //TimeUnit.MICROSECONDS.sleep(2);\r\n        //t1.interrupt();\r\n    }\r\n}\r\n```\r\n\r\n我们让t2阻塞，t1在没有t2竞争CPU的情况下独自占用CPU运行，由于只有1毫秒，5太小看不到预期结果，改为1000，那么运行就会发现1毫秒后t1与t2抢占式交替执行，这是因为t1对CPU的独占在1毫秒后就失效了。\r\n\r\n再看这个\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread t3 = new Thread(new Runnable() {\r\n            int i = 0;\r\n            @Override\r\n            public void run() {\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread() + \" : \" + (i++));\r\n                }\r\n            }\r\n        }, \"t3\");\r\n        Thread t1 = new Thread(new Runnable() {\r\n            int i = 0;\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    t3.join();\r\n                } catch (InterruptedException e) {\r\n                    // TODO Auto-generated catch block\r\n                    e.printStackTrace();\r\n                }\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread() + \" : \" + (i++));\r\n                }\r\n            }\r\n        }, \"t1\");\r\n        Thread t2 = new Thread(new Runnable() {\r\n            int i = 0;\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    t1.join();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread() + \" : \" + (i++));\r\n                }\r\n            }\r\n        }, \"t2\");\r\n        t1.start();\r\n        t2.start();\r\n        t3.start();\r\n        //t1.join();\r\n        //TimeUnit.MICROSECONDS.sleep(2);\r\n        //t1.interrupt();\r\n    }\r\n}\r\n```\r\n\r\nt2把CPU使用权让渡给t1，t1让渡给t3，那么执行顺序就是t3\u003et1\u003et2，如下\r\n\r\n```\r\nThread[t3,5,main] : 0\r\nThread[t3,5,main] : 1\r\nThread[t3,5,main] : 2\r\nThread[t3,5,main] : 3\r\nThread[t3,5,main] : 4\r\nThread[t1,5,main] : 0\r\nThread[t1,5,main] : 1\r\nThread[t1,5,main] : 2\r\nThread[t1,5,main] : 3\r\nThread[t1,5,main] : 4\r\nThread[t2,5,main] : 0\r\nThread[t2,5,main] : 1\r\nThread[t2,5,main] : 2\r\nThread[t2,5,main] : 3\r\nThread[t2,5,main] : 4\r\n```\r\n\r\n我们再改动一下上面的程序，t2将权力让渡给t3，我们让t1调用t3的interrupt方法中断t3，会出现什么情况，如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread t3 = new Thread(new Runnable() {\r\n            int i = 0;\r\n            @Override\r\n            public void run() {\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread() + \" : \" + (i++) + \" \" + Thread.interrupted());\r\n                }\r\n            }\r\n        }, \"t3\");\r\n        Thread t1 = new Thread(new Runnable() {\r\n            int i = 0;\r\n            @Override\r\n            public void run() {\r\n                t3.interrupt();\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread() + \" : \" + (i++));\r\n                }\r\n            }\r\n        }, \"t1\");\r\n        Thread t2 = new Thread(new Runnable() {\r\n            int i = 0;\r\n            @Override\r\n            public void run() {\r\n                try {\r\n                    t3.join();\r\n                } catch (InterruptedException e) {\r\n                    e.printStackTrace();\r\n                }\r\n                while (i \u003c 5) {\r\n                    System.out.println(Thread.currentThread() + \" : \" + (i++));\r\n                }\r\n            }\r\n        }, \"t2\");\r\n        t1.start();\r\n        t2.start();\r\n        t3.start();\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nThread[t1,5,main] : 0\r\nThread[t1,5,main] : 1\r\nThread[t1,5,main] : 2\r\nThread[t1,5,main] : 3\r\nThread[t1,5,main] : 4\r\nThread[t3,5,main] : 0 true\r\nThread[t3,5,main] : 1 false\r\nThread[t3,5,main] : 2 false\r\nThread[t3,5,main] : 3 false\r\nThread[t3,5,main] : 4 false\r\nThread[t2,5,main] : 0\r\nThread[t2,5,main] : 1\r\nThread[t2,5,main] : 2\r\nThread[t2,5,main] : 3\r\nThread[t2,5,main] : 4\r\n```\r\n\r\n可见t1先于t3执行(不一定，但是肯定不是t3独占式运行)，t2最后执行。\r\n\r\n而且可见t3的`Thread.interrupted()`方法第一次检测到标识信号，输出为true，然后擦除掉了，以后输出为false\r\n\r\n## 七、线程的关闭\r\n\r\n线程在生命周期正常结束时就会关闭，即run方法执行完毕后关闭(ru中的循环不算，因为尚未执行完毕)。\r\n\r\n也可以捕获中断信号关闭线程，例如\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    public static void main(String[] args) throws InterruptedException {\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                while (Thread.interrupted()) {\r\n                    \r\n                }\r\n                System.out.println(\"I will exit\");\r\n            }\r\n        }, \"t1\");\r\n        t1.start();\r\n        TimeUnit.MICROSECONDS.sleep(1);\r\n        System.out.println(\"System will be shutdown\");\r\n        t1.interrupt();\r\n    }\r\n}\r\n```\r\n\r\n以上代码通过检测中断标识而中断自己，也是正常生命周期结束的一种变体。\r\n\r\n也可以使用volatile关键字修饰的开关flag来实现，如下\r\n\r\n```\r\nimport java.util.concurrent.TimeUnit;\r\n\r\npublic class TestMain {\r\n    \r\n    static class MyThread extends Thread {\r\n        private volatile boolean closed = false;\r\n        @Override\r\n        public void run() {\r\n            while (!closed \u0026\u0026 !isInterrupted()) {\r\n               \r\n            }\r\n            System.out.println(\"I will exit\");\r\n        }\r\n        public void close() {\r\n            this.closed = true;\r\n            this.interrupt();\r\n        }\r\n    }\r\n    \r\n    public static void main(String[] args) throws InterruptedException {\r\n        MyThread mt = new MyThread();\r\n        mt.start();\r\n        TimeUnit.MICROSECONDS.sleep(1);\r\n        System.out.println(\"System will be shutdown\");\r\n        //do something\r\n        mt.close();\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nSystem will be shutdown\r\nI will exit\r\n```\r\n\r\n注意，本文的代码中可能含有没有用途的变量或者方法，忘记删除，需要读者甄别。","cover":"/images/java.jpg","link":"thread-api-detailed-introduction.html","preview":"\u003cp\u003esleep()、yield()、设置线程的优先级、线程interrupt、join()方法以及线程的关闭。\u003c/p\u003e\n","title":"Thread API详细介绍"},{"content":"\r\n\r\n## 一、线程的名称\r\n\r\n线程可以通过当前线程的getName()方法获取该线程在运行期间唯一的名称，如下\r\n\r\n```\r\npublic class TestMain {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(Thread.currentThread().getName());\r\n        for (int i = 0; i \u003c 3; i++) {\r\n            Thread thread = new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    System.out.println(Thread.currentThread().getName());\r\n                }\r\n            });\r\n            thread.start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n我们启动了三个线程，线程的逻辑写在run方法之内，目的是输出线程name，输出为\r\n\r\n```\r\nmain\r\nThread-0\r\nThread-1\r\nThread-2\r\n```\r\n\r\ngetId()方法也可以获得线程的Id，与getName使用方法一样\r\n\r\n## 二、线程的命名\r\n\r\n我们也可以自定义线程的名称，这便于我们监控线程的执行状态和排错，方法就是在Thread类的第二个参数设置名称，在run方法内通过Thread.currentThread()方法来获取，如下\r\n\r\n```\r\npublic class TestMain {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(Thread.currentThread().getName());\r\n        for (int i = 0; i \u003c 3; i++) {\r\n            Thread thread = new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    System.out.println(Thread.currentThread());\r\n                }\r\n            },\"My Thead-\" + i);\r\n            thread.start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nmain\r\nThread[My Thead-0,5,main]\r\nThread[My Thead-1,5,main]\r\nThread[My Thead-2,5,main]\r\n```\r\n\r\n该构造方法的原型为\r\n\r\n```\r\nThread(Runnable target, String name)\r\n```\r\n\r\n## 三、线程的重新命名\r\n\r\n线程在run之前，还可以修改线程名称，即new之后run之前还可以修改，方式为Thread.setName()方法，这是最后一次修改机会，线程在运行时是不能修改名称的，如下\r\n\r\n```\r\npublic class TestMain {\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(Thread.currentThread().getName());\r\n        for (int i = 0; i \u003c 3; i++) {\r\n            Thread thread = new Thread(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    System.out.println(Thread.currentThread());\r\n                }\r\n            },\"My Thead-\" + i);\r\n            //thread.setName(\"Your Thread+\" + i);\r\n            thread.start();\r\n            thread.setName(\"Your Thread+\" + i);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nmain\r\nThread[Your Thread+0,5,main]\r\nThread[Your Thread+1,5,main]\r\nThread[Your Thread+2,5,main]\r\n```\r\n\r\n## 四、Thread与ThreadGroup\r\n\r\n在Thread的构造函数中，可以显式的指定线程的Group，如果没有显式的指定Group那么该线程就会被假如父线程的Group，Thread设置Group的构造方法为\r\n\r\n```\r\nThread(ThreadGroup group, String name)\r\nThread(ThreadGroup group, Runnable target, String name)\r\nThread(ThreadGroup group, Runnable target, String name, long stackSize)\r\n```\r\n\r\nThreadGroup的构造方法为\r\n\r\n```\r\nThreadGroup group = new ThreadGroup(String groupName)\r\n```\r\n\r\n测试一下\r\n\r\n```\r\npublic class TestMain {\r\n\r\n    public static void main(String[] args) {\r\n        Thread t1 = new Thread(\"t1\");\r\n        ThreadGroup group = new ThreadGroup(\"My Group\");\r\n        Thread t2 = new Thread(group, \"t2\");\r\n        System.out.println(t1.getThreadGroup());    //java.lang.ThreadGroup[name=main,maxpri=10]\r\n        System.out.println(t2.getThreadGroup());    //java.lang.ThreadGroup[name=My Group,maxpri=10]\r\n        System.out.println(t1.getThreadGroup() == group);   //false\r\n        System.out.println(t2.getThreadGroup() == group);   //true\r\n        System.out.println(Thread.currentThread().getThreadGroup() == group);   //false\r\n        \r\n    }\r\n}\r\n```\r\n\r\n## 五、Thread与Runnable的区别\r\n\r\n二者看似都可以创建线程，但是二者其实是有区别的，区别就是Thread负责线程本身相关职责和控制，Runnable负责线程逻辑执行单元部分。上述例子已经很好的说明了这一点。","cover":"/images/java.jpg","link":"deep-understanding-of-thread-class-constructors.html","preview":"\u003cp\u003e由于线程有自己的程序计数器、局部变量表和操作数栈，那么也就意味着每实例化一个继承了Thread的类或者实现了Runnable接口的类，就意味着创建了一个对象，这些都是线程私有的，也就无法对变量实现共享。\u003c/p\u003e\n","title":"深入理解Thread类构造函数"},{"content":"\r\n\r\n由于线程有自己的程序计数器、局部变量表和操作数栈，那么也就意味着每实例化一个继承了Thread的类或者实现了Runnable接口的类，就意味着创建了一个对象，这些都是线程私有的，也就无法对变量实现共享。\r\n\r\n想共享变量，即变量在多个实例访问的情况下仍然是唯一的(指的是只有这一个变量，不会因new关键字而产生对象的变量)，在多线程并发的情况下有两种方式实现：\r\n\r\n+ 第一种是，使用类变量。这种变量存在于方法区中，由线程共享，每个方法或者线程都拥有对该线程的访问权，那么就能够实现变量共享的需求。\r\n+ 第二种是，让线程使用同一个Runnable接口，这样他们的资源仍然是共享的。\r\n\r\n如下，示例一个叫号机程序，每天放号50个，共有四台出号机，也就意味着共有四个线程，即四个线程对共享变量进行操作，该共享变量就是号数，小于等于50，先用第一种方式来实现\r\n\r\n由于50比较大，不好输出结果，不妨改为10\r\n\r\n```\r\npublic class TicketWindow extends Thread {\r\n    private final String name;\r\n    private static int num = 1;\r\n    private static final int maxNum = 10;\r\n    public TicketWindow(String name) {\r\n        this.name = name;\r\n    }\r\n    @Override\r\n    public void run() {\r\n        while (num \u003c= maxNum) {\r\n            System.out.println(\"Window:\" + name + \" current number is \" + (num++));\r\n        }\r\n    }\r\n}\r\n\r\npublic class TicketWindowMain {\r\n\r\n    public static void main(String[] args) {\r\n        TicketWindow tw1 = new TicketWindow(\"First\");\r\n        TicketWindow tw2 = new TicketWindow(\"Second\");\r\n        TicketWindow tw3 = new TicketWindow(\"Third\");\r\n        tw1.start();\r\n        tw2.start();\r\n        tw3.start();\r\n        \r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nWindow:Second current number is 1\r\nWindow:Third current number is 2\r\nWindow:First current number is 1\r\nWindow:Third current number is 4\r\nWindow:Second current number is 3\r\nWindow:Third current number is 6\r\nWindow:First current number is 5\r\nWindow:Third current number is 8\r\nWindow:Second current number is 7\r\nWindow:Third current number is 10\r\nWindow:First current number is 9\r\n```\r\n\r\n事实上，每次执行的结果是不一样的，可以看到1被抽了两次，这是因为变量num的访问不是原子的，对num的操作分为两步，第一步是先读num，然后再加1；当Second线程读取了num之后还没来得及加1就丧失了CPU的使用权，被First线程获取到了CPU使用权，因为First仍然拿到了1，此时正常加1，但是为什么2会比1输出早呢？因为加1之后才会输出，First线程加1之后又丧失了CPU使用权，被调度到Third线程，Third线程完成了所有步骤。\r\n\r\n可见，此方式虽然实现了对共享变量的访问，但是对共享变量的操作不是原子的，存在线程安全问题(即一个线程状态对另一个线程会产生影响)。\r\n\r\n可见，线程不安全的问题主要产生在共享变量num身上，即对其操作不原子，如果我们用synchronized关键字修饰涉及对共享变量操作的代码块或者方法，那么就相当于锁住了共享变量，在一个线程访问共享变量开始就对共享变量加锁，一直到对共享变量的访问结束(而不是线程结束)才会释放锁，期间其它线程想要获得锁只能等待，处于阻塞状态，当该线程释放锁，那么下一个排队的线程就会拿到锁而进入就绪状态等待CPU调度。\r\n\r\n还有第二种方法，即多个线程使用相同的Runnable接口，如下\r\n\r\n```\r\npublic class TicketWindow implements Runnable {\r\n    private int num = 1;\r\n    private final int maxNum = 10;\r\n    @Override\r\n    public void run() {\r\n        while (num \u003c= maxNum) {\r\n            System.out.println(Thread.currentThread() + \" current number is \" + (num++));\r\n        }\r\n    }\r\n}\r\n\r\npublic class TicketWindowMain {\r\n\r\n    public static void main(String[] args) {\r\n        TicketWindow tw = new TicketWindow();\r\n        Thread t1 = new Thread(tw, \"First\");\r\n        Thread t2 = new Thread(tw, \"Second\");\r\n        Thread t3 = new Thread(tw, \"Third\");\r\n        t1.start();\r\n        t2.start();\r\n        t3.start();\r\n        \r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nThread[Second,5,main] current number is 2\r\nThread[First,5,main] current number is 2\r\nThread[Third,5,main] current number is 1\r\nThread[First,5,main] current number is 4\r\nThread[Second,5,main] current number is 3\r\nThread[First,5,main] current number is 6\r\nThread[Third,5,main] current number is 5\r\nThread[First,5,main] current number is 8\r\nThread[Second,5,main] current number is 7\r\nThread[First,5,main] current number is 10\r\nThread[Third,5,main] current number is 9\r\n```\r\n\r\n和第一种方法一样，虽然实现了对共享变量的访问，但是还是线程不安全，明明十次但是却有十一个输出，总之会产生各种各样的问题。对关键代码块加`synchronized`关键字即可解决问题\r\n\r\n```\r\npublic class TicketWindow implements Runnable {\r\n    private int num = 1;\r\n    private static final int maxNum = 10;\r\n    private static final Object MUTEX = new Object();\r\n    @Override\r\n    public void run() {\r\n        while (num \u003c= maxNum) {\r\n            synchronized(MUTEX) {\r\n                System.out.println(Thread.currentThread() + \" current number is \" + (num++));\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n主文件不变，结果为\r\n\r\n```\r\nThread[First,5,main] current number is 1\r\nThread[First,5,main] current number is 2\r\nThread[First,5,main] current number is 3\r\nThread[First,5,main] current number is 4\r\nThread[First,5,main] current number is 5\r\nThread[Third,5,main] current number is 6\r\nThread[Third,5,main] current number is 7\r\nThread[Third,5,main] current number is 8\r\nThread[Third,5,main] current number is 9\r\nThread[Third,5,main] current number is 10\r\nThread[Second,5,main] current number is 11\r\nThread[First,5,main] current number is 12\r\n```\r\n\r\n**synchronized关键字的粒度应该尽可能小**，因为粒度越大效率越低越不能发挥出多线程并发的优势，因为对非共享资源加锁本身就是资源的浪费。比如锁加在while循环外面的话，那么就会出现一个线程从头到尾的执行的现象，这是因为，锁中的代码执行完毕之后该线程才会释放锁其余线程才有机会拿到锁，锁中是while循环，那么也就意味着while循环执行完毕才会释放锁，由于三个线程用一个实现了Runnable接口的类，所以共享变量达到要求之后就会线程终止，那么其余线程就没机会执行。\r\n\r\n但是不是应该输出到10吗，怎么到了12？这可能是因为Third线程再获得锁之后(修改num之前)丧失了CPU使用权，此后Second线程与First线程看到自身条件仍然满足(10 \u003c= 10),只是拿不到锁无法进一步操作，但是等Third线程操作完成释放锁之后他们就继续操作，因为他们已经判断过了while条件，他们的程序计数器记得，所以直接拿到锁输出。\r\n\r\n这就简单了，让他们拿到锁之后再判断一次，重新看一下num的值是否符合条件，如下\r\n\r\n```\r\npublic class TicketWindow implements Runnable {\r\n    private int num = 1;\r\n    private static final int maxNum = 10;\r\n    private static final Object MUTEX = new Object();\r\n    @Override\r\n    public void run() {\r\n        while (num \u003c= maxNum) {\r\n            synchronized(MUTEX) { \r\n                if (num \u003c= maxNum) { \r\n                    System.out.println(Thread.currentThread() + \" current number is \" + (num++)); \r\n                } \r\n            } \r\n        } \r\n    } \r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nWindow:First current number is 1\r\nWindow:Third current number is 2\r\nWindow:Third current number is 3\r\nWindow:Third current number is 4\r\nWindow:Third current number is 5\r\nWindow:Third current number is 6\r\nWindow:Third current number is 7\r\nWindow:Third current number is 8\r\nWindow:Third current number is 9\r\nWindow:Third current number is 10\r\n```\r\n\r\n问题解决！\r\n\r\n两种方法的区别在于static修饰的变量和方法随类的生存而生存，生命周期很长，所以尽可能使用实现了Runnable接口的办法。\r\n\r\n----------2018-12-21 17：29 更新----------\r\n\r\n还有一种办法就是使用相同的类实例，让多线程调用相同的类实例方法来实现，如下(没加锁，需要注意)\r\n\r\n```\r\npublic class TicketWindow {\r\n    private int num = 1;\r\n    private final int maxNum = 10;\r\n    public void run() {\r\n        while (num \u003c= maxNum) {\r\n            System.out.println(Thread.currentThread() + \" current number is \" + (num++));\r\n        }\r\n    }\r\n}\r\npublic class TicketWindowMain {\r\n\r\n    public static void main(String[] args) {\r\n        TicketWindow tw = new TicketWindow();\r\n        Thread t1 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                tw.run();\r\n            }\r\n            \r\n        }, \"First\");\r\n        Thread t2 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                tw.run();\r\n            }\r\n            \r\n        },\"Second\");\r\n        Thread t3 = new Thread(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                tw.run();\r\n            }\r\n            \r\n        },\"Third\");\r\n        t1.start();\r\n        t2.start();\r\n        t3.start();\r\n        \r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nThread[Second,5,main] current number is 2\r\nThread[Third,5,main] current number is 3\r\nThread[First,5,main] current number is 1\r\nThread[Third,5,main] current number is 5\r\nThread[Second,5,main] current number is 4\r\nThread[Third,5,main] current number is 7\r\nThread[First,5,main] current number is 6\r\nThread[Third,5,main] current number is 9\r\nThread[Second,5,main] current number is 8\r\nThread[First,5,main] current number is 10\r\n```","cover":"/images/java.jpg","link":"sharing-variables-and-synchronized-keyword-among-threads-to-solve-thread-insecurity.html","preview":"\u003cp\u003e由于线程有自己的程序计数器、局部变量表和操作数栈，那么也就意味着每实例化一个继承了Thread的类或者实现了Runnable接口的类，就意味着创建了一个对象，这些都是线程私有的，也就无法对变量实现共享。\u003c/p\u003e\n","title":"线程间共享变量与synchronized关键字解决线程不安全问题"},{"content":"\r\n\r\n## 一、Java线程的两种创建方式\r\n\r\n### 1.1 继承Thread类\r\n\r\n其步骤为继承Thread类并重写run方法，创建对象并调用start方法\r\n\r\n```\r\npublic class HelloThread extends Thread {\r\n    @Override\r\n    public void run() {\r\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \":hello\");\r\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + Thread.currentThread().getState());\r\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + Thread.currentThread().isAlive());\r\n    }\r\n    \r\n    public static void main(String[] args) throws InterruptedException {\r\n        for (int i = 0; i \u003c 3; i++) {\r\n            HelloThread thread = new HelloThread();\r\n            thread.start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n1545129625507,Thread-2:hello\r\n1545129625508,Thread-4:hello\r\n1545129625509,Thread-4RUNNABLE\r\n1545129625509,Thread-4true\r\n1545129625508,Thread-2RUNNABLE\r\n1545129625509,Thread-2true\r\n1545129625507,Thread-3:hello\r\n1545129625509,Thread-3RUNNABLE\r\n1545129625509,Thread-3true\r\n```\r\n\r\n我们启动了三个线程，他们是并发执行的，可以看出，它们几乎是在同时执行的。执行顺序并不确定，线程接收CPU的调度。\r\n\r\n### 1.2 实现Runnable接口\r\n\r\n```\r\npublic class HelloThread implements Runnable {\r\n    @Override\r\n    public void run() {\r\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + \":hello\");\r\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + Thread.currentThread().getState());\r\n        System.out.println(System.currentTimeMillis() + \",\" + Thread.currentThread().getName() + Thread.currentThread().isAlive());\r\n    }\r\n    \r\n    public static void main(String[] args) throws InterruptedException {\r\n        for (int i = 0; i \u003c 3; i++) {\r\n            Thread thread = new Thread(new HelloThread());\r\n            thread.start();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n1545129841418,Thread-0:hello\r\n1545129841418,Thread-2:hello\r\n1545129841418,Thread-1:hello\r\n1545129841418,Thread-2RUNNABLE\r\n1545129841418,Thread-1RUNNABLE\r\n1545129841418,Thread-0RUNNABLE\r\n1545129841418,Thread-1true\r\n1545129841418,Thread-2true\r\n1545129841418,Thread-0true\r\n```\r\n\r\n## 二、Java线程的生命周期\r\n\r\n![](https://cdn.nlark.com/yuque/0/2019/png/257195/1549874605826-e2982cd9-d892-4ef4-8534-559191202b0a.png#align=left\u0026display=inline\u0026height=244\u0026name=%E4%B8%8B%E8%BD%BD.png\u0026originHeight=316\u0026originWidth=966\u0026size=30900\u0026width=746)\r\n\r\n\u003e 图片来源于：[https://www.cnblogs.com/sunddenly/p/4106562.html](https://www.cnblogs.com/sunddenly/p/4106562.html)\r\n\r\n1. 新建状态：使用new关键字创建一个线程对象，那么就处于新建状态；\r\n1. 就绪状态：\r\n  1. 调用start方法进入就绪状态，在就绪队列中等待CPU调度；\r\n  1. 当时间片到或者调用yield方法让出CPU使用权时重新进入就绪队列等待CPU调度；\r\n1. 运行状态：运行状态当获得CPU调度，执行run方法时，就进入运行状态；\r\n1. 阻塞状态：当调用sleep方法(睡眠时间到，进入就绪状态)、IO阻塞(线程调用的阻塞式IO方法已经返回,线程进入就绪状态)、等待同步锁(线程成功地获得了试图取得的同步监视器,进入就绪状态)、等待通知(线程正在等待某个通知时，其他线程发出了个通知，线程进入就绪状态)和suspend(处于挂起状态的线程被调甩了resdme()恢复方法,进入就绪状态)时进入阻塞状态；\r\n1. 死亡状态：线程执行完毕(run()或call()方法执行完成)、调用stop方法(该方法容易导致死锁，通常不推荐使用)、线程抛出一个未捕获的Exception或Error,都会使线程死亡\r\n\r\n需要注意的是以下方法已经过时，应该尽可能减少使用\r\n\r\n```\r\npublic final void stop()\r\npublic final void suspend()\r\npublic final void resume()\r\n```","cover":"/images/java.jpg","link":"review-the-creation-and-life-cycle-of-java-threads.html","preview":"\u003cp\u003eJava线程的两种创建方式与线程的生命周期。\u003c/p\u003e\n","title":"复习Java线程的创建与其生命周期"},{"content":"\r\n\r\n数组的Arrays类有很多有用的功能，看一下\r\n\r\n## toString方法\r\n\r\n如果我们想直接输出整个数组，如果我们像下面这样的话得到的只是数组的内存地址，而Arrays.toString()方法得到的就是预期结果\r\n\r\n```\r\nimport java.util.Arrays;\r\n\r\npublic class ArraysTest {\r\n\r\n    public static void main(String[] args) {\r\n        int[] array = {2， 3， 1};\r\n        System.out.println(array);  //[I@15db9742\r\n        System.out.println(Arrays.toString(array)); //[1, 2, 3]\r\n    }\r\n\r\n}\r\n```\r\n\r\n## sort方法\r\n\r\n对于除boolean类型外的数组，Arrays均提供了排序方法\r\n\r\nint型数组从小到大排序为\r\n\r\n```\r\nimport java.util.Arrays;\r\n\r\npublic class ArraysTest {\r\n\r\n    public static void main(String[] args) {\r\n        int[] array = {1, 2, 3};\r\n        Arrays.sort(array);\r\n        System.out.println(Arrays.toString(array)); //[1, 2, 3]\r\n    }\r\n\r\n}\r\n```\r\n\r\nString型数组的排序为\r\n\r\n```\r\nimport java.util.Arrays;\r\n\r\npublic class ArraysTest {\r\n\r\n    public static void main(String[] args) {\r\n        String[] str = {\"Feily\", \"Zhang\", \"Haoyue\", \"Li\", \"hello\", \"world\"};\r\n        Arrays.sort(str);\r\n        System.out.println(Arrays.toString(str)); //[Feily, Haoyue, Li, Zhang, hello, world]\r\n    }\r\n\r\n}\r\n```\r\n\r\n是按照首字母的ASCII码int值排序的，由于大些字母的ASCII码小于小写，所以在前面，如果排序像忽略大小写，那么如下\r\n\r\n```\r\nimport java.util.Arrays;\r\n\r\npublic class ArraysTest {\r\n\r\n    public static void main(String[] args) {\r\n        String[] str = {\"Feily\", \"Zhang\", \"Haoyue\", \"Li\", \"hello\", \"world\"};\r\n        Arrays.sort(str, String.CASE_INSENSITIVE_ORDER);\r\n        System.out.println(Arrays.toString(str)); //[Feily, Haoyue, hello, Li, world, Zhang]\r\n    }\r\n\r\n}\r\n```\r\n\r\n## binarySearch()方法\r\n\r\n```\r\nimport java.util.Arrays;\r\n\r\npublic class ArraysTest {\r\n\r\n    public static void main(String[] args) {\r\n        int[] arr = {5, 3, 1, 4, 2};\r\n        String[] str = {\"Feily\", \"Zhang\", \"Haoyue\", \"Li\", \"hello\", \"world\"};\r\n        System.out.println(Arrays.binarySearch(str, \"Li\")); //3\r\n        Arrays.sort(arr);\r\n        System.out.println(Arrays.binarySearch(str, \"hello\")); //4\r\n        System.out.println(Arrays.binarySearch(arr, 5));    //-6\r\n        Arrays.sort(arr);\r\n        System.out.println(Arrays.binarySearch(arr, 5));    //4\r\n    }\r\n\r\n}\r\n```\r\n在二分查找整形数组时一定要保证元素有序，否则不会达到预期效果，字符串数组的话应该都可以。如果找不到指定的元素，那么就会返回负数，负数等于插入点+1，插入点指的是在这个位置插入没找到的元素仍然可以保证数组有序。","cover":"/images/java.jpg","link":"analysis-of-arrays-classes.html","preview":"\u003cp\u003etoString方法, sort方法, binarySearch()方法。\u003c/p\u003e\n","title":"Arrays类的相关用法"},{"content":"\r\n\r\nString类适合少量字符串的不太频繁的操作，因为String的每次的字符串操作基本上都是重新创建一个字符数组，这样性能太低，很多时候我们需要兼顾性能，能不能直接在字符串上 操作而不是拷贝到另一个字符数组再操作？\r\n\r\n答案就是用StringBuilder或者StringBuffer，这两个类的方法基本上都是一样的实现的代码也几乎一样，唯一不同的地方在于StringBuffer是线程安全的，而StringBuilder是线程不安全的。线程安全的成本就是性能耗损，所以在不存在线程安全的情况下StringBuilder处理大量字符串无疑是首选\r\n\r\n## 基本用法\r\n\r\n创建StringBuilder对象\r\n\r\n```\r\nStringBuilder ab = new StringBuilder();\r\nsb.append(String str);\r\n```\r\n\r\n然后通过toString获取字符串\r\n\r\n```\r\nSystem.out.println(sb.toString());\r\n```\r\n\r\n## 基本实现原理\r\n\r\nStringBuilder内部仍然是基于字符数组，但是该字符数组不是final的，是可以修改的，与String不同的是，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数,该实例变量如下定义\r\n\r\n```\r\nint count;\r\n```\r\n\r\nStringBuilder继承自AbstractStringBuilder，它的默认构造方法是\r\n\r\n```\r\npublic StringBuilder() {\r\n    super(16);\r\n}\r\n```\r\n\r\n即调用父类的构造方法，其父类的构造方法为\r\n\r\n```\r\nAbstractStringBuilder(int capacity) {\r\n    value = new cahr[capacity];\r\n}\r\n```\r\n\r\n即创建一个容量为16的字符数组。\r\n\r\nappend方法的实现为\r\n\r\n```\r\npublic AbstractStringBuilder append(String str) {\r\n    if (str == null) str = \"null\";\r\n    int len = str.length;\r\n    ensureCapacityInternal(count + len);\r\n    str.getChars(0, len, value, count);\r\n    count += len;\r\n    return this;\r\n}\r\n```\r\n\r\n可见，append会直接复制字符到内部的字符数组中，如果字符数组的长度不够，那么会进行拓展，并增加实际使用的长度。\r\n\r\ntoString方法的实现为\r\n\r\n```\r\npublic String toString() {\r\n    return new String(value, o, count);\r\n}\r\n```\r\n\r\n即直接将字符数组转化为字符串。\r\n\r\n## String的+和+=运算符\r\n\r\nString的+和+=运算符，是Java编译器提供的支持，但是背后会转化为StringBuilder的append方法，所以在大量且频繁的字符串操作时应该尽量避免使用String的+和+=运算符，性能比较低。","cover":"/images/java.jpg","link":"analysis-of-stringbuilder-classes.html","preview":"\u003cp\u003eString类适合少量字符串的不太频繁的操作，因为String的每次的字符串操作基本上都是重新创建一个字符数组，这样性能太低，可以考虑使用StringBuilder或者StringBuffer。\u003c/p\u003e\n","title":"剖析StringBuilder类"},{"content":"\r\n\r\nString类的常用方法：\r\n\r\n```\r\npublic boolean isEmpty()\r\npublic int length\r\npublic String subString(int beginIndex)\r\npublic String subString(int beginIndex, int endIndex)\r\npublic int indexOf(char c)\r\npublic int indexOf(String str)\r\npublic int lastIndexOf(char c)\r\npublic int lattIndexOf(String str)\r\npublic boolean contains(CharSequence s)\r\npublic boolean startsWith(String str)\r\npublic boolean endsWith(String str)\r\npublic boolean equals(Object obj)\r\npublic boolean equalsIgnoreCase(String str)\r\npublic int compareTo(String anotherString)\r\npublic int compareToIgnoreCase(String str)\r\npublic String toUpperCase()\r\npublic String toLowerCase()\r\npublic String concat(String str)\r\npublic String replace(char oldChar, char newChar)\r\npublic String replace(CharSequence target, CharSequence replacement)\r\npublic String trim()\r\n```\r\n\r\n## String类的内部\r\n\r\nString类基于char数组，有两个构造方法可以根据char数组创建String变量\r\n\r\n```\r\npublic String(char[] value)\r\npublic String(char[] value, int offset, int count)\r\n```\r\n\r\nString对字符串的操作并不是在字符串或者字符数组本身进行操作，而是创建一个新的char数组然后把内容复制进去再操作\r\n\r\nJava使用Charset类表示各种编码，它有两个常用静态方法\r\n\r\n```\r\npublic static Charset defaultCharset() //获取系统默认编码\r\npublic static Charset forName(String charsetName) //设置编码\r\n```\r\n\r\n## String类的不可变性\r\n\r\n与包装类相似，String类也是不可变类，即对象一旦创建，就无法修改。String类也被声明为final，无法继承，内部的char数组也是final的，一旦初始化就不能再变。这也就是说String内部对字符串进行操作的方法是通过拷贝原有字符串再操作实现的。\r\n\r\n## String常量字符串\r\n\r\nString常量字符串被存放在JVM常量池当中，也就是说就算创建多份相同的常量，实际上这些常量都是引用的同一份JVM常量池的常量，测试一下\r\n\r\n```\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str1 = \"hello,world\";\r\n        String str2 = \"hello,world\";\r\n        System.out.println(str1 == str2); //true\r\n    }\r\n\r\n}\r\n```\r\n\r\n以上定义的是两个常量，由于常量存放在常量池，所以二者的引用是一致的，所以打印true，上面的代码类似于\r\n\r\n```\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str = new String(new char[] {'h','e','l','l','o',',','w','o','r','l','d'});\r\n        String str1 = str;\r\n        String str2 = str;\r\n        System.out.println(str1 == str2);\r\n    }\r\n\r\n}\r\n```\r\n\r\n即实际上只有一个对象，那么当然等于自身\r\n\r\n如果用new创建，那么就不会存放在常量池，而是Java堆，如下\r\n\r\n```\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str1 = new String(\"hello,world\");\r\n        String str2 = new String(\"hello,world\");\r\n        System.out.println(str1 == str2); //false\r\n    }\r\n\r\n}\r\n```\r\n\r\n所以输出为false，因为有两个对象。上面的代码类似于\r\n\r\n```\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str = new String(new char[] {'h','e','l','l','o',',','w','o','r','l','d'});\r\n        String str1 = new String(str);\r\n        String str2 = new String(str);\r\n        System.out.println(str1 == str2);\r\n    }\r\n\r\n}\r\n```\r\n\r\n而String类中以String为参数的构造方法的代码如下\r\n\r\n```\r\npublic String(String str) {\r\n    this.value = str.value;\r\n    this.hash = str.hash;\r\n}\r\n```\r\n\r\nstr1与str2的value值共同指向常量池的同一个常量，但是hash不同，所以二者不同。\r\n\r\n如果用equals方法比较，那么输出为真\r\n\r\n```\r\npublic class StringTest {\r\n\r\n    public static void main(String[] args) {\r\n        String str1 = new String(\"hello,world\");\r\n        String str2 = new String(\"hello,world\");\r\n        System.out.println(str1.equals(str2)); //true\r\n    }\r\n\r\n}\r\n```\r\n\r\n这是由于equals方法比较对象内容是否相等，而==只是比较常量的引用，后者速度更快。","cover":"/images/java.jpg","link":"analysis-of-string-classes.html","preview":"\u003cp\u003eString类基于char数组，String对字符串的操作并不是在字符串或者字符数组本身进行操作，而是创建一个新的char数组然后把内容复制进去再操作。\u003c/p\u003e\n","title":"剖析String类"},{"content":"\r\n\r\n字符流以字符为单位操作文件，以下是Java中字符流的主要类\r\n\r\n+ Reader/Writer：字符流的基类，是抽象类；\r\n+ FileRead/FileWrite：输入源与输出源均为文件的字符流；\r\n+ InputStreamReader/OutputStreamWriter：适配器类，将字节流转换为字符流；\r\n+ CharArrayReader/CharArrayWriter：属于源与输出源是char数组的字符流；\r\n+ StringReader/StringWriter：输入源与输出源为String的字符流；\r\n+ BufferedReader/BufferedWriter：装饰类，对输入/输出提供缓冲，以及按行读写功能；\r\n+ PrintWriter：装饰类，可将基本类型与对象类型转换为其字符串形式输出的类。\r\n\r\n## Reader类的主要方法如下\r\n\r\n```\r\npublic int read() throws IOException\r\npublic int read(char cbuf[]) throws IOException\r\nabstract public void close() throws IOException\r\n```\r\n\r\n## Writer类的主要方法如下\r\n\r\n```\r\npublic void writer(int c)\r\npublic void writer(char cbuf)\r\npublic void writer(String str) throws IOException\r\nabstract public void flush() throws IOException\r\n```\r\n\r\n## InputStreamReader/OutputStreamWriter\r\n\r\nInputStreamReader/OutputStreamWriter是适配器类，能够将InputStream/OutputStream转换为Reader/Writer，使用方法如下\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Writer;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            File file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            Writer writer = new OutputStreamWriter(new FileOutputStream(file));\r\n            writer.write(\"Feily Zhang\");\r\n            writer.close();\r\n            Reader reader = new InputStreamReader(new FileInputStream(file));\r\n            char[] data = new char[1024];\r\n            int size = reader.read(data);\r\n            System.out.println(new String(data, 0, size));\r\n\t\t\treader.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## FileRead/FileWrite\r\n\r\nFileRead/FileWrite的用法类似于FileInputStream/FileOutputStream，直接传入文件名就可以按字符流读取，如下\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.io.Reader;\r\nimport java.io.Writer;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            File file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            Writer writer = new FileWriter(file);\r\n            writer.write(\"Hello, world\");\r\n            writer.close();\r\n            Reader reader = new FileReader(file);\r\n            char[] data = new char[1024];\r\n            int size = reader.read(data);\r\n            System.out.println(new String(data, 0, size));\r\n            reader.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## BufferedReader/BufferedWriter\r\n\r\nBufferedReader/BufferedWriter为Reader/Writer提供缓冲区功能，属于装饰类，能按行读写，示例如下\r\n\r\n```\r\nimport java.io.BufferedReader;\r\nimport java.io.BufferedWriter;\r\nimport java.io.File;\r\nimport java.io.FileReader;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            File file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            BufferedWriter writer = new BufferedWriter(new FileWriter(file));\r\n            writer.write(\"Hello, Feily Zhang\\nHello, World\");\r\n            writer.close();\r\n            BufferedReader read = new BufferedReader(new FileReader(file));\r\n            char[] data = new char[1024];\r\n            int size = read.read(data);\r\n            System.out.println(new String(data, 0, size));\r\n            read.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```","cover":"/images/java.jpg","link":"review-at-the-character-stream-of-java-file-operations.html","preview":"\u003cp\u003e字符流以字符为单位操作文件。\u003c/p\u003e\n","title":"再看Java文件操作之字符流"},{"content":"\r\n\r\n这里Java以二进制字节的方式处理文件，以二进制方式读写的主要流如下\r\n\r\n+ InputStream/OutputStream：这是基类，都是抽象类；\r\n+ FileInputStream/FileOutputStream：输出源和输出目标是文件的流；\r\n+ ByteArrayInputStream/ByteArrayOutputStream：输入源和输出目标是字节数组的流\r\n+ DataInputStream/DataOutputStream：装饰类，按基本类型和字符串而非只是字节读写流；\r\n+ BufferedInputStream/BufferedOutputStream：装饰类，对输入输出提供缓冲功能。\r\n\r\n## InputStream/OutputStream\r\n\r\nInputStream的三个基本方法分别是\r\n\r\n```\r\npublic abstract int read() throws IOException; //从流中读取下一个字节，返回类型为int，但取值为0-255，当读到流末尾时，返回-1，如果流中没有数据则会阻塞直到数据到来、流关闭或者异常出现\r\npublic int read(byte b[]) throws IOException; //批量读取，一次性读取数组b的长度个字节，返回值为实际读取的字节个数，若刚开始读取时已经到达流结尾，那么返回-1，该方法有默认实现\r\npublic int read(byte b[], int off, int len) throws IOException; //批量读取的一个重载方法\r\n```\r\n\r\nOutputStream的三个基本方法分别是\r\n\r\n```\r\npublic abstract void write(int b) throws IOException; //向流中写一个字节，参数类型必须是int(其实只会用到低八位)\r\npublic void write(byte[] b) throws IOException; //批量写入，一次性写入数组b的长度个字节\r\npublic int read(byte[] b, int off, int len); //批量读取的一个重载方法\r\n```\r\n\r\n## FileInputStream/FileOutputStream\r\n\r\nFileInputStream的两个较为常用的构造方法\r\n\r\n```\r\npublic FileInputStream(File file, boolean append) throws FileNotFoundException //其中append为true表明追加，为false表明覆盖\r\npublic FileInputStream(String filePath) throws FileNotFoundException\r\n```\r\n\r\n用法如下\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStream;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        int data = 0;\r\n        int index = 0;\r\n        byte[] buffer = new byte[1024];\r\n        File file = null;\r\n        InputStream in = null;\r\n        try {\r\n            file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            in = new FileInputStream(file);\r\n            while ((data = in.read()) != -1) {\r\n                buffer[index++] = (byte)data;\r\n            }\r\n            System.out.println(new String(buffer, 0, index, \"utf-8\"));\r\n            in.close();\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n写入文件的代码为\r\n\r\n```\r\nimport java.io.File;\r\nimport java.io.FileOutputStream;\r\nimport java.io.OutputStream;\r\nimport java.nio.charset.Charset;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        File file = null;\r\n        OutputStream out = null;\r\n        try {\r\n            file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            out = new FileOutputStream(file, true); //追加\r\n            byte[] data = \"Hello, world\".getBytes(Charset.forName(\"utf-8\"));\r\n            out.write(data);\r\n            out.close();\r\n        } catch(Exception e) {\r\n            e.printStackTrace();\r\n        } finally {\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n## DataInputStream/DataOutputStream\r\n\r\n这两个是装饰类，他们接受一个已有的InputStream/OutputStream为构造方法的参数，通过他们写入或读取数据时，可以读取或写入指定类型的数据，类型如下\r\n\r\n```\r\nread/writeInt：读取或写入四个字节，先是高字节再是低字节；\r\nread/writeBoolean：写入一个字节，若值为true则写入1否则写入0\r\nread/writeUTF：将字符串按utf-8编码写入。\r\n...\r\n```\r\n\r\n需要注意的是这两个类写入的文件都是对应的二进制字节，也就是说打开文件是乱码的，但是读写均正常\r\n\r\n```\r\nimport java.io.DataInputStream;\r\nimport java.io.DataOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            File file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            DataOutputStream out = new DataOutputStream(new FileOutputStream(file));\r\n            List\u003cStudent\u003e list = Arrays.asList(new Student[] {\r\n                    new Student(18, \"张三\", 80.9d), new Student(17, \"李四\", 67.5d)\r\n            });\r\n            out.writeInt(list.size());\r\n            for (Student s : list) {\r\n                out.writeInt(s.getAge());\r\n                out.writeUTF(s.getName());\r\n                out.writeDouble(s.getScore());\r\n            }\r\n            out.close();\r\n            \r\n            List\u003cStudent\u003e students = new ArrayList\u003cStudent\u003e();\r\n            DataInputStream in = new DataInputStream(new FileInputStream(file));\r\n            int size = in.readInt();\r\n            for (int i = 0; i \u003c size; i++) {\r\n                Student s = new Student();\r\n                s.setAge(in.readInt());\r\n                s.setName(in.readUTF());\r\n                s.setScore(in.readDouble());\r\n                students.add(s);\r\n            }\r\n            for(Student s : students) {\r\n                System.out.println(s.getAge());\r\n                System.out.println(s.getName());\r\n                System.out.println(s.getScore());\r\n            }\r\n            in.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n    \r\n    public static class Student {\r\n        int age;\r\n        String name;\r\n        double score;\r\n        public Student() {\r\n            \r\n        }\r\n        public Student(int age, String name, double score) {\r\n            this.age = age;\r\n            this.name = name;\r\n            this.score = score;\r\n        }\r\n        public void setAge(int age) {\r\n            this.age = age;\r\n        }\r\n        public void setName(String name) {\r\n            this.name = name;\r\n        }\r\n        public void setScore(double score) {\r\n            this.score = score;\r\n        }\r\n        public int getAge() {\r\n            return age;\r\n        }\r\n        public String getName() {\r\n            return name;\r\n        }\r\n        public double getScore() {\r\n            return score;\r\n        }\r\n    }\r\n\r\n}\r\n```\r\n\r\n写入的文件内容为\r\n\r\n```\r\n   \u0002   \u0012 \u0006寮犱笁@T9櫃櫃?   \u0011 \u0006鏉庡洓@P?  \r\n```\r\n\r\n读出的文件内容为\r\n\r\n```\r\n18\r\n张三\r\n80.9\r\n17\r\n李四\r\n67.5 \r\n```\r\n\r\n## BufferedInputStream/BufferedOutputStream\r\n\r\nFileInputStream/FileOutputStream没有缓冲，是按字节读取的，性能低，虽然可以按字节数组读取以提高性能，但是有时必须按字节读写，如果使用缓冲区的话就能很好的解决这个问题。\r\n\r\n使用BufferedInputStream/BufferedOutputStream时，只需要将FileInputStream/FileOutputStream对象作为参数传入构造方法即可。如下\r\n\r\n```\r\nimport java.io.BufferedInputStream;\r\nimport java.io.BufferedOutputStream;\r\nimport java.io.File;\r\nimport java.io.FileInputStream;\r\nimport java.io.FileOutputStream;\r\nimport java.io.IOException;\r\nimport java.nio.charset.Charset;\r\n\r\npublic class StreamTest {\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            File file = new File(\"C:\\\\Users\\\\Administrator\\\\Desktop\\\\Docs\\\\test.txt\");\r\n            BufferedOutputStream bufferedOut = new BufferedOutputStream(new FileOutputStream(file));\r\n            bufferedOut.write(\"Feily Zhang\\nHello , world\".getBytes(Charset.forName(\"utf8\")));\r\n            bufferedOut.close();\r\n            int size = 0;\r\n            byte[] buffer = new byte[1024];\r\n            BufferedInputStream bufferedIn = new BufferedInputStream(new FileInputStream(file));\r\n            size = bufferedIn.read(buffer);\r\n            System.out.println(new String(buffer, 0, size, \"utf-8\"));\r\n            bufferedIn.close();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nFeily Zhang\r\nHello , world\r\n```","cover":"/images/java.jpg","link":"review-at-the-byte-stream-of-java-file-operations.html","preview":"\u003cp\u003e这里Java以二进制字节的方式处理文件。\u003c/p\u003e\n","title":"再看Java文件操作之字节流"},{"content":"\r\n\r\n接口屏蔽了类型的差异性，只关注能力或者动作。比如说计算机USB接口，它只是定义了一个规则，并没有具体的实现(U盘)，但是却可以使得U盘与计算机交互，接口就是具备这样一种能力。\r\n\r\n简单来说接口的使用包括三方，一方是使用者、一方是接口，另一方是接口的实现。接口实现者实现了接口定义的规则，而使用者通过接口使用实现者提供的服务，这就是他们之间的关系。这样就会降低耦合性，把各部分独立出来。\r\n\r\n比如，我们以前的随机数服务为例，如下\r\n\r\n```\r\npublic interface HelloInterface {\r\n    public abstract Random createRandom();\r\n}\r\n```\r\n\r\n然后我们定义接口的实现者\r\n\r\n```\r\npublic class RealizeInterface implements HelloInterface {\r\n\r\n    @Override\r\n    public Random createRandom() {\r\n        return new Random();\r\n    }\r\n\r\n}\r\n```\r\n\r\n该实现者返回一个随机数类，该类的定义如下\r\n\r\n```\r\npublic class Random {\r\n    private int randomNum = (int) (50 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(randomNum);\r\n    }\r\n}\r\n```\r\n\r\n接口的使用者为\r\n\r\n```\r\npublic class Using {\r\n\r\n    public static void main(String[] args) {\r\n        HelloInterface hello = new RealizeInterface();\r\n        Random random = hello.createRandom();\r\n        random.printRandom();\r\n    }\r\n}\r\n```\r\n\r\n这就是接口的使用，也是面向接口编程，即我们所需要的服务全部是向接口索取，而非Random实体类，由于接口屏蔽了随机数的实现细节，那么我们获取到的随机数服务就是稳定的。\r\n\r\n这里的例子是IoC与DI的面向接口编程的例子，只是没有使用依赖注入与控制反转。\r\n\r\n下面说接口的一些细节\r\n\r\n第一、接口中可以定义变量\r\n\r\n变量的默认修饰符是public static final，引用方式为接口名.变量名。\r\n\r\n第二、接口可以继承其他接口\r\n\r\n接口可以继承其他接口，且可以是多继承，同样适用extends关键字\r\n\r\n第三、instanceof\r\n\r\n也可以使用instanceof判断某对象是否实现了某接口，使用方式为\r\n\r\n对象 instanceof 接口\r\n返回值是boolean型变量\r\n\r\n第四、Java8对接口的增强\r\n\r\nJava8中对接口进行了功能增强，使得接口可以定义静态方法和默认方法且都有实现体，金泰方法通过接口名调用，默认方法通过接口型的对象调用，且静态方法和默认方法都必须是public的\r\n\r\n以随机数这个例子说明之，改动接口的代码，添加默认方法和静态方法，如下\r\n\r\n```\r\npublic interface HelloInterface {\r\n    public abstract Random createRandom();\r\n    \r\n    public static void printmMathRandom() {\r\n        System.out.println(Math.random());\r\n    }\r\n    \r\n    public default void printRandomClassRandom() {\r\n        System.out.println(new java.util.Random().nextInt(10));\r\n    }\r\n}\r\n```\r\n\r\n主函数改一下\r\n\r\n```\r\npublic class Using {\r\n\r\n    public static void main(String[] args) {\r\n        HelloInterface hello = new RealizeInterface();\r\n        Random random = hello.createRandom();\r\n        random.printRandom();\r\n        hello.printRandomClassRandom();\r\n        HelloInterface.printmMathRandom();\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n16\r\n6\r\n0.31667981164852066\r\n```\r\n\r\n第五、Java9对接口的增强\r\n\r\nJava9去掉了接口的静态方法和默认方法是public的限制，可以是private，这样就便于同一个接口内的其余方法引用private修饰的方法代码。由于我是Java8,因此，这里无法演示。\r\n\r\n总结一下，面向接口编程是一种重要的程序思维方式，这种方式不仅可以复用代码，还可以降低耦合，提高灵活性，所以适合对大问题分而治之，与面向切面编程各有侧重。\r\n\r\n抽象类\r\n\r\n抽象类与具体类相对立又同一，抽象类只是无法创建对象，表达的是抽象的概念，除此之外与具体类并无差别，是用来继承的，也可以不继承直接通过main方法运行(一定是自身的main方法，因为因为无法创建对象，就无法在别的类的main方法中运行)。类因为抽象方法而抽象，没有抽象方法的抽象类是没意义的但是并不是错误的，也就是说抽象类中要有抽象方法(也可以没有)，但是抽象方法所在的类必须是抽象的，抽象类可以有非抽象方法的实现，抽象方法不能有方法体，可以有main方法，如下，我们定义一个计算图形面积和周长的抽象类\r\n\r\n我们先演示一下抽象类可以有main方法，但不能实例化，如果我们要运行抽象类的非抽象方法，那么就只能写为静态方法，如下\r\n\r\n```\r\npublic abstract class Shape {\r\n\r\n    public static float length = 10f;\r\n    public static float width = 20f;\r\n    \r\n    public static void area() {\r\n        System.out.println(length * width);\r\n    }\r\n    \r\n    public static void main(String[] args) {\r\n        area();    //200.0\r\n    }\r\n}\r\n```\r\n\r\n当然，这不是我们的重点，我们直接定义一个抽象类\r\n\r\n```\r\npublic abstract class Shape {\r\n    public abstract void calArea();\r\n    public abstract void calGirth();\r\n}\r\n```\r\n\r\n看起开好像与接口无异，你是正确的，现在确实是这样，我们还得继续，再声明类继承抽象类并直接main运行\r\n\r\n```\r\npublic class Square extends Shape {\r\n\r\n    float length, width;\r\n    \r\n    public Square(float length, float width) {\r\n        this.length = length;\r\n        this.width = width;\r\n    }\r\n    public void calArea() {\r\n        System.out.println(length * width);\r\n    }\r\n\r\n    public void calGirth() {\r\n        System.out.println((length + width) * 2);\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Square s = new Square(10.0f, 20.0f);\r\n        s.calArea();\t//200.0\r\n        s.calGirth();\t//60.0\r\n    }\r\n}\r\n```\r\n\r\n看来确实与接口无异啊，只不过就是比接口高级一点，可以有默认方法实现(Java8中接口也有了)，可以有main方法(这个接口没有)。\r\n\r\n其实，接口与抽象类还是有去别的，抽象类抽象实体，而接口只抽象动作。\r\n\r\n还有二者其实是配合使用的，接口声明能力，抽象类提供默认实现(实现部分或者全部方法)，所以一个接口常常有一个抽象类相对应。那么逻辑现在就变成了，抽象类实现接口，原先的接口实现者现在继承抽象类，然后重写必要的方法供使用者使用，这是因为抽象类无法new对象，因此只能通过继承了抽象类的类来new对象，供接口使用者使用。\r\n\r\n内部类与包含它的外部类有着密切的关系，而与其他类关系不大，定义在类内部，可以实现对外的完全隐藏，代码上更为紧凑和简洁。不过，内部类，只是Java编译器的概念，在运行时每个类都会被编译为一个独立的类，拥有独立的字节码文件。\r\n\r\n内部类共有四种类型，分别是\r\n\r\n+ 静态内部类 \r\n+ 成员内部类 \r\n+ 方法内部类 \r\n+ 匿名内部类\r\n\r\n静态内部类带有static关键字，如下\r\n\r\n```\r\npublic class Outer {\r\n    private static int shared = 100;\r\n    public static class StaticInner {\r\n        public void innerMethod() {\r\n            System.out.println(\"inner \" + shared);\r\n        }\r\n    }\r\n    public void test() {\r\n        new StaticInner().innerMethod();\r\n    }\r\n}\r\n```\r\n\r\n静态内部类可以访问对应外部类的静态变量和方法，但不能访问实例变量和方法。静态内部类可以被其余外部类访问，访问方式是外部类.静态内部类的方式。\r\n\r\n成员内部类\r\n\r\n```\r\npublic class Outer {\r\n    private int a = 100;\r\n    public class Inner {\r\n        public void innerMethod() {\r\n            System.out.println(\"outer a \" + a);\r\n            Outer.this.action();\r\n        }\r\n    }\r\n    private void action() {\r\n        System.out.println(\"action\");\r\n    }\r\n    public void test() {\r\n        new Inner().innerMethod();\r\n    }\r\n}\r\n```\r\n\r\n与静态内部类的区别是少了static关键字，可以访问外部类的变量和方法，如果内部类方法与外部类方法重名那么可以通过外部类.this.外部类方法的形式访问外部类方法。\r\n\r\n方法内部类\r\n\r\n顾名思义，就是内部类定义在方法中，如下\r\n\r\n```\r\npublic class Outer {\r\n    private int a = 100;\r\n    public void test(final int param) {\r\n        final String str = \"hello\";\r\n        class Inner {\r\n            public void innerMethod() {\r\n                System.out.println(\"outer a \" + a);\r\n                System.out.println(\"param \" + param);\r\n                System.out.println(\"local var \" + str);\r\n            }\r\n        }\r\n        new Inner().innerMethod();\r\n    }\r\n}\r\n```\r\n\r\n如果包含内部类的方法是非静态方法，那么方法内部类可以访问方法之外外部类之内的非静态变量和方法；\r\n\r\n如果包含内部类的方法是静态方法，那么内部类只能访问外部类的静态变量和静态方法。\r\n\r\n方法内部类还可以访问方法的参数和方法中的局部变量，在Java8之前，这两种变量必须被声明为final，Java8之后不再要求，但变量不能重新赋值否则会编译错误。\r\n\r\n匿名内部类\r\n\r\n其语法为\r\n\r\n```\r\nnew 父类(参数列表) {\r\n\t//匿名内部类的实现部分\r\n}\r\n或者\r\nnew 父接口() {\r\n\t//匿名内部类的实现部分\r\n}\r\n```\r\n\r\n例如\r\n\r\n```\r\npublic class Outer {\r\n    public static void main(String[] args) {\r\n        Shape shape = new Shape() {\r\n            float length = 10f;\r\n            float width = 20f;\r\n            @Override\r\n            public void calArea() {\r\n                System.out.println(length * width);\r\n            }\r\n\r\n            @Override\r\n            public void calGirth() {\r\n                System.out.println((length + width) * 2);\r\n            }\r\n            \r\n        };\r\n        shape.calArea();\t//200.0\r\n        shape.calGirth();\t//60.0\r\n    }\r\n}\r\n```\r\n\r\n通过匿名类重写了抽象父类Shape的方法，那么由于重写方法使得Shape变成了形式上的抽象类实际上的抽象类，所以可以new对象，然后调用方法。","cover":"/images/java.jpg","link":"review-at-interfaces-abstract-classes-and-internal-classes.html","preview":"\u003cp\u003e接口屏蔽了类型的差异性，只关注能力或者动作; 而抽象类与接口的区别在于抽象类抽象实体，而接口只抽象动作。内部类与包含它的外部类有着密切的关系，而与其他类关系不大，定义在类内部，可以实现对外的完全隐藏，代码上更为紧凑和简洁。\u003c/p\u003e\n","title":"再看接口、抽象类与内部类"},{"content":"\r\n\r\n封装是对成员变量的包装和隐藏。实现封装首先要将被封装的属性设置为私有private，然后对其提供相应的set/get方法进行特定的访问，set方法之外的方法只能通过get方法读取到被private修饰的变量的值而无法修改，且只能通过get方法获取，这就是封装。通过一个例子说明一下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class People {\r\n\r\n    private String name;\r\n    private int age;\r\n    private String sex;\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    public void setAge(int age) {\r\n        this.age = age;\r\n    }\r\n    \r\n    public void setSex(String sex) {\r\n        this.sex = sex;\r\n    }\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public int getAge() {\r\n        return age;\r\n    }\r\n    \r\n    public String getSex() {\r\n        return sex;\r\n    }\r\n    \r\n}\r\npackage springTest;\r\n\r\npublic class PeopleMain {\r\n\r\n    public static void main(String[] args) {\r\n        People people = new People();\r\n        // 只能通过set方法设置私有属性\r\n        people.setName(\"Feily Zhang\");\r\n        people.setAge(21);\r\n        people.setSex(\"man\");\r\n        // System.out.println(people.name + \" \" + people.age + \" \" + people.sex);  错误，私有属性只能通过get方法获取\r\n        System.out.println(people.getName() + \" \" + people.getAge() + \" \" + people.getSex());\r\n    }\r\n}\r\n```\r\n\r\n继承指的是子类可以继承父类的非私有属性和方法，在此之外，子类可以定义自己的和父类无关的属性和方法，换句话说就是既然已经有类有这个方法，而我正好要用这个方法，那么我就不用再写，直接extends，我自己就可以获得这个方法。\r\n\r\n需要特别注意的是，父类一定会有默认构造方法(即使没写那么编译期间也会填充一个)，子类可以在自己的构造方法(任意构造方法不一定是默认构造器)通过super()初始化父类构造器也可以不初始化交给编译器自动完成；但是如果父类有带参数的非默认构造器，那么子类必须在自己的构造器内通过super(参数)初始化父类，否则会报错。\r\n\r\n```\r\npublic class Animal {\r\n\r\n    private String animalName;\r\n    \r\n    public void setAnimalName(String animalName) {\r\n        this.animalName = animalName;\r\n    }\r\n    \r\n    public String getAnimalName() {\r\n        return animalName;\r\n    }\r\n    \r\n    public void say() {\r\n        System.out.println(animalName + \" , I am saying!\");\r\n    }\r\n    \r\n}\r\n```\r\n\r\n以上定义了一个Animal类，并封装了私有属性animalName，使得只能通过set和get方法来访问，我们接下来定义一个Dog类，该类extends了Animal类，那么只要其继承了Animal，就获得了Animal私有属性之外的所有属性和方法，如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Dog extends Animal{\r\n\r\n}\r\n```\r\n\r\n我们什么也不用写，因为通过extends已经获得了Animal的私有animalName之外所有属性和方法\r\n\r\n然后验证一下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class AnimalMain {\r\n\r\n    public static void main(String[] args) {\r\n        Dog dog = new Dog();\r\n        dog.setAnimalName(\"Dog\");\r\n        dog.say();\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nDog , I am saying!\r\n```\r\n\r\n如果我们不用继承的方式，那么等同于如下代码\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Dog{\r\n\r\n    private String dogName;\r\n    \r\n    public void setDogName(String dogName) {\r\n        this.dogName = dogName;\r\n    }\r\n    \r\n    public String getDogName() {\r\n        return dogName;\r\n    }\r\n    \r\n    public void say() {\r\n        System.out.println(dogName + \" , I am saying!\");\r\n    }\r\n}\r\n\r\npackage springTest;\r\n\r\npublic class AnimalMain {\r\n\r\n    public static void main(String[] args) {\r\n        Dog dog = new Dog();\r\n        dog.setDogName(\"Dog\");\r\n        dog.say();\r\n    }\r\n\r\n}\r\n```\r\n\r\n在我们已经有Animal的情况下，是不是就没有必要写Dog的重复代码？所以通过继承可以简化冗余代码。\r\n\r\n总体来说，继承还是比较常规的，就是子类没有必要写父类拥有的代码，直接拿来用就行了。但是，关于继承，还有如下注意点\r\n\r\n第一、关于构造方法\r\n\r\n父类一定会有默认构造方法(即使没写那么编译期间也会填充一个)，子类可以在自己的构造方法(任意构造方法不一定是默认构造器)通过super()初始化父类构造器也可以不初始化交给编译器自动完成；但是如果父类有带参数的非默认构造器，那么子类必须在自己的构造器内通过super(参数)初始化父类，否则会报错。\r\n\r\n在上面的例子中，父类没有写默认构造器，但是编译期间填充了一个，子类也没有构造器，但是运行成功了。这是因为父类的默认构造器子类不需要显式super，所以有没有构造器都无所谓。那我们改动一下。让父类拥有非默认构造器\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Animal {\r\n\r\n    private String animalName;\r\n    \r\n    public Animal(String animalName) {\r\n        this.animalName = animalName;\r\n    }\r\n    /*\r\n    public void setAnimalName(String animalName) {\r\n        this.animalName = animalName;\r\n    }\r\n    \r\n    public String getAnimalName() {\r\n        return animalName;\r\n    }\r\n    */\r\n    public void say() {\r\n        System.out.println(animalName + \" , I am saying!\");\r\n    }\r\n    \r\n}\r\n\r\npackage springTest;\r\n\r\npublic class Dog extends Animal{\r\n    /*\r\n    private String dogName;\r\n    \r\n    public void setDogName(String dogName) {\r\n        this.dogName = dogName;\r\n    }\r\n    \r\n    public String getDogName() {\r\n        return dogName;\r\n    }\r\n    \r\n    public void say() {\r\n        System.out.println(dogName + \" , I am saying!\");\r\n    }\r\n    */\r\n}\r\n```\r\n\r\n那么Dog类一定会提示你\r\n\r\n```\r\nImplicit super constructor Animal() is undefined for default constructor. Must define an explicit constructor\r\n```\r\n\r\n所以加上构造方法，如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Dog extends Animal{\r\n\r\n    public Dog(String animalName) {\r\n        super(animalName);\r\n    }\r\n    /*\r\n    private String dogName;\r\n    \r\n    public void setDogName(String dogName) {\r\n        this.dogName = dogName;\r\n    }\r\n    \r\n    public String getDogName() {\r\n        return dogName;\r\n    }\r\n    \r\n    public void say() {\r\n        System.out.println(dogName + \" , I am saying!\");\r\n    }\r\n    */\r\n}\r\n```\r\n\r\n再测试一下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class AnimalMain {\r\n\r\n    public static void main(String[] args) {\r\n        Dog dog = new Dog(\"Dog\");;\r\n        dog.say();\t//Dog , I am saying!\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n运行是没有问题的。所以，一定要注意。\r\n\r\n第二、关于构造方法调用方法\r\n\r\n构造方法调用方法应该尽可能避免，因为子类一旦重写这个方法，那么一旦子类重写的方法有变量参与，就会造成非预期结果，这是因为，在new子类的过程中是先初始化父类的，由于父类构造方法调用了方法，再由于子类重写了这个方法且有变量参与，那么由于该方法被重写，父类初始化的时候就调用重写后的方法，因为父类在子类之前被初始化，所以父类读取到的方法的变量就会是默认值(int为0).一个例子说明\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Base {\r\n\r\n    public Base() {\r\n        test();\r\n    }\r\n    \r\n    public void test() {\r\n        \r\n    }\r\n}\r\n```\r\n\r\n父类Base的构造方法调用了test方法\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Child extends Base {\r\n\r\n    private int a = 111;\r\n    public Child() {\r\n        \r\n    }\r\n    public void test() {\r\n        System.out.println(a);\r\n    }\r\n}\r\n```\r\n\r\n子类重写了test方法，导致new子类时先初始化父类，父类直接调用子类重写的test方法，由于子类还未new，那么a为0；等父类初始化之后，子类被new，那么调用test方法才会输出111\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        Child c = new Child();\t//0\r\n        c.test();\t//111\r\n    }\r\n\r\n}\r\n```\r\n\r\n但是为什么父类初始化的时候执行的是子类的test方法呢？怎么不执行父类自己的test？\r\n\r\n这牵扯到动态绑定和静态绑定的概念，Java中实例变量、静态变量、静态方法、private方法都是静态绑定的，其余均是动态绑定。静态绑定的话如果子类对象向上转型为父类对象那么子类重写的父类方法无效即向上转型的子类对象执行的是父类的方法，如果不转型那么执行的仍然是子类的方法。动态绑定中无论子类对象是否转型，(不管是父类还是子类)执行的都是重写后的子类的方法。\r\n\r\n第三、关于重名(重写)与静态绑定\r\n\r\n上面其实已经说了，静态绑定的概念，我们先看一下动态绑定，仍然看上面的例子，只不过我们增加一个转型\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        Child c = new Child();\r\n        Base b = c;\r\n        c.test();\r\n        b.test();\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n0\r\n111\r\n111\r\n```\r\n\r\n可以看出，执行的还是子类的方法\r\n\r\n说个题外话，为什么只有一个0，不是应该有两个吗？这是因为Child c = new Child()的时候父类已经被初始化，子类也被初始化，那么自然a的值为111而非0.\r\n\r\n再看一下静态绑定，如果我们子类重写父类的实例变量、静态变量、静态方法、private方法，那么如果转型就会调用父类的方法，不转型则是子类的方法，如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Base {\r\n\r\n    public String a = \"base\";\r\n    public static String b = \"static_base\";\r\n    \r\n    public static void staticTest() {\r\n        System.out.println(\"static_staticTest \" + b);\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class Child extends Base {\r\n\r\n    public String a = \"child\";\r\n    public static String b = \"static_child\";\r\n    \r\n    public static void staticTest() {\r\n        System.out.println(\"static_staticTest_child \" + b);\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        // 不转型，输出的就是子类的重写\r\n        Child c = new Child();\r\n        System.out.println(c.a);\r\n        c.staticTest();\r\n        //转型，输出的是父类的属性和方法\r\n        Base b = c;\r\n        System.out.println(b.a);\r\n        b.staticTest();\r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nchild\r\nstatic_staticTest_child static_child\r\nbase\r\nstatic_staticTest static_base\r\n```\r\n\r\n显而易见\r\n\r\n第四、重载时调用父类还是子类方法\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Base {\r\n    public int sum(int a, int b) {\r\n        System.out.println(\"base_int_int\");\r\n        return a + b;\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class Child extends Base {\r\n\r\n    public long sum(long a, long b) {\r\n        System.out.println(\"child_long_long\");\r\n        return a + b;\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        Child c = new Child();\r\n        int a = 1, b = 2;\r\n        System.out.println(c.sum(a, b));\r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nbase_int_int\r\n3\r\n```\r\n\r\n这是因为重载时是根据数据类型匹配方法的。由于Main方法中a和b后市int型参数，父类的参数都是int型，所以使用父类的方法，如果我们把main方法中的a和b改为long型参数，那么就会调用子类的方法，如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        Child c = new Child();\r\n        long a = 1L, b = 2L;\r\n        System.out.println(c.sum(a, b));\r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nchild_long_long\r\n3\r\n```\r\n\r\n第五、父子类型的转换\r\n\r\n子类型转为父类型称为向上转型，我们上面有涉及，向下转型(父类转型为子类)呢？\r\n\r\n语法上可以通过强制类型转换进行，但是不一定成功。\r\n\r\n一个父类的变量能不能转型为一个子类的变量，取决于这个父类变量的动态类型是不是这个子类或者这个子类的子类。\r\n\r\n比如\r\n\r\n```\r\nBase b = new Child();\r\nChild c = (Child) b;\r\n```\r\n\r\n这是可以成功的，因为父类Base的动态类型就是子类Child，所以可以成功\r\n\r\n但是\r\n\r\n```\r\nBase b = new Base();\r\nChild c = (Base) b;\r\n```\r\n\r\n这是会失败的，因为Base的动态类型不确定是不是Child\r\n\r\n另外，可以通过instanceof关键字查看父类能否转型为子类，如下\r\n\r\n```\r\npublic boolean canCast(Base b) {\r\n    return b instanceof Child;\r\n}\r\n```\r\n\r\n第六、可见性重写\r\n\r\n重写方法一般情况下不会修改父类方法的可见性，但是需要注意的是子类不能降低父类方法的可见性。\r\n\r\n可见性由高到低为：public、protected、private。\r\n\r\n第七、父类的final方法不能被继承\r\n\r\nfinal关键字可以修饰类、变量、方法，不能修饰接口，因为接口必须被实现才有意义，一旦声明为final就无法被其他类实现。\r\n\r\nfinal修饰的类不能被继承、修饰的方法和变量不能被重写。\r\n\r\n最后，通过一个例子来说明，继承的真谛：利用继承的特性，只写有必要的代码，没有必要且已经存在的代码直接继承调用即可。\r\n\r\n假定现在我们已经有了这个类\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Base {\r\n    protected int currentStep;\r\n    protected void step1() {\r\n        \r\n    }\r\n    protected void step2() {\r\n        \r\n    }\r\n    protected void action() {\r\n        this.currentStep = 1;\r\n        step1();\r\n        this.currentStep = 2;\r\n        step2();\r\n    }\r\n}\r\n```\r\n\r\n我们需要的是action里面的功能，发现完全满足，但是step1和step2并没有被实现，那么简单我们实现了这两个方法然后调用action即可。子类如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Child extends Base {\r\n\r\n    public void step1() {\r\n        System.out.println(\"Child step \" + this.currentStep);\r\n    }\r\n    \r\n    public void step2() {\r\n        System.out.println(\"Child step \" + this.currentStep);\r\n    }\r\n}\r\n```\r\n\r\n我们升级了父类方法的可见性，然后调用了父类的实例变量，请注意，我们并没有重写父类的实例变量，调用完全是可以的，那么我们不管是否向上转型，那么我们都会得到相同的结果\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class BaseMain {\r\n\r\n    public static void main(String[] args) {\r\n        Child c = new Child();\r\n        c.action();\r\n        Base b = c;\r\n        b.action();\r\n    }\r\n\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nChild step 1\r\nChild step 2\r\nChild step 1\r\nChild step 2\r\n```\r\n\r\n多态\r\n\r\n多态是基于继承的，多态存在的3个条件是\r\n\r\n+ 子类继承父类； \r\n+ 子类重写父类的方法； \r\n+ 父类引用指向子类对象\r\n\r\n就用之前的Animal举个例子\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Animal {\r\n    public void say() {\r\n    }\r\n}\r\n```\r\n\r\nAnimal我们定义一个空方法，类似于接口和抽象类，多态我们一般都是这么做\r\n\r\n再定义Cat和Dog，分别继承Animal，这是多态的第一个条件，然后重写say方法，这是第二个条件\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class Dog extends Animal{\r\n\r\n    String dogName;\r\n    \r\n    public Dog(String dogName) {\r\n        this.dogName = dogName;\r\n    }\r\n    public void say() {\r\n        System.out.println(\"I am a \" + dogName);\r\n    }\r\n\r\n}\r\npackage springTest;\r\n\r\npublic class Cat extends Animal{\r\n\r\n    String catName;\r\n    \r\n    public Cat(String catName) {\r\n        this.catName = catName;\r\n    }\r\n    \r\n    public void say() {\r\n        System.out.println(\"I am a \" + catName);\r\n    }\r\n}\r\n```\r\n\r\n主文件中，向上转型为Animal，这是多态的第三个条件，即父类引用指向子类对象，如下\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class AnimalMain {\r\n\r\n    public static void main(String[] args) {\r\n        Animal dog = new Dog(\"dog\");\r\n        dog.say();\r\n        Animal cat = new Cat(\"cat\");\r\n        cat.say();\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nI am a dog\r\nI am a cat\r\n```\r\n\r\n好吧，你可能说也没见多态有什么威力呀，不用转型照样可以实现需求啊。主要是这样更加规范和便于理解\r\n\r\n改造一下，我们再抽象一个动物管理员出来\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class AnimalManager {\r\n\r\n    private static final int MAX_NUM = 100;\r\n    private Animal[] animals = new Animal[MAX_NUM];\r\n    private int animalNum = 0;\r\n    \r\n    public void addAnimal(Animal animal) {\r\n        if (animalNum \u003c MAX_NUM) { \r\n            animals[animalNum++] = animal; \r\n        } \r\n    } \r\n\t\r\n    public void say() { \r\n        for(Animal animal : animals) { \r\n            animal.say(); \r\n        }\r\n    }\r\n}\r\n```\r\n\r\n相应的主文件为\r\n\r\n```\r\npackage springTest;\r\n\r\npublic class AnimalMain {\r\n\r\n    public static void main(String[] args) {\r\n        AnimalManager am = new AnimalManager();\r\n        am.addAnimal(new Dog(\"dog\"));\r\n        am.addAnimal(new Cat(\"cat\"));\r\n        am.say();\r\n    }\r\n\r\n}\r\n```\r\n\r\n便于管理，可拓展性极强。\r\n\r\n变量Animal可以引用任何Animal子类类型的对象，这叫多态，即一种类型的变量，可以引用多种实际类型对象。这样，对于类型Animal，我们称之位animal的静态类型，而Dog、Cat等，我们称之为animal的动态类型，AnimalManager的say方法调用的是其对应的动态类型(如Dog、Cat)的say方法，这称之为动态绑定。\r\n\r\n多态和动态绑定是计算机程序的一种重要的思维方式，使得操作对象的程序不需要关注对象的实际类型，因为被父类统一起来了，这样就可以同意处理不同的对象，而且能够实现每个对象的特有行为。\r\n\r\n总而言之，多态就是同一个类型在不同的指向下有不同的状态，所谓状态就是特定的属性和行为。","cover":"/images/java.jpg","link":"review-encapsulation-inheritance-and-polymorphism.html","preview":"\u003cp\u003e封装是对成员变量的包装和隐藏；继承指的是子类可以继承父类的非私有属性和方法，在此之外，子类可以定义自己的和父类无关的属性和方法；多态是基于继承的。\u003c/p\u003e\n","title":"再看封装、继承和多态"},{"content":"\r\n\r\n面向接口编程通过结合IoC和DI，使得耦合性相当低，可拓展性极强，实现了低耦合高内聚，但是这种编程方式是对功能性主业务需求的分而治之，对于一些非功能性的需求则显得力不从心，比如日志、安全、事务、性能统计等次要但很必要的功能就显得不够省力。\r\n\r\n我们在软件系统设计的时候，一项很重要的工作就是把一个大系统按业务功能分解成一个个低耦合、高内聚的模块，分而治之，但是分解之后就会发现，有些非功能性需求的东西是通用的或者说是跨越多个模块的，即多个模块都需要，比如\r\n\r\n1. 日志：对特定的操作输出日志来记录； \r\n2. 安全：在执行操作之前进行权限的检查； \r\n3. 事务：在方法开始之前要开始事务，在方法结束之后要提交或者回滚事务；\r\n4. 性能统计：统计每个方法的执行时间\r\n5. ......\r\n\r\n这些多个模块都需要的非功能性需求用面向接口编程的方式实现是很不优雅的，但是用面向切面的编程方式来实现则方便很多。\r\n\r\n主业务功能性需求我们可以看作是一个个面，每层叠加在一起构成了一个面包，这个面包就是整个需求，由于每个面都需要一些非功能性需求(诸如日志、安全等等)，那么这些需求就像一个切面一样贯穿到了主业务需求的每层面包当中，即非功能性代码与业务代码的关注点不同，业务代码的关注点是必要性功能的实现(面向接口更简单，强调的是可拓展性)，非功能性代码的关注点是通用性非必要功能的实现，采用面向切面的方式更简单，即非功能性代码与业务代码之间应该是正交的(垂直的)。\r\n\r\n把通用性非功能性代码的实现方式就叫做面向切面编程，切面是贯穿于业务代码的。这就是AOP\r\n\r\n先说明几个简单的概念\r\n\r\n1. 切入点或连接点：如果切面要切入业务代码的某个方法，那么这个方法就是切面的切入点； \r\n2. 通知：由于切面是对业务代码通用性非必要功能的抽象，那么以日志为例，比如日志切面要切入业务需求User类的print()方法，那么就要在该方法执行之前和之后记录日志，这就要用到通知，通知就是对切入方法的前置、后置和环绕等操作；\r\n3. 目标：即切面切入的方法所在的类就是目标，例如User类就是目标。\r\n\r\n通过一个简单的例子来说明之\r\n\r\nUser类如下，该类通过Setter方式接受参数创建bean\r\n```\r\npackage springTest;\r\n\r\npublic class User {\r\n    \r\n    String userName;\r\n    \r\n    public void setUserName(String userName) {\r\n        this.userName = userName;\r\n    }\r\n    \r\n    public String getUserName() {\r\n        return userName;\r\n    }\r\n    \r\n    public void print() {\r\n        System.out.println(\"I am \" + userName);\r\n    }\r\n    \r\n}\r\n```\r\n配置文件如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\" \r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"             \r\n    xsi:schemaLocation=\"                                               \r\n            http://www.springframework.org/schema/beans \r\n            http://www.springframework.org/schema/beans/spring-beans.xsd    \r\n            http://www.springframework.org/schema/context     \r\n            http://www.springframework.org/schema/context/spring-context.xsd    \r\n            http://www.springframework.org/schema/mvc    \r\n            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \r\n            http://www.springframework.org/schema/tx   \r\n            http://www.springframework.org/schema/tx/spring-tx.xsd  \r\n            http://www.springframework.org/schema/aop  \r\n            http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e\r\n\u003cbean id=\"u\" class=\"springTest.User\"\u003e\r\n    \u003cproperty name=\"userName\" value=\"Java\"/\u003e\t\u003c!-- 传递参数创建bean --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n主文件如下\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class UserMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/userBean.xml\");\r\n        User user = (User) factory.getBean(\"u\");\r\n        user.print();\r\n    }\r\n\r\n}\r\n```\r\n运行结果为\r\n```\r\nI am Java\r\n```\r\n假如我们现在要给目标User类的print方法记录操作日志，那么就需要一个切面，定义如下\r\n```\r\npackage springTest;\r\n\r\nimport java.util.Date;\r\n\r\npublic class Log {\r\n\r\n    public void beforeExecute() {\r\n        System.out.println(\"Log : \" + new Date() + \"User类的print方法即将执行\");\r\n    }\r\n    \r\n    public void afterExecute() {\r\n        System.out.println(\"Log : \" + new Date() + \"User类的print方法已经执行\");\r\n    }\r\n}\r\n```\r\n可以看出，其实就是一个简单的Java类，定义了两个方法，在目标方法执行之前执行beforeExecute()方法记录日志，在目标方法执行之后执行afterExecute()方法记录日志，但是并没有看到切面Log作用在目标User类之上啊？？？稍安勿躁，这些都是配置文件完成的，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\" \r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"             \r\n    xsi:schemaLocation=\"                                               \r\n            http://www.springframework.org/schema/beans \r\n            http://www.springframework.org/schema/beans/spring-beans.xsd    \r\n            http://www.springframework.org/schema/context     \r\n            http://www.springframework.org/schema/context/spring-context.xsd    \r\n            http://www.springframework.org/schema/mvc    \r\n            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \r\n            http://www.springframework.org/schema/tx   \r\n            http://www.springframework.org/schema/tx/spring-tx.xsd  \r\n            http://www.springframework.org/schema/aop  \r\n            http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e\r\n\u003cbean id=\"u\" class=\"springTest.User\"\u003e\r\n    \u003cproperty name=\"userName\" value=\"Java\"/\u003e\r\n\u003c/bean\u003e\r\n\u003cbean id=\"log\" class=\"springTest.Log\"/\u003e\r\n\u003caop:config proxy-target-class=\"true\" \u003e\r\n\u003caop:aspect ref=\"log\"\u003e\r\n    \u003caop:pointcut id=\"place-order\" expression=\"execution( * springTest.User.print(..))\"/\u003e\r\n    \u003caop:before pointcut-ref=\"place-order\" method=\"beforeExecute\"/\u003e\r\n    \u003caop:after pointcut-ref=\"place-order\" method=\"afterExecute\"/\u003e\r\n\u003c/aop:aspect\u003e\r\n\u003c/aop:config\u003e\r\n\u003c/beans\u003e\r\n```\r\n我们通过`\u003cbean id=\"log\" class=\"springTest.Log\"/\u003e`创建了切面Log的bean实例，然后通过`\u003caop:aspect ref=\"log\"\u003e`将切面Log的实例log作为切面，然后定义切入点pointcut为sprintTest包内User类的print方法(代号为place-order)，即切面作用于该方法，只通知该方法，然后对该切入点place-order绑定前置和后置操作，即beforeExecute方法和afterExecute方法记录User类print方法的日志\r\n\r\n其余代码不变，然后运行，结果为\r\n```\r\nLog : Thu Dec 13 19:57:21 CST 2018User类的print方法即将执行\r\nI am Java\r\nLog : Thu Dec 13 19:57:21 CST 2018User类的print方法已经执行\r\n```\r\n很明显，日志记录成功。\r\n\r\n如果我们要监控User类中的其他方法那怎么办？\r\n\r\n我们不妨再给User类中再增加两个方法，如下\r\n```\r\npackage springTest;\r\n\r\npublic class User {\r\n    \r\n    String userName;\r\n    \r\n    public void setUserName(String userName) {\r\n        this.userName = userName;\r\n    }\r\n    \r\n    public String getUserName() {\r\n        return userName;\r\n    }\r\n    \r\n    public void print() {\r\n        System.out.println(\"I am \" + userName);\r\n    }\r\n    \r\n    public void print1() {\r\n        System.out.println(\"I am \" + userName + \" 1\");\r\n    }\r\n\r\n    public void print2() {\r\n        System.out.println(\"I am \" + userName + \" 2\");\r\n    } \r\n}\r\n```\r\n其实我们只需要修改配置文件切面的作用域即可，如下\r\n```\r\n\u003caop:pointcut id=\"place-order\" expression=\"execution( * springTest.User.*(..))\"/\u003e\r\n```\r\n然后再在主文件中调用一下其余两个方法就可以看到效果了\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class UserMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/userBean.xml\");\r\n        User user = (User) factory.getBean(\"u\");\r\n        user.print();\r\n        user.print1();\r\n        user.print2();\r\n    }\r\n\r\n}\r\n```\r\n结果为\r\n```\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法即将执行\r\nI am Java\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法已经执行\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法即将执行\r\nI am Java 1\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法已经执行\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法即将执行\r\nI am Java 2\r\nLog : Thu Dec 13 20:00:46 CST 2018User类的print方法已经执行\r\n```\r\n怎么样，简单吧？如果要给其它类也要记录日志怎么办？同样修改作用域，将类名部分用通配符*代替即可。\r\n\r\n这是一个较为简单优雅的AOP实例，还有一个更为复杂的，不妨也看一下(这个是真的复杂)\r\n\r\n假定我们现在有一个银行账户Account类，里面有add和minus方法，要给这两个方法加日志功能，包括前置、后置和环绕操作，那么首先要先定义一个Account接口\r\n```\r\npackage springTest;\r\n\r\npublic interface Account {\r\n    void add(int money);\r\n    void minus(int money);\r\n}\r\n```\r\n再实现这个接口\r\n```\r\npackage springTest;\r\n\r\npublic class AccountImpl implements Account {\r\n\r\n    private String name;\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    @Override\r\n    public void add(int money) {\r\n        System.out.println(\"给\" + name + \"账户加钱\" + money + \"元\");\r\n    }\r\n\r\n    @Override\r\n    public void minus(int money) {\r\n        System.out.println(\"给\" + name + \"账户扣钱\" + money + \"元\");\r\n    }\r\n\r\n}\r\n```\r\n那么，我们切面的目标就是这个Account接口的实现类AccountImpl。接下来定义前置、后置和环绕类及方法，如下\r\n```\r\npackage springTest;\r\n\r\nimport java.lang.reflect.Method;\r\nimport org.springframework.aop.MethodBeforeAdvice;\r\n\r\n\r\npublic class BeforeAdvice implements MethodBeforeAdvice {\r\n\r\n    public void before(Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用前\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n    }\r\n}\r\n\r\npackage springTest;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\npublic class AfterAdvice implements org.springframework.aop.AfterAdvice {\r\n\r\n    public void afterReturning(Object returnValue, Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用后\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n        \r\n    }\r\n}\r\n\r\npackage springTest;\r\n\r\nimport org.aopalliance.intercept.MethodInterceptor;\r\nimport org.aopalliance.intercept.MethodInvocation;\r\n\r\npublic class AroundInterceptor implements MethodInterceptor {\r\n\r\n    @Override\r\n    public Object invoke(MethodInvocation arg0) throws Throwable {\r\n        System.out.println(\"调用方法之前：invocation对象：[\"+ arg0 + \"]\");\r\n        Object rval = arg0.proceed();\r\n        System.out.println(\"调用结束...\");\r\n        return rval;\r\n    }\r\n\r\n}\r\n```\r\n主文件为\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class AOPMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/AOPBean.xml\");\r\n        Account account = (Account) factory.getBean(\"account\");\r\n        System.out.println(\"第一个add方法\");\r\n        account.add(100);\r\n        System.out.println(\"第二个minus方法\");\r\n        account.minus(200);\r\n    }\r\n\r\n}\r\n```\r\n同样的，通过配置文件绑定切面和目标，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\r\n\u003c!-- 先给目标对象注入参数以创建bean --\u003e\r\n\u003cbean id=\"accountTarget\" class=\"springTest.AccountImpl\"\u003e\r\n    \u003cproperty name=\"name\" value=\"Java\" /\u003e\r\n\u003c/bean\u003e\r\n\r\n\u003c!-- 再配置前置、环绕bean --\u003e\r\n\u003cbean id=\"myBeforeAdvice\" class=\"springTest.BeforeAdvice\"/\u003e\r\n\u003cbean id=\"myAroundInterceptor\" class=\"springTest.AroundInterceptor\"/\u003e\r\n\r\n\u003c!-- 后置bean比较特殊，将20行的后置bean包装在id为addAdvisor的bean当中，并指定patterns使该后置bean只作用在add方法上，对其他方法没有作用 --\u003e\r\n\u003cbean id=\"addAdvisor\" class=\"org.springframework.aop.support.RegexpMethodPointcutAdvisor\"\u003e\r\n    \u003cproperty name=\"advice\"\u003e\r\n        \u003cbean class=\"springTest.AfterAdvice\"/\u003e\r\n    \u003c/property\u003e\r\n    \u003cproperty name=\"patterns\"\u003e\r\n        \u003clist\u003e\r\n            \u003cvalue\u003e.*add*.\u003c/value\u003e\t\u003c!-- 只对add方法管用 --\u003e\r\n        \u003c/list\u003e\r\n    \u003c/property\u003e\r\n\u003c/bean\u003e\r\n\r\n\u003c!-- 以上是配置前后置及环绕bean --\u003e\r\n\u003c!-- 以下是绑定切面(通知)和目标 --\u003e\r\n\r\n\u003cbean id=\"account\" class=\"org.springframework.aop.framework.ProxyFactoryBean\"\u003e\r\n    \u003cproperty name=\"proxyInterfaces\" value=\"springTest.Account\"/\u003e\r\n    \u003cproperty name=\"target\"\u003e\t\u003c!-- 切面的目标是id为accountTarget的bean类，即上面定义的 --\u003e\r\n        \u003cref bean=\"accountTarget\"/\u003e\r\n    \u003c/property\u003e\r\n    \u003cproperty name=\"interceptorNames\"\u003e\t\u003c!-- 拦截器列表，对目标方法拦截以记录日志 --\u003e\r\n        \u003clist\u003e\r\n            \u003cvalue\u003emyBeforeAdvice\u003c/value\u003e\r\n            \u003cvalue\u003emyAroundInterceptor\u003c/value\u003e\r\n        \u003c/list\u003e\r\n    \u003c/property\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n执行结果为\r\n```\r\n第一个add方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.add(int)\r\n方法的参数是100\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.add(int); target is of class [springTest.AccountImpl]]\r\n给Java账户加钱100元\r\n调用结束...\r\n第二个minus方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.minus(int)\r\n方法的参数是200\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.minus(int); target is of class [springTest.AccountImpl]]\r\n给Java账户扣钱200元\r\n调用结束...\r\n```\r\n很明显，这种方法很繁琐，我们完全可以将其改造一下，如下\r\n\r\n目标类Account，为了与上文区分(下同)，我们定义为Accounts，如下\r\n```\r\npackage springTest;\r\n\r\npublic class Accounts {\r\n\r\n    private String name;\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    public void add(int money) {\r\n        System.out.println(\"给\" + name + \"账户加钱\" + money + \"元\");\r\n    }\r\n\r\n    public void minus(int money) {\r\n        System.out.println(\"给\" + name + \"账户扣钱\" + money + \"元\");\r\n    }\r\n\r\n}\r\n```\r\n切面类，我们定义为AccountsLog，如下\r\n```\r\npackage springTest;\r\n\r\nimport java.lang.reflect.Method;\r\n\r\nimport org.aopalliance.intercept.MethodInterceptor;\r\nimport org.aopalliance.intercept.MethodInvocation;\r\nimport org.springframework.aop.MethodBeforeAdvice;\r\n\r\npublic class AccountsLog implements \r\n    MethodBeforeAdvice, org.springframework.aop.AfterAdvice, MethodInterceptor {\r\n\r\n    @Override\r\n    public Object invoke(MethodInvocation arg0) throws Throwable {\r\n        System.out.println(\"调用方法之前：invocation对象：[\"+ arg0 + \"]\");\r\n        Object rval = arg0.proceed();\r\n        System.out.println(\"调用结束...\");\r\n        return rval;\r\n    }\r\n\r\n    @Override\r\n    public void before(Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用前\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n    }\r\n\r\n\r\n    public void afterReturning(Object returnValue, Method m, Object[] args, Object target) throws Throwable {\r\n        System.out.println(\"在方法调用后\");\r\n        System.out.println(\"执行的方法是\" + m);\r\n        System.out.println(\"方法的参数是\" + args[0]);\r\n        System.out.println(\"目标对象是：\" + target);\r\n        \r\n    }\r\n}\r\n```\r\n该类实现了三个接口，分别是前置，后置和环绕接口，因为我们要拿到相应的参数，所以必须实现接口并重写方法，如果不拿参数，自己写即可不需要实现接口\r\n\r\n配置文件为\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\" \r\n    xmlns:aop=\"http://www.springframework.org/schema/aop\"             \r\n    xsi:schemaLocation=\"                                               \r\n            http://www.springframework.org/schema/beans \r\n            http://www.springframework.org/schema/beans/spring-beans.xsd    \r\n            http://www.springframework.org/schema/context     \r\n            http://www.springframework.org/schema/context/spring-context.xsd    \r\n            http://www.springframework.org/schema/mvc    \r\n            http://www.springframework.org/schema/mvc/spring-mvc.xsd  \r\n            http://www.springframework.org/schema/tx   \r\n            http://www.springframework.org/schema/tx/spring-tx.xsd  \r\n            http://www.springframework.org/schema/aop  \r\n            http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e\r\n\u003cbean id=\"acc\" class=\"springTest.Accounts\"\u003e\r\n    \u003cproperty name=\"userName\" value=\"Java\"/\u003e\r\n\u003c/bean\u003e\r\n\u003cbean id=\"log\" class=\"springTest.AccountsLog\"/\u003e\r\n\u003caop:config proxy-target-class=\"true\" \u003e\r\n\u003caop:aspect ref=\"log\"\u003e\r\n    \u003caop:around pointcut=\"execution(* springTest.Accounts.*(..))\" method=\"invokev\" /\u003e\r\n    \u003caop:before pointcut=\"execution(* springTest.Accounts.*(..))\" method=\"before\"/\u003e\r\n    \u003caop:after pointcut=\"execution(* springTest.Accounts.*(..))\" method=\"afterReturning\"/\u003e\r\n\u003c/aop:aspect\u003e\r\n\u003c/aop:config\u003e\r\n\u003c/beans\u003e\r\n```\r\n这次我们并没有像第一个例子一样单独定义切入点，而是对不同的通知类型单独定义，其实完全可以提出来，这样做是为了演示这种方式，主文件为\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class AccountsMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/accountsBean.xml\");\r\n        Account account = (Account) factory.getBean(\"account\");\r\n        System.out.println(\"第一个add方法\");\r\n        account.add(100);\r\n        System.out.println(\"第二个minus方法\");\r\n        account.minus(200);\r\n    }\r\n\r\n}\r\n```\r\n运行结果为\r\n```\r\n第一个add方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.add(int)\r\n方法的参数是100\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.add(int); target is of class [springTest.AccountImpl]]\r\n给Java账户加钱100元\r\n调用结束...\r\n第二个minus方法\r\n在方法调用前\r\n执行的方法是public abstract void springTest.Account.minus(int)\r\n方法的参数是200\r\n目标对象是：springTest.AccountImpl@12c8a2c0\r\n调用方法之前：invocation对象：[ReflectiveMethodInvocation: public abstract void springTest.Account.minus(int); target is of class [springTest.AccountImpl]]\r\n给Java账户扣钱200元\r\n调用结束...\r\n```\r\n怎么样？完美无缺！！！\r\n\r\n需要特别注意的是AOP的使用，不仅仅要用Spring官方给出的jar，还需要两个jar，分别从这里下载\r\n\r\n+ [https://www.findjar.com/jar/aopalliance/jars/aopalliance-1.0.jar.html](https://www.findjar.com/jar/aopalliance/jars/aopalliance-1.0.jar.html)\r\n+ [http://maven.outofmemory.cn/org.aspectj/aspectjweaver/1.7.4/](http://maven.outofmemory.cn/org.aspectj/aspectjweaver/1.7.4/)\r\n","cover":"/images/Spring-Framework.jpg","link":"analysis-of-aspect-oriented-programming.html","preview":"\u003cp\u003e把通用性非功能性代码的实现方式就叫做面向切面编程，切面是贯穿于业务代码的，这就是AOP。\u003c/p\u003e\n","title":"面向切面编程(Aspect Oriented Programming)浅析"},{"content":"\r\n\r\n第一种方式，(无参创建)通过无参构造器创建一个bean实例\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n\t/*\r\n    public Product() {\r\n        \r\n    }*/\r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am product1!\");\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am product2!\");\r\n    }\r\n}\r\n```\r\n其中默认构造器可以省略，即使没有那么Java类在编译期间也会自动填充一个默认构造器\r\n\r\n然后是配置文件\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"/\u003e\r\n\u003c/beans\u003e\r\n```\r\n再是主方法类\r\n```\r\nackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class ProductMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/productBean.xml\");\r\n        Product product = (Product) factory.getBean(\"pro\", Product.class);\r\n        product.printProduct1();\r\n        product.printProduct2();\r\n    }\r\n}\r\n```\r\n运行结果为\r\n```\r\nHello, I am product1!\r\nHello, I am product2!\r\n```\r\n这里并不会牵扯到依赖注入，因为只是一个类，并没有类之间的依赖关系，所以和正常的Java类一样，不需要编写依赖注入时被注入类的set/get方法。\r\n\r\n但是如果类有构造器而且不是默认构造器，该怎么办？用第一种方法是会报错的，如下\r\n```\r\nException in thread \"main\" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'pro' defined in class path resource [springTest/productBean.xml]: Instantiation of bean failed; nested exception is org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [springTest.Product]: No default constructor found; nested exception is java.lang.NoSuchMethodException: springTest.Product.()\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1076)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBeanInstance(AbstractAutowireCapableBeanFactory.java:1021)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:504)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:475)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:302)\r\n\tat org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:298)\r\n\tat org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:193)\r\n\tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:703)\r\n\tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:760)\r\n\tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:482)\r\n\tat org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:139)\r\n\tat org.springframework.context.support.ClassPathXmlApplicationContext.(ClassPathXmlApplicationContext.java:83)\r\n\tat springTest.ProductMain.main(ProductMain.java:9)\r\nCaused by: org.springframework.beans.BeanInstantiationException: Could not instantiate bean class [springTest.Product]: No default constructor found; nested exception is java.lang.NoSuchMethodException: springTest.Product.()\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:85)\r\n\tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.instantiateBean(AbstractAutowireCapableBeanFactory.java:1069)\r\n\t... 13 more\r\nCaused by: java.lang.NoSuchMethodException: springTest.Product.()\r\n\tat java.lang.Class.getConstructor0(Unknown Source)\r\n\tat java.lang.Class.getDeclaredConstructor(Unknown Source)\r\n\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:80)\r\n\t... 14 more\r\n```\r\n这种情况下第二种方法就显得很有必要了\r\n\r\n第二种方法，(有参通过构造器创建)通过配置文件向构造器传递参数实例化bean\r\n\r\n我们先将Product类改为有构造器参与的形式\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n    \r\n    String product1;\r\n    String product2;\r\n    \r\n    public Product(String product1, String product2) {\r\n        this.product1 = product1;\r\n        this.product2 = product2;\r\n    }\r\n    \r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am \" + product1);\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am \" + product2);\r\n    } \r\n}\r\n```\r\n再通过配置文件传递参数实例化bean(其实就是实例化类)\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cconstructor-arg index=\"0\" value=\"product1\"/\u003e\r\n    \u003cconstructor-arg index=\"1\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n以上配置文件的bean标签的constructor-arg标签的index属性等同于name属性，如下\r\n```\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cconstructor-arg name=\"product1\" value=\"product1\"/\u003e\r\n    \u003cconstructor-arg name=\"product2\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\n```\r\n是同样的功能\r\n\r\n再运行之\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class ProductMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/productBean.xml\");\r\n        Product product = (Product) factory.getBean(\"pro\", Product.class);\r\n        product.printProduct1();\r\n        product.printProduct2();\r\n    }\r\n}\r\n```\r\n结果为\r\n```\r\nHello, I am product1\r\nHello, I am product2\r\n```\r\n当然这只是向一个bean传递参数的一种方式，还有一种方式是通过Setter方式\r\n\r\n第三种，(有参通过Setter方式创建)通过Setter方式传递参数给bean创建其实例\r\n\r\n这种方法自然要对相应的字段编写对应的get/set方法，如下\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n    \r\n    String product1;\r\n    String product2;\r\n    /*\r\n    public Product(String product1, String product2) {\r\n        this.product1 = product1;\r\n        this.product2 = product2;\r\n    }\r\n    */\r\n    public String getProduct1() {\r\n        return product1;\r\n    }\r\n    \r\n    public String getProduct2() {\r\n        return product2;\r\n    }\r\n    \r\n    public void setProduct1(String product1) {\r\n        this.product1 = product1;\r\n    }\r\n    \r\n    public void setProduct2(String product2) {\r\n        this.product2 = product2;\r\n    }\r\n    \r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am \" + product1);\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am \" + product2);\r\n    } \r\n}\r\n```\r\n配置文件只需要把constructor-arg标签改为property即可，如下\r\n```\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cproperty name=\"product1\" value=\"product1\"/\u003e\r\n    \u003cproperty name=\"product2\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\n```\r\n主文件不做改动，仍然是同样的运行结果\r\n\r\n这种情况下你可以注释掉构造器，前提是你没有使用constructor-arg标签传递参数。当然，你也可以二者都使用，如下\r\n```\r\npackage springTest;\r\n\r\npublic class Product {\r\n    \r\n    String product1;\r\n    String product2;\r\n    \r\n    public Product(String product1) {\r\n        this.product1 = product1;\r\n    }\r\n    \r\n    public String getProduct2() {\r\n        return product2;\r\n    }\r\n    public void setProduct2(String product2) {\r\n        this.product2 = product2;\r\n    }\r\n    \r\n    public void printProduct1() {\r\n        System.out.println(\"Hello, I am \" + product1);\r\n    }\r\n\r\n    public void printProduct2() {\r\n        System.out.println(\"Hello, I am \" + product2);\r\n    } \r\n}\r\n\u003cbean name=\"pro\" class=\"springTest.Product\"\u003e\r\n    \u003cconstructor-arg name=\"product1\" value=\"product1\"/\u003e\r\n    \u003cproperty name=\"product2\" value=\"product2\"/\u003e\r\n\u003c/bean\u003e\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class ProductMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/productBean.xml\");\r\n        Product product = (Product) factory.getBean(\"pro\", Product.class);\r\n        product.printProduct1();\r\n        product.printProduct2();\r\n    }\r\n}\r\n```\r\n此外，这里配置文件的属性用的是name而不是id，这两者都可以用而且主文件中`factory.getBean(\"pro\", Product.class)`与`factory.getBean(\"pro\")`是同样的功能，可以自由组合。","cover":"/images/Spring-Framework.jpg","link":"several-ways-to-create-bean-instances-in-spring.html","preview":"\u003cp\u003e无参默认构造器、有参自定义构造器、有参通过Setter方式创建。\u003c/p\u003e\n","title":"Spring中创建Bean实例的几种方式"},{"content":"\r\n\r\n就是变动一下配置文件，改为\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e    \u003c!-- 注意注入类的id可以随意定义，无需与被注入类字段保持一致 -\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" /\u003e\r\n\u003ccontext:annotation-config /\u003e    \u003c!-- 注意这里的代码 --\u003e\r\n\u003c/beans\u003e\r\n```\r\n再在被注入类字段上进行注解\r\n```\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\n\r\npublic class SayHello {\r\n    \r\n    @Autowired\r\n    private HelloWorldSpring helloWorldSpring;\r\n    public HelloWorldSpring getHelloWorldSpring() {\r\n        return helloWorldSpring;\r\n    }\r\n    public void setHelloWorldSpring(HelloWorldSpring helloWorldSpring) {\r\n        this.helloWorldSpring = helloWorldSpring;\r\n    }\r\n    public void sayHello() {\r\n        System.out.println(\"Say Hello:\" + helloWorldSpring.sayHello());\r\n    }\r\n}\r\n```\r\n这种注入方式等同于autowire=\"byType\"。只不过尽可能少用这种方式，缺点如下\r\n\r\n+ 代码可读性差，不容易维护，因为类之间的依赖关系我们只能在代码中找\r\n+ 通用性不好，如果我们哪天不用Spring了，那么我们就得一个个删除注解。","cover":"/images/Spring-Framework.jpg","link":"spring-assembly-via-autowire-annotation.html","preview":"\u003cp\u003eAutowired按byType自动注入，而Resource默认按 byName自动注入。\u003c/p\u003e\n","title":"通过@Autowired注解进行Spring装配"},{"content":"\r\n\r\n先说明，以下是公用代码，只是配置文件不同\r\n```\r\npublic class HelloWorldSpring {\r\n    private String sayContent;\r\n    public String sayHello() {\r\n        System.out.println(\"HelloWorld Spring!\");\r\n        return \"HelloWorld Spring\";\r\n    }\r\n}\r\n\r\npublic class SayHello {\r\n    private HelloWorldSpring helloWorldSpring;\r\n    public HelloWorldSpring getHelloWorldSpring() {\r\n        return helloWorldSpring;\r\n    }\r\n    public void setHelloWorldSpring(HelloWorldSpring helloWorldSpring) {\r\n        this.helloWorldSpring = helloWorldSpring;\r\n    }\r\n    public void sayHello() {\r\n        System.out.println(\"Say Hello:\" + helloWorldSpring.sayHello());\r\n    }\r\n}\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringMain {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"bean.xml\");\r\n        SayHello sayHello = (SayHello) factory.getBean(\"sayHello\");\r\n        sayHello.sayHello();\r\n    }\r\n\r\n}\r\n```\r\nSpring的注入方式有六种，比较常用的有三种自动装配\r\n\r\n第一种自动装配，当被注入类配置文件bean标签中属性autowire的取值为no时，表明不使用自动装配，即必须显式的使用\u003cref\u003e标签明确的指定注入的bean\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" autowire=\"no\"\u003e    \u003c!-- 请注意这里的autowire属性及其值 --\u003e\r\n    \u003cproperty name=\"helloWorldSpring\" ref=\"helloWorldSpring\"/\u003e    \u003c!-- 还有这里的property标签 --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n可见，这种方式无异于脱了裤子放屁，直接去掉autowire属性即可，就和前几篇文章用的注入方式一致\r\n\r\n第二种自动装配，当被注入类配置文件bean标签中属性autowire的取值为byName时，表明根据属性名自动装配，那么将会检查Spring容器，根据名字查找属性完全一致的Bean然后进行注入。简言之就是与被注入类中字段名称相同的配置文件中的bean标签的id值代表的class类对象将会被装配(注入)，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" autowire=\"byName\"\u003e    \u003c!-- 请注意这里的autowire属性及其值 --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n第三种自动装配，当被注入类配置文件bean标签中属性autowire的取值为byType时，表明按类型自动装配，即被注入类字段的数据类型(为类)与配置文件中bean标签的注入类class属性的类型名一致时，才会装配，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\" autowire=\"byType\"\u003e    \u003c!-- 请注意这里的autowire属性及其值 --\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n需要特别注意的是，被注入类中的相关字段一定要有对应的set方法(和get方法)，不然byName和byType会报错NPE,no和以前的那种装配方式则会报错如下\r\n```\r\nCaused by: org.springframework.beans.NotWritablePropertyException: Invalid property 'helloWorldSpring' of bean class [SayHello]: Bean property 'helloWorldSpring' is not writable or has an invalid setter method. Does the parameter type of the setter match the return type of the getter?\r\n```","cover":"/images/Spring-Framework.jpg","link":"three-other-common-ways-of-spring-injection-and-autowire.html","preview":"\u003cp\u003eSpring的注入方式有六种，比较常用的有三种自动装配。\u003c/p\u003e\n","title":"Spring注入的另外三种常用方式与AutoWire"},{"content":"\r\n\r\nSpring中读取配置文件的三种方式\r\n```\r\nResource res = new ClassPathResource(\"packageName/bean.xml\");\r\nBeanFactory factory = new XmlBeanFactory(res);    //通过XmlBeanFactory类读取\r\n\r\nApplicationContext factory = new ClassPathXmlApplicationContext(\"packageName/bean.xml\");    //通过ClassPathXmlApplicationContext类读取\r\n\r\nApplicationContext factory = new FileSystemXmlApplicationContext(new String[] {\"bean.xml的绝对路径\"})\r\n或者\r\nApplicationContext factory = new FileSystemXmlApplicationContext(\"bean.xml的绝对路径\")    //通过FileSystemXmlApplicationContext类读取\r\n```\r\n单例Bean就是Main文件在运行中只会得到一个Bean实例，即每次得到的Bean实例是相同的，也称无状态Bean，一般把公用的资源可以保存为单例Bean；\r\n\r\n多例Bean就是Main文件在运行中每getBean()都会得到一个截然不同的Bean实例，也称有状态Bean，那么就可以用有状态Bean来保存比较私有的资源。\r\n\r\n单例和多例Bean可以在配置文件中的bean标签中设置，需要特别注意的是，旧版Spring中是通过singleton属性来设置的，当值为true时为单例无状态Bean，当值为false时为多例有状态Bean；在新版Spring中，是通过scope属性来设置的，当值为prototype时为有状态多例Bean，当值为singleton时为单例无状态Bean。\r\n\r\n一个简单的例子来说明单例和多例Bean\r\n\r\n这是一个提供随机数的类\r\n```\r\npackage springTest;\r\n\r\npublic class Randoms {\r\n    private int i  = (int) (100 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(i);\r\n    }\r\n}\r\n```\r\n配置文件设置其为多例Bean，由于和其它类没有依赖关系，所以只需要定义bean即可，无需定义其他的属性\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"ran\" class=\"springTest.Randoms\" scope=\"prototype\"/\u003e\r\n\u003c/beans\u003e\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringRandoms {\r\n\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/RandomsBean.xml\");\r\n        Randoms r1 = (Randoms)factory.getBean(\"ran\");\r\n        Randoms r2 = (Randoms)factory.getBean(\"ran\");\r\n        System.out.println(r1 == r2);\r\n        r1.printRandom();\r\n        r2.printRandom();\r\n    }\r\n\r\n}\r\n```\r\n运行结果为\r\n```\r\nfalse\r\n28\r\n15\r\n```\r\n通过配置文件将其设置为单例Bean，如下\r\n```\r\n\u003cbean id=\"ran\" class=\"springTest.Randoms\" scope=\"singleton\"/\u003e\r\n```\r\n那么运行结果为\r\n```\r\ntrue\r\n93\r\n93\r\n```","cover":"/images/Spring-Framework.jpg","link":"spring-reads-configuration-files-in-three-ways-single-and-multiple-beans.html","preview":"\u003cp\u003eSpring中读取配置文件的三种方式。\u003c/p\u003e\n","title":"Spring中读取配置文件的三种方式及单例多例Bean"},{"content":"\r\n\r\n所谓Spring依赖注入，指的是类之间对象实例的传递方式。传统的类间对象(或参数)传递是通过实例化一个类，然后将该对象传递给另一个类的方法,而依赖注入则是通过配置文件将一个类的实例直接传递给另一个类的变量或者方法，根本不用显式的new对象然后再作为参数传递。如下\r\n```\r\npublic class SayHello {\r\n    private HelloWorldSpring helloWorldSpring;\r\n    public HelloWorldSpring getHelloWorldSpring() {\r\n        return helloWorldSpring;\r\n    }\r\n    public void setHelloWorldSpring(HelloWorldSpring helloWorldSpring) {\r\n        this.helloWorldSpring = helloWorldSpring;\r\n    }\r\n    public void sayHello() {\r\n        System.out.println(\"Say Hello:\" + helloWorldSpring.sayHello());\r\n    }\r\n}\r\npublic class HelloWorldSpring {\r\n    private String sayContent;\r\n    public String sayHello() {\r\n        System.out.println(\"HelloWorld Spring!\");\r\n        return \"HelloWorld Spring\";\r\n    }\r\n}\r\npublic class HelloMain {\r\n\r\n    public static void main(String[] args) {\r\n        SayHello sayHello = new SayHello();\r\n        // new实例然后传递给调用者，耦合度高\r\n        sayHello.setHelloWorldSpring(new HelloWorldSpring());\r\n        sayHello.sayHello();\r\n    }\r\n\r\n}\r\n```\r\n以上HelloMain是传统的注入方式，明显耦合度高，但是依赖注入可不这么干，是通过配置文件来实现注入，如下\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"helloWorldSpring\" class=\"HelloWorldSpring\"/\u003e\r\n\u003cbean id=\"sayHello\" class=\"SayHello\"\u003e\r\n    \u003cproperty name=\"helloWorldSpring\" ref=\"helloWorldSpring\"/\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringMain {\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"bean.xml\");\r\n        SayHello sayHello = (SayHello) factory.getBean(\"sayHello\");\r\n        sayHello.sayHello();\r\n    }\r\n}\r\n```\r\n`ApplicationContext factory = new ClassPathXmlApplicationContext(\"bean.xml\")`读取配置文件，然后通过getBean()方法获取一个目标为sayHello的对象，其实就是通过配置文件实例化了SayHello类，sayHello对应bean.xml文件里的SayHello类的id。\r\n\r\n特别注意的是此处代码并没有在包中(一个空包，即文件头没有package声明)，所以bean文件中bean标签的class属性并没有加包名前缀，同理SpringMain读取配置文件也没有加包名路径。\r\n\r\n以上就是Spring依赖注入。\r\n\r\n至于Spring控制反转，则说的是类的实例化不用通过new显式的实现，而是将创建对象的控制权由自写代码交给Spring容器(或Spring jar包)，即控制反转。上述SpringMain可以明显的看出，sayHello对象的创建是通过`factory.getBean()`方法实现的，而不是new操作符。\r\n\r\n简言之，控制反转说的是类的初始化(创建)不用new而交给Spring容器，依赖注入说的是通过配置文件实现类间的对象传递。其目的就是解耦.\r\n\r\n再通过面向接口编程深入理解IoC与DI\r\n\r\n面向接口编程的本质是缩小修改的影响范围,先看一个实际的例子，有一个提供随机数生成的类，有一个专门使用随机数的类，如果用常规思维来实现的话，无非就是如下的代码\r\n```\r\npackage springTest;\r\n\r\npublic class Random {\r\n    private int randomNum = (int) (50 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(randomNum);\r\n    }\r\n}\r\npackage springTest;\r\n\r\npublic class TestMain {\r\n    public static void main(String[] args) {\r\n        new Random().printRandom();\r\n    }\r\n}\r\n```\r\n而面向接口编程则是如下的代码\r\n\r\n先是接口，向外部调用者提供用于返回Random对象的createRandom方法\r\n```\r\npackage springTest;\r\n\r\npublic interface HelloInterface {\r\n    public abstract Random createRandom();\r\n}\r\n```\r\n再是接口的实现，外部调用者通过createRandom得到Random对象时，是直接和接口打交道，根本不知道有该实现类的存在\r\n```\r\npackage springTest;\r\n\r\npublic abstract class HelloAbstract implements HelloInterface {\r\n    @SuppressWarnings(\"unused\")\r\n    private Random random;\r\n    public void setRandom(Random random) {\r\n        this.random = random;\r\n    }\r\n    public abstract Random createRandom();\r\n}\r\n```\r\n实际上，该实现类就是在配置文件中直接将Random类注入到其中，由于实现类实现了接口，而实现类被注入了Random类，那么实现类就可以当作接口与Random类之间的桥梁，这个桥梁是通过配置文件依赖注入建造的。\r\n\r\nRandom类如下\r\n```\r\npackage springTest;\r\n\r\npublic class Random {\r\n    private int randomNum = (int) (50 * Math.random());\r\n    public void printRandom() {\r\n        System.out.println(randomNum);\r\n    }\r\n}\r\n```\r\nSpringMain如下\r\n```\r\npackage springTest;\r\n\r\nimport org.springframework.context.ApplicationContext;\r\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\r\n\r\npublic class SpringMain {\r\n    @SuppressWarnings(\"resource\")\r\n    public static void main(String[] args) {\r\n        ApplicationContext factory = new ClassPathXmlApplicationContext(\"springTest/bean.xml\");\r\n        HelloInterface hi = (HelloInterface) factory.getBean(\"hello\");\r\n        Random random = hi.createRandom();\r\n        random.printRandom();\r\n    }\r\n\r\n}\r\n```\r\n配置文件为\r\n```\r\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e\r\n\u003cbeans xmlns=\"http://www.springframework.org/schema/beans\"\r\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xmlns:p=\"http://www.springframework.org/schema/p\"\r\n    xmlns:context=\"http://www.springframework.org/schema/context\"\r\n    xmlns:util=\"http://www.springframework.org/schema/util\"\r\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\r\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd\r\n        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd\"\u003e\r\n\u003cbean id=\"ran\" class=\"springTest.Random\"/\u003e\r\n\u003cbean id=\"hello\" class=\"springTest.HelloAbstract\"\u003e\r\n    \u003clookup-method name=\"createRandom\" bean=\"ran\"/\u003e\r\n\u003c/bean\u003e\r\n\u003c/beans\u003e\r\n```\r\n可见，是通过lookup-method标签将id为ran的bean注入到id为hello的bean的createRandom方法中，即createRandom方法的返回值就是这个id为ran的bean(对象)。","cover":"/images/Spring-Framework.jpg","link":"spring-dependency-injection-and-control-inversion-and-its-application-in-interface-oriented-programming.html","preview":"\u003cp\u003eSpring依赖注入，指的是类之间对象实例的传递方式；将创建对象的控制权由自写代码交给Spring容器(或Spring jar包)，即控制反转。\u003c/p\u003e\n","title":"Spring依赖注入(DI)与控制反转(IoC)及在面向接口编程上的应用"},{"content":"\r\n\r\n## 一、Predicate接口及其test方法的签名如下\r\n\r\n```\r\nPredicate\u003cT\u003e\r\nboolean test\u003cT t\u003e\r\n```\r\n\r\n即泛型T为test形参的数据类型，也就是test判断数据类型为T的形参是否满足条件\r\n\r\n## 二、Function接口及其apply方法的签名如下\r\n\r\n```\r\nFunction\u003cT, R\u003e\r\nR apply(T t)\r\n```\r\n\r\n即Function接口共有两种泛型，分别是T和R，从apply方法来看其中T为输入的数据类型，R为输出的数据类型，也就是apply方法将操作施加在类型为T的参数身上然后返回类型为R的返回值。\r\n\r\n## 三、Consumer接口及其accept方法的签名如下\r\n\r\n```\r\nComsumer\u003cT\u003e\r\nvoid accept(T t)\r\n```\r\n\r\n即Cosumer接口只有一种类型，为T，accept方法是直接对原对象进行操作，这些都是在编写代码时要注意的。\r\n\r\n## 四、示例\r\n\r\n用一个例子说明之，也是上文的一个例子，只不过综合运用了这三种函数接口\r\n\r\n```\r\npublic class Student {\r\n\r\n    String name;\r\n    double score;\r\n    \r\n    public Student(String name, double score) {\r\n        this.name = name;\r\n        this.score = score;\r\n    }\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    public void setScore(double score) {\r\n        this.score = score;\r\n    }\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public double getScore() {\r\n        return score;\r\n    }\r\n}\r\n```\r\n\r\n```\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.function.Consumer;\r\nimport java.util.function.Function;\r\nimport java.util.function.Predicate;\r\n\r\npublic class StudentTest {\r\n\r\n    public static void main(String[] args) {\r\n        List\u003cStudent\u003e list = Arrays.asList(new Student[] {\r\n            new Student(\"Feily Zhang\", 95d), new Student(\"Haoyue Li\", 100d),\r\n            new Student(\"Daji Luobu\", 80d), new Student(\"Xin Chen\", 94d)\r\n        });\r\n\r\n        List\u003cStudent\u003e result = filter(list, student -\u003e student.getScore() \u003e 90);\r\n        for (Student ele : result) {\r\n            System.out.println(ele.getName() + \" , \" + ele.getScore());\r\n        }\r\n\r\n        List\u003cString\u003e resultMap = map(list, student -\u003e student.getScore() \u003e 90 ? student.getName() : null);\r\n        for (String e : resultMap) {\r\n            if (e != null) {\r\n                System.out.println(e);\r\n            }\r\n        }\r\n\r\n        forEach(list, student -\u003e student.setName(student.getName().toLowerCase()));\r\n        for (Student e : list) System.out.println(e.getName());\r\n    }\r\n\r\n    public static \u003cE\u003e List\u003cE\u003e filter(List\u003cE\u003e list, Predicate\u003cE\u003e pred) {\r\n        List\u003cE\u003e retList  = new ArrayList\u003cE\u003e();\r\n        for (E e : list) {\r\n            if (pred.test(e)) {\r\n                retList.add(e);\r\n            }\r\n        }\r\n        return retList;\r\n    }\r\n    \r\n    public static \u003cT, R\u003e List\u003cR\u003e map (List\u003cT\u003e list, Function\u003cT, R\u003e mapper) {\r\n        List\u003cR\u003e reList = new ArrayList\u003cR\u003e(list.size());\r\n        for (T e : list) {\r\n            reList.add(mapper.apply(e));\r\n        }\r\n        return reList;\r\n    }\r\n    \r\n    public static \u003cT\u003e void forEach(List\u003cT\u003e list, Consumer\u003cT\u003e consumer) {\r\n        for (T e : list) {\r\n            consumer.accept(e);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n有如下输出\r\n\r\n```\r\nFeily Zhang , 95.0\r\nHaoyue Li , 100.0\r\nXin Chen , 94.0\r\nFeily Zhang\r\nHaoyue Li\r\nXin Chen\r\nfeily zhang\r\nhaoyue li\r\ndaji luobu\r\nxin chen\r\n```","cover":"/images/java.jpg","link":"usage-of-predicate-function-and-consumer-interfaces-in-java-functional-programming.html","preview":"\u003cp\u003ePredicate、Function、Consumer接口的用法。\u003c/p\u003e\n","title":"Java函数式编程之Predicate、Function、Consumer接口的用法"},{"content":"\r\n\r\nJava8定义了大量的预定义函数式接口，用于常见的代码传递(其实就是参数化函数)，这些函数定义在包java.util.function下,每个接口只有一个抽象方法\r\n\r\nPredicate函数接口的接口签名如下\r\n\r\n```\r\nPredicate\u003cT\u003e\r\n```\r\n\r\n其唯一的方法test的签名如下\r\n\r\n```\r\nboolean test(T t)    //谓词，判断输入是否满足条件\r\n```\r\n\r\n用一个例子来简单说明，首先定义序列化学生姓名和成绩的JavaBean，如下\r\n\r\n```\r\npublic class Student {\r\n\r\n    String name;\r\n    double score;\r\n    \r\n    public Student(String name, double score) {\r\n        this.name = name;\r\n        this.score = score;\r\n    }\r\n    \r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    public void setScore(double score) {\r\n        this.score = score;\r\n    }\r\n    \r\n    public String getName() {\r\n        return name;\r\n    }\r\n    \r\n    public double getScore() {\r\n        return score;\r\n    }\r\n}\r\n```\r\n\r\n再在main方法所在的主文件中重写有Predicate和test方法参与的函数，如下\r\n\r\n```\r\npublic static \u003cE\u003e List\u003cE\u003e filter(List\u003cE\u003e list, Predicate\u003cE\u003e pred) {\r\n    List\u003cE\u003e retList  = new ArrayList\u003cE\u003e();\r\n    for (E e : list) {\r\n        if (pred.test(e)) {\r\n            retList.add(e);\r\n        }\r\n    }\r\n    return retList;\r\n}\r\n```\r\n\r\n该方法通过Predicate的test过滤不符合条件的Student，正是谓词的作用\r\n\r\n那么再定义Student型List列表，通过arrays.asList方法将Student型数组转化为列表，如下\r\n\r\n```\r\nList\u003cStudent\u003e list = Arrays.asList(new Student[] {\r\n    new Student(\"Feily Zhang\", 95d), new Student(\"Haoyue Li\", 100d),\r\n    new Student(\"Daji Luobu\", 80d), new Student(\"Xin Chen\", 94d)\r\n});\r\n```\r\n\r\n然后就需要调用filter方法，传入list，并编写Lambda表达式作为函数接口Predicate的实现，如下\r\n\r\n```\r\nList\u003cStudent\u003e result = filter(list, student -\u003e student.getScore() \u003e 90);\r\n```\r\n\r\n这样过滤的结果就会全部保存在result列表中\r\n\r\n完整的主文件代码如下\r\n\r\n```\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.function.Predicate;\r\n\r\npublic class StudentTest {\r\n\r\n    public static void main(String[] args) {\r\n        List\u003cStudent\u003e list = Arrays.asList(new Student[] {\r\n            new Student(\"Feily Zhang\", 95d), new Student(\"Haoyue Li\", 100d),\r\n            new Student(\"Daji Luobu\", 80d), new Student(\"Xin Chen\", 94d)\r\n        });\r\n        List\u003cStudent\u003e result = filter(list, student -\u003e student.getScore() \u003e 90);\r\n        for (Student ele : result) {\r\n            System.out.println(ele.getName() + \" , \" + ele.getScore());\r\n        }\r\n    }\r\n\r\n    public static \u003cE\u003e List\u003cE\u003e filter(List\u003cE\u003e list, Predicate\u003cE\u003e pred) {\r\n        List\u003cE\u003e retList  = new ArrayList\u003cE\u003e();\r\n        for (E e : list) {\r\n            if (pred.test(e)) {\r\n                retList.add(e);\r\n            }\r\n        }\r\n        return retList;\r\n    }\r\n}\r\n```\r\n\r\n结果为\r\n\r\n```\r\nFeily Zhang , 95.0\r\nHaoyue Li , 100.0\r\nXin Chen , 94.0\r\n```","cover":"/images/java.jpg","link":"usage-of-predicate-interface-in-java-functional-programming.html","preview":"\u003cp\u003eJava8定义了大量的预定义函数式接口，用于常见的代码传递(其实就是参数化函数)，这些函数定义在包java.util.function下,每个接口只有一个抽象方法.\u003c/p\u003e\n","title":"Java函数式编程之Predicate接口的用法"},{"content":"\r\n\r\n泛型不仅仅是类层面的，也可以单独给方法定义，形式是在方法的声明的返回值类型前加上`\u003cT\u003e`，这是只有一种泛型的情况，如果是多种泛型，那么用逗号隔开即可，然后就可以在形参列表使用了。如下，我们实现一个数组的相关方法\r\n\r\n## 一、泛型方法\r\n\r\n```\r\npublic class Array {\r\n\r\n    public static  int indexFirstOf(T[] array, T ele) {\r\n        for (int i = 0; i \u003c array.length; i++) { \r\n            if (array[i].equals(ele)) { \r\n                return i; \r\n            } \r\n        } \r\n        return -1; \r\n    } \r\n\r\n    public static  int indexLastOf(T[] array, T ele) {\r\n        for (int i = array.length - 1; i \u003e= 0; i--) {\r\n            if (array[i].equals(ele)) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public static  boolean isExist(T[] array, T ele) {\r\n        for (T e : array) {\r\n            if (e.equals(ele)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n}\r\npublic class ArrayTest {\r\n\r\n    public static void main(String[] args) {\r\n        String[] string = {\"Zhang\", \"Peng\", \"Fei\", \"Zhang\"};\r\n        System.out.println(Array.indexFirstOf(string, \"Zhang\"));\r\n        System.out.println(Array.indexLastOf(string, \"Zhang\"));\r\n        System.out.println(Array.isExist(string, \"Zhang\"));\r\n        System.out.println(Array.isExist(string, \"feily\"));\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\n0\r\n3\r\ntrue\r\nfalse\r\n```\r\n\r\n## 二、泛型接口\r\n\r\n接口也可以是泛Comparator型的，注意是接口层面而不是接口中的抽象方法，Comparable和Comparator接口都是泛型的，代码如下\r\n\r\n```\r\npublic interface Comparable {\r\n    public int comparaTo(T o);\r\n}\r\npublic interface comparator {\r\n    int compare(T o1, T o2);\r\n    boolean equals(Object obj);\r\n}\r\n```\r\n\r\n实现接口时，应该指定具体的类型，比如，对于Integer类，实现代码是\r\n\r\n```\r\npublic final class Integer extends Number implements Comparable {\r\n    public int comparaTo(Integer anotherInteger) {\r\n\t      return compare(this.value, anotherInteger.value);\r\n    }\r\n}\r\n```\r\n\r\n而String类内部的一个Comparator接口实现为\r\n\r\n```\r\nprivate static class CaseInsensitiveComparator implements Comparator {\r\n    public int compare(String s1, String s2) {\r\n        // ...\r\n    }\r\n}\r\n```","cover":"/images/java.jpg","link":"generic-method-and-generic-interface.html","preview":"\u003cp\u003e泛型不仅仅是类层面的，也可以单独给方法定义，形式是在方法的声明的返回值类型前加上\u003ccode\u003e\u0026lt;T\u0026gt;\u003c/code\u003e，这是只有一种泛型的情况，如果是多种泛型，那么用逗号隔开即可，然后就可以在形参列表使用了。\u003c/p\u003e\n","title":"泛型方法与泛型接口"},{"content":"\r\n\r\n泛型，即广泛的类型，也就是不指定数据类型，而是在创建对象的时候在根据实际情况设置数据类型，一个简单的泛型类如下\r\n\r\n```\r\npublic class Pair\u003cT\u003e {\r\n\t\r\n    T first;\r\n    T second;\r\n\t\r\n    public Pair() {\r\n\t\t\r\n    }\r\n\t\r\n    public Pair(T first, T second) {\r\n        this.first = first;\r\n        this.second = second;\r\n    }\r\n\t\r\n    public void setFirst(T first) {\r\n        this.first = first;\r\n    }\r\n\t\r\n    public void setSecond(T second) {\r\n        this.second = second;\r\n    }\r\n\t\r\n    public T getFirst() {\r\n        return first;\r\n    }\r\n    \r\n    public T getSecond() {\r\n        return second;\r\n    }\r\n\t\r\n}\r\n```\r\n\r\n我们用这个泛型类实现简单的JavaBean，那么其中的参数就可以在我们new对象时根据实际情况制定，可以是任意类型(包装类)，如下\r\n\r\n```\r\npublic class Main {\r\n\r\n    public static void main(String[] args) {\r\n        Pair\u003cString\u003e pair = new Pair\u003cString\u003e();\r\n        pair.setFirst(\"hello\");\r\n        pair.setSecond(\"world\");\r\n        System.out.println(pair.getFirst() + \" \" + pair.getSecond());\r\n\t\t\r\n        Pair\u003cInteger\u003e pair2 = new Pair\u003cInteger\u003e();\r\n        pair2.setFirst(100);\r\n        pair2.setSecond(200);\r\n        System.out.println(pair2.getFirst() + pair2.getSecond());\r\n    }\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nhello world\r\n300\r\n```\r\n\r\n同样的功能也可以使用Object类型实现，如下\r\n\r\n```\r\npublic class Pair1 {\r\n\r\n    Object first;\r\n    Object second;\r\n    \r\n    public Pair1() {\r\n        \r\n    }\r\n    \r\n    public Pair1(Object first, Object second) {\r\n        this.first = first;\r\n        this.second = second;\r\n    }\r\n    \r\n    public void setFirst(Object first) {\r\n        this.first = first;\r\n    }\r\n    \r\n    public void setSecond(Object second) {\r\n        this.second = second;\r\n    }\r\n    \r\n    public Object getFirst() {\r\n        return first;\r\n    }\r\n    \r\n    public Object getSecond() {\r\n        return second;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n```\r\npublic class Pair1Main {\r\n\r\n    public static void main(String[] args) {\r\n        Pair1 pair1 = new Pair1();\r\n        pair1.setFirst(\"hello\");\r\n        pair1.setSecond(\"world\");\r\n        System.out.println((String)pair1.getFirst() + \" \" + (String)pair1.getSecond());\r\n        Pair1 pair2 = new Pair1();\r\n        pair2.setFirst(100);\r\n        pair2.setSecond(200);\r\n        System.out.println((Integer)pair2.getFirst() + (Integer)pair2.getSecond());\r\n    }\r\n\r\n}\r\n```\r\n\r\n与泛型实现有着同样的输出\r\n\r\n这两种方式有什么区别呢？\r\n\r\n对于泛型类，Java编译器会将泛型代码转换为普通的非泛型代码，这种转换叫做**擦除**，即将类型参数T擦除，替换为Object并插入必要的强制类型转换，也就是说泛型类被擦除之后会变成上述带有Object的代码。\r\n\r\n这样做有什么好处呢？既然这么麻烦为什么不直接用Object呢？\r\n\r\n泛型的好处为：**更好的安全性和更好的可读性**。\r\n\r\n如果用Object实现可变类型的话，那么如果在代码编写过程中，开发环境和编译器并不能发现错误就会导致bug，但是如果用泛型的话开发环境和编译器会直接给我们报错，安全性更强；而且通过使用泛型，可以省去强制类型转换，方便了很多，可读性明显提升。\r\n","cover":"/images/java.jpg","link":"analysis-of-java-generics.html","preview":"\u003cp\u003e泛型，即广泛的类型，也就是不指定数据类型，而是在创建对象的时候在根据实际情况设置数据类型。\u003c/p\u003e\n","title":"Java泛型浅析"},{"content":"\r\n\r\n我们的太阳处于核力和引力的微妙平衡状态，核力倾向于以亿万个氢弹的力量将星球炸开，而引力则倾向于将星球压缩至淹没，在这两种力的作用下，一颗恒星就变得成熟起来。\r\n\r\n当一团许多倍于我们太阳系的氢云被自身的引力收缩时，一颗恒星就会诞生，引力收缩气体并对其加热，引力能逐渐转换为氢原子的动能。通常情况下，气态氢内的质子的排斥电荷足以将被收缩的质子分开，但是在温度升高到绝对温度10^8-10^9开时，质子(氢原子核)的动能就会克服静电的排斥力，质子从而融合在一起并发生热核反应，从而核力取代电磁力占据主导地位，两个氢核“聚合”为氦，同时释放出巨大的能量。\r\n\r\n氢“聚合”为氦，之所以会释放出巨大的能量，是因为氢原子中的质子比氦原子中的质子重，那么就会产生质量盈余，这样盈余的质量就会根据爱因斯坦质能方程转化为能量。换句话说，释放出来的能量，是氢原子相对于氦原子的额外质量，这些质量等于释放出的能量与光速平方的比值。这样恒星就会因聚变燃烧，从而发光。\r\n\r\n但是氢原子总有聚变完的一天，那么氢原子消耗殆尽之时，恒星就会被氦原子充斥，氦原子可以看做是氢原子燃烧的废料。那么此时，核力将会变小，引力重新占上风，以至于继续压缩恒星，那么在这种收缩下恒星的温度继续升高，以至于氦原子可以燃烧并释放能量，那么燃烧后的氦原子的废料将会是锂和碳(遵循结合能曲线)。虽然废氦还可以燃烧，但是恒星的尺寸是越来越小了(因为燃料都被烧了)，但是他的温度非常高(不然废氦也无法燃烧)，从而恒星的大气层会极速膨胀。此时，恒星就不再是恒星，而是红巨星。也就意味着原先距离恒星近的星球会被如今的红巨星蒸发掉，当然这也是50亿年后的地球的命运。\r\n\r\n当废氦也消耗殆尽时，那么核燃炉将会熄灭。引力又再一次战胜核力占据压倒性优势，红巨星会在引力作用下继续坍缩，变成白矮星，也就是全部质量被压缩为地球那么大的一个小小的恒星。\r\n\r\n白矮星并不明亮，因为是燃烧废氦的结果，但是还尚未到达结合能曲线底部，也就是说白矮星还可以通过质能方程燃烧结合能曲线底部以上，氦原子以下的原子燃料继续在引力压缩恒星而产生的高温作用下燃烧。等到达结合能曲线的底部之后，恒星的内部将会被重元素(比如铁)充斥，也就无法再燃烧，恒星彻底死亡，由白矮星变为暗淡的矮星。引力再次占据主导地位，继续压缩恒星，星体的温度爆炸性上升几千倍，达到上万亿度，此时，矮星的铁核坍缩，其外层被炸毁，同时释放出星系中已知的最巨大的爆发能量，成为一个被称为超新星的爆炸恒星。一个超新星爆发时的亮度足以超过银河系上千亿颗恒星的整体亮度。\r\n\r\n超新星爆发之后，会留下一个完全死亡的星球，即中子星，只有曼哈顿大小，其密度非常大，大到所有的中子互相紧挨在一起。尽管中子星几乎看不见(恒星燃烧后的最终废料，即被重元素充斥，密度非常大，在强大的质量的作用下中子星有着强大的引力场，连光也无法逃逸，所以我们看不到，事实上，如果一个恒星是我们太阳的10-50倍，那么即使该恒星变成了中子星，那么引力还是会继续压缩它，此时没有核力抵抗引力的压缩，那么就无法阻止该恒星的最终坍缩，此时，就会变成广为人知的黑洞，黑洞仍然继承了中子星的特性，高密度、强引力场，所以光无法逃逸但是可以围绕其旋转，而进入黑洞视界内的任何物质都无法逃逸，都会被强大的引力压缩到粉碎)，但是我们仍然可以用仪器探测到。旋转的中子星会发出某些放射线，他们的作用就像外空间的宇宙灯塔，而在我们看来就会是闪烁着的星星，被称为脉冲星。\r\n\r\n当然，这并不意味着恒星的彻底死亡，这只是另一颗恒星诞生的开始，超新星爆炸后喷射出的星际物质与混合气体集聚到一个富含氢的新星中产生二代恒星，又继续上演恒星的兴衰史。\r\n\r\n事实上，把恒星的兴衰过程反方向重演，就是原子弹和氢弹，即通过结合能曲线的另一端，裂变铀元素，一次性跳到曲线的底部(铁元素)，爆发的能量相当大是因为铀在核裂变过程中的产物(铯和钾)中的质子的平均重量小于铀中的质子的平均重量，那么盈余的质量会通过质能方程被一次性转化为能量，这就是原子弹的能量来源。\r\n\r\n最后，再次感谢天才而又伟大的爱因斯坦！","cover":"/images/FixedStar.jpg","link":"the-rise-and-fall-of-stars-once-born-it's-designed-to-be-eternal.html","preview":"\u003cp\u003e我们的太阳处于核力和引力的微妙平衡状态，核力倾向于以亿万个氢弹的力量将星球炸开，而引力则倾向于将星球压缩至淹没，在这两种力的作用下，一颗恒星就变得成熟起来。\u003c/p\u003e\n","title":"恒星兴衰史:一诞生就注定永恒"},{"content":"\r\n\r\n超弦理论中，弦的大小不到质子的10^19倍(因而尚且观测不到)且是振动的，每种振动模式代表一种独特的共振或粒子(即粒子不是一个点，而是以某种模式振动的弦)。电子并不比中微子更基本，这是由于我们的显微镜还不够强大，无法观测到更深层的结构，根据弦理论，如果我们能把点粒子放大，那么我们就会看到一个小的振动弦，也就是说物质本质上是由这个振动弦产生的(由于振动而产生的一种“和声”，就像小提琴可以组合出无限多的和声，振动弦也可以构造出无限数量的物质形式，其实这样就明确解释了自然界中粒子的丰富性)，同样，物理定律可以被比作弦上所允许的和声定律，那么由无数的振动弦组成的宇宙就可以被当做一首交响曲了。","cover":"/images/Strings.jpg","link":"strings-particles-matter-and-the-universe-in-string-theory.html","preview":"\u003cp\u003e超弦理论中，弦的大小不到质子的10^19倍(因而尚且观测不到)且是振动的，每种振动模式代表一种独特的共振或粒子(即粒子不是一个点，而是以某种模式振动的弦)。\u003c/p\u003e\n","title":"弦理论中的弦、粒子、物质以及宇宙"},{"content":"\r\n\r\n## 一、比较常见的异常\r\n\r\n### 1.1 NullPointerException\r\n\r\n先看一段代码\r\n\r\n```\r\npublic class ExceptionTest {\r\n\r\n    public static void main(String[] args) {\r\n\t      String string = null;\r\n\t      string.indexOf('s');\r\n\t      System.out.println(\"end\");\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nException in thread \"main\" java.lang.NullPointerException\r\n\tat ExceptionTest.main(ExceptionTest.java:6)\r\n```\r\n\r\n空指针异常，即被擦操作对象不存在，即空指针，那么就会抛出该异常。\r\n\r\n### 1.2 NumberFormatException\r\n\r\n```\r\nimport java.util.Scanner;\r\n\r\npublic class ExceptionTest {\r\n\r\n    public static void main(String[] args) {\r\n\t      System.out.println(Integer.parseInt(new Scanner(System.in).next()));\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\na\r\nException in thread \"main\" java.lang.NumberFormatException: For input string: \"a\"\r\n\tat java.lang.NumberFormatException.forInputString(Unknown Source)\r\n\tat java.lang.Integer.parseInt(Unknown Source)\r\n\tat java.lang.Integer.parseInt(Unknown Source)\r\n\tat ExceptionTest.main(ExceptionTest.java:6)\r\n```\r\n\r\n即被操作对象不是数字格式，就会抛出该异常。\r\n\r\n### 1.3 ArrayIndexOutOfBoundsException\r\n\r\n```\r\npublic class ExceptionTest {\r\n\r\n    public static void main(String[] args) {\r\n        int[] array = {0, 1, 2};\r\n        System.out.println(array[array.length]);\r\n    }\r\n\r\n}\r\n```\r\n\r\n```\r\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 3\r\n\tat ExceptionTest.main(ExceptionTest.java:6)\r\n```\r\n\r\n数组下标越界，就会抛出该异常\r\n\r\n### 1.4 StringIndexOutOfBoundsException\r\n\r\n```\r\npublic class ExceptionTest {\r\n\r\n    public static void main(String[] args) {\r\n        String string = \"hello , world\";\r\n        System.out.println(string.substring(string.length() + 1));\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nException in thread \"main\" java.lang.StringIndexOutOfBoundsException: String index out of range: -1\r\n\tat java.lang.String.substring(Unknown Source)\r\n\tat ExceptionTest.main(ExceptionTest.java:6)\r\n```\r\n\r\n对String型操作数进行操作，超出其length就会触发该异常\r\n\r\n## 二、对异常的处理\r\n\r\n当然是使用try-catch-finally语句进行处理\r\n\r\n可能的组合如下\r\n\r\n* try-catch 捕获异常并处理\r\n* try-finally 不捕获异常，即异常会抛出，但仍会执行finally中的语句，即异常并不会中断程序的执行(仅限于finally中的语句会执行)\r\n* try-catch-finally 捕获并处理异常，然后一定会执行finally中的语句。\r\n\r\n需要注意的是如果没有用try-catch-finally语句处理异常，那么就会在异常发生的位置中断程序的执行。 示例如下\r\n\r\n```\r\npublic class ExceptionTest {\r\n\r\n    public static void main(String[] args) {\r\n        String string = \"hello , world\";\r\n        try {\r\n            System.out.println(string.substring(string.length() + 1));\r\n        } catch(StringIndexOutOfBoundsException e) {\r\n\t          System.out.println(\"String型下标越界\");\r\n\t      } finally {\r\n\t          System.out.println(\"over\");\r\n\t      }\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nString型下标越界\r\nover\r\n```\r\n\r\n另外，catch块中为相应异常类的对象e，可以通过该类的`getMessage()`方法和`getCause()`方法获取异常的描述和原因，例如上述代码可以获取到的信息如下\r\n\r\n```\r\nSystem.out.println(e.getMessage() + \", \" + e.getCause());    //String index out of range: -1, null\r\n```\r\n\r\n## 三、异常类与异常类体系\r\n\r\n所有的异常类都有一个共同的父类，即Throwable，该父类有四个构造方法，如下\r\n\r\n```\r\npublic Throwable()\r\npublic Throwable(String message)\r\npublic Throwable(Throwable cause)\r\npublic Throwable(String message, Throw cause) message为异常消息，即对该异常的描述；cause描述触发该异常的其他异常，也就是说异常可能会形成异常链，上层的异常会有由底层的异常触发。 Throwable的一些常用方法如下\r\nvoid printStackTrace()    //打印异常栈信息到标准错误输出流\r\nString getMessage()    \r\nThrowable getCause()\r\n```\r\n\r\n以Throwable为根，Java定义了很多的异常类，形成了异常类体系，部分如下\r\n\r\n```\r\nThrowable\r\n  |-Error\r\n    |-VirtualMachineError\r\n\t|-OutOfMemoryError\r\n\t|-StackOverflowError\r\n  |-Exception\r\n    |-IOException\r\n\t|-SQLException\r\n\t|-RuntimeException\r\n\t  |-IllegalStateException\r\n\t  |-NullPointerException\r\n\t  |-ClassCastException\r\n\t  |-IllegalArgumentException\r\n\t    |-NumberFormatException\r\n\t  |-IndexOutofBoundsException\r\n\t    |-StringIndexOutOfBoundsException\r\n\t    |-ArrayIndexOutOfBoundsException\r\n```\r\n\r\n还可以自定义异常类，如下\r\n\r\n```\r\npublic class AppException extends Exception {\r\n\r\n    /**\r\n     * \r\n     */\r\n    private static final long serialVersionUID = 1L;\r\n\r\n    public AppException() {\r\n\t      super();\r\n    }\r\n\t\r\n    public AppException(String message) {\r\n\t      super(message);\r\n    }\r\n\t\r\n    public AppException(Throwable cause) {\r\n\t      super(cause);\r\n    }\r\n\t\r\n    public AppException(String message, Throwable cause) {\r\n\t      super(message, cause);\r\n    }\r\n}\r\n```\r\n\r\n只需要实现ThrowAble的四个构造方法即可，那么在处理异常时，可以重新抛出已知异常通过自定义异常类再处理，这样做的话可以增加描述异常的信息或者细节，以便于更好的理解异常发生的情况或者位置，如下\r\n\r\n```\r\npublic class ExceptionTest {\r\n\r\n    public static void main(String[] args) {\r\n\t      String string = \"hello , world\";\r\n\t      try {\r\n\t          System.out.println(string.substring(string.length() + 1));\r\n\t      } catch (StringIndexOutOfBoundsException e) {\r\n\t          System.out.println(e.getMessage() + \", \" + e.getCause());\r\n\t          try {\r\n\t\t            throw new AppException(\"下标越界\", e);\r\n\t          } catch (AppException e1) {\r\n\t\t            // TODO Auto-generated catch block\r\n\t\t            System.out.println(e1.getMessage() + \", \" + e1.getCause());\r\n\t          }\r\n\t            } finally {\r\n\t          System.out.println(\"over\");\r\n\t      }\r\n    }\r\n\r\n}\r\n```\r\n\r\n输出为\r\n\r\n```\r\nString index out of range: -1, null\r\n下标越界, java.lang.StringIndexOutOfBoundsException: String index out of range: -1\r\nover\r\n```\r\n\r\n我们先处理`StringIndexOutOfBoundsException`的异常，即打印`e.getMessage()`和`e.getCause()`之后，然后通过`throw`关键字重新抛出该异常，将异常传递给`AppException`，这样就形成了一条异常链，顶层`AppException`由底层`StringIndexOutOfBoundsException`触发，那么我们通过`try-catch`语句处理该异常就可以获取相信信息，即\r\n\r\n```\r\nSystem.out.println(e1.getMessage() + \", \" + e1.getCause());    //下标越界, java.lang.StringIndexOutOfBoundsException: String index out of range: -1\r\n```\r\n\r\n也可以通过`throw`关键字直接在方法层面抛出`AppException`异常，在处理完异常链之后才会执行`finally`中的语句。\r\n\r\n## 四、try-with-resources\r\n\r\n对于一些使用资源的场景，例如操作文件和数据库，典型的使用流程是先打开资源，然后操作，最后在finally语句中释放资源，Java7支持这种语法形式，即try-catch-resources.这种语法针对实现了java.lang.AutoCloseable接口的对象，该接口定义如下\r\n\r\n```\r\npublic interface AutoCloseable {\r\n    void close() throws Exception;\r\n}\r\n```\r\n\r\n没有try-with-resources时，操作资源的形式如下\r\n\r\n```\r\npublic static void useResource() throws Exception {\r\n    AutoCloseable autoCloseable = new FileInputStream(\"hello\");\r\n    try {\r\n        //使用资源\r\n    } finall {\r\n        autoCloseable.close();\r\n    }\r\n}\r\n```\r\n\r\n使用了try-with-resources语法，形式如下\r\n\r\n```\r\npublic static void useResource() throws Exception {\r\n    try ( AutoCloseable autoCloseable = new FileInputStream(\"hello\")) {\r\n        //使用资源\r\n    }\r\n}\r\n```\r\n\r\n也就是在try语句执行完毕之后，系统会自动调用close()方法释放资源。\r\n\r\n## 五、throws关键字\r\n\r\nthrows可以抛出一系列异常，跟在方法括号的后面，含义为这个方法可能会抛出这些异常(或其中的某个)且没有对这些异常进行处理或者没处理完。\r\n\r\n## 六、受检异常和未受检异常\r\n\r\nRuntimeException的真实含义是未受检异常，Exception的除RuntimeException之外的其他异常则是受检异常，受检异常和未受检异常的区别在于Java对这两种异常的态度，对于受检异常Java要求程序员处理，否则会有编译错误。\r\n\r\n关于两者的详细区别，一种普遍说法是：未受检异常说明程序本身存在逻辑错误，比如NPE，这些在编程时完全可以避免；受检异常则是说明程序本身没有错误但是涉及到I/O、网络或者文件以及数据库的操作时，可能不可避免的会出现问题，虽然程序本身不存在逻辑问题，但是也应该进行处理。\r\n\r\n简言之，未受检异常是思维考虑问题不全面而产生的，完全可以避免；受检异常不是思维的问题，而是资源利用或者资源本身性质而引发的问题，不可避免但是可以尽可能捕获作进一步处理。\r\n","cover":"/images/java.jpg","link":"java-exception-and-exception-handling-mechanism.html","preview":"\u003cp\u003e受检异常和未受检异常的区别在于Java对这两种异常的态度，对于受检异常Java要求程序员处理，否则会有编译错误。\u003c/p\u003e\n","title":"Java异常及异常处理机制"},{"content":"\r\n\r\nJava中的数据类型分为三大类，分别是数值型、布尔型、字符型，其中数值型分为整型和浮点型。\r\n\r\n相对于数据类型，Java中的变量类型分为布尔型boolean；字符型char；整型byte、short、int、long；浮点型float、double。\r\n\r\n需要注意的是String虽然平时与int、double等常用，但是String并不是Java当中的简单数据类型，String是类变量。\r\n\r\nJava数据类型的转换分为三种，分别是：简单数据类型之间的转换(低级变量向高级变量的自动类型转换、高级变量向低级变量的强制类型转换以及包装类过渡类型转换)、字符串型与其他数据类型的转换、将字符型直接作为数值转换为其他数据类型。\r\n\r\nJava当中简单数据类型由低级到高级分别是：(byte、short、char)—int—long—float—double\r\n\r\n## 一、简单数据类型之间的转换\r\n\r\n### 1.1 低级变量向高级变量的自动类型转换\r\n\r\n```\r\npublic class TestPlus {\r\n    public static void main(String[] args) {\r\n        byte bi = 10;\r\n        int ii = bi;\r\n        long li = ii;\r\n        float fi = li;\r\n        double di = fi;\r\n        System.out.println(bi);    //10\r\n        System.out.println(ii);    //10\r\n        System.out.println(li);    //10\r\n        System.out.println(fi);    //10.0\r\n        System.out.println(di);    //10.0\r\n        char cj = 'a';\r\n        int ij = cj;\r\n        long lj = ij;\r\n        float fj = lj;\r\n        double dj = fj;\r\n        System.out.println(cj);    //a\r\n        System.out.println(ij);    //97\r\n        System.out.println(lj);    //97\r\n        System.out.println(fj);    //97.0\r\n        System.out.println(dj);    //97.0\r\n\r\n    }\r\n}\r\n```\r\n\r\n如果是char型自动类型转化那么会转化为其对应的ASCII码值。\r\n\r\n对于char、byte、short三种类型而言，由于他们是相同的级别，所以不能自动类型转化，但是可以强制类型转化，比如\r\n\r\n```\r\nbyte bi = 97;\r\nSystem.out.println((char)bi);    //a\r\n```\r\n\r\n### 1.2 高级变量向低级变量的强制类型转换\r\n\r\n```\r\npublic class TestPlus {\r\n    public static void main(String[] args) {\r\n        double di = 10.0;\r\n        float fi = (float)di;\r\n        long li = (long)di;\r\n        int ii = (int)di;\r\n        byte bi = (byte)ii;\r\n        System.out.println(bi);    //10\r\n        System.out.println(ii);    //10\r\n        System.out.println(li);    //10\r\n        System.out.println(fi);    //10.0\r\n        System.out.println(di);    //10.0\r\n    }\r\n}\r\n```\r\n\r\n不过这种转化会导致溢出或精度下降，比如\r\n\r\n```\r\npublic class TestPlus {\r\n    public static void main(String[] args) {\r\n        double di = 10.1111111111111111111;\r\n        float fi = (float)di;\r\n        long li = (long)di;\r\n        int ii = (int)di;\r\n        byte bi = (byte)ii;\r\n        System.out.println(bi);    //10\r\n        System.out.println(ii);    //10\r\n        System.out.println(li);    //10\r\n        System.out.println(fi);    //10.111111\r\n        System.out.println(di);    //10.11111111111111\r\n    }\r\n}\r\n```\r\n\r\n明显损失掉了double型变量的精度\r\n\r\n### 1.3 包装类过渡类型转换\r\n\r\n包装类其实就是对简单数据类型的一个包装,char、int、long、float、double、boolean类型的包装类分别是Character、Integer、Long、Float、Double、Boolean，而String本身就是类因此不存在包装类。\r\n\r\n对简单数据类型进行包装的一个好处就是规避了NPE风险，简单数据类型是不可以接收null值的，比如\r\n\r\n```\r\ndouble di = null;    //Error:(5, 21) java: incompatible types: \u003cnulltype\u003e cannot be converted to double\r\n```\r\n\r\n以上代码会报错，但是包装类却不存在问题\r\n\r\n```\r\nDouble di = null;\r\nSystem.out.println(di);    //null\r\n```\r\n\r\n在进行简单数据类型之间的转换(无论自动还是强制)时可以用包装类进行中间过渡，如下\r\n\r\n```\r\nDouble di = 10.11111111111;\r\nSystem.out.println(di);    //10.11111111111\r\nSystem.out.println(di.floatValue());    //10.111111\r\n```\r\n\r\n直接得到了double对应的包装类Double转化的float型数据\r\n\r\n简单数据类型到包装数据类型(装箱的过程)可以通过相应包装类的构造函数，例如\r\n\r\n```\r\nDouble di = new Double(10.11111111111);\r\nFloat fi = new Float(10.1111f);\r\nLong li = new Long(10l);\r\nInteger ii = new Integer(10);\r\nBoolean bi = new Boolean(true);\r\nCharacter ci = new Character('a');\r\n```\r\n\r\n而拆箱同样简单，只需要将包装类对象直接赋值给相应的简单类型变量即可。\r\n\r\n## 二、字符串型与其他数据类型的转换\r\n\r\n### 2.1 其它数据类型转字符串，通过相应包装类的toString()方法即可实现\r\n\r\n```\r\npublic class TestPlus {\r\n    public static void main(String[] args) {\r\n        Double di = new Double(10.11111111111);\r\n        Float fi = new Float(10.1111f);\r\n        Long li = new Long(10l);\r\n        Integer ii = new Integer(10);\r\n        Boolean bi = new Boolean(true);\r\n        Character ci = new Character('a');\r\n        System.out.println(di.toString().getClass().toString());\r\n        System.out.println(fi.toString().getClass().toString());\r\n        System.out.println(li.toString().getClass().toString());\r\n        System.out.println(ii.toString().getClass().toString());\r\n        System.out.println(bi.toString().getClass().toString());\r\n        System.out.println(ci.toString().getClass().toString());\r\n    }\r\n}\r\n```\r\n\r\n如下输出\r\n\r\n```\r\nclass java.lang.String\r\nclass java.lang.String\r\nclass java.lang.String\r\nclass java.lang.String\r\nclass java.lang.String\r\nclass java.lang.String\r\n```\r\n\r\n可以看到明显转化为了String类型，需要注意的是只有包装类的toString方法可以getClass，因为toString的目标类型是String类，那么就可以通过getClass获取其类型；但是诸如包装类的floatValue之类的转化附带拆箱的方法是无法getClass的，因为其目标类型是简单数据类型，简单数据类型不是类，无法getClass\r\n\r\n### 2.2 字符串转简单数据类型，通过包装类的parse方法即可实现\r\n\r\n```\r\nString s = \"11\";\r\nSystem.out.println(Integer.parseInt(s));    //11\r\nSystem.out.println(Double.parseDouble(s));    //11.0\r\n```\r\n\r\nparse之后的目标类型是简单数据类型(附带拆箱)，所以仍然无法getClass\r\n\r\n### 2.3 将字符型直接作为数值转换为其他数据类型\r\n\r\n**一种是将字符型直接转化为其对应的ASCII码值，**如\r\n\r\n```\r\nchar c = '1';\r\nSystem.out.println((int)c);    //49\r\n```\r\n\r\n\u003ca name=\"d9c2dd1a\"\u003e\u003c/a\u003e\r\n**另一种是直接获取字面量**\r\n\r\n但是我们有些时候想得到的是字面量1的数值(是数值)，那么可以通过Character的getNumericValue方法实现，如下\r\n\r\n```\r\nchar c = '1';\r\nSystem.out.println(Character.getNumericValue(c));    //1\r\n```\r\n\r\n全文完！\r\n\r\n","cover":"/images/java.jpg","link":"data-type-conversion-in-java.html","preview":"\u003cp\u003eJava中的数据类型分为三大类，分别是数值型、布尔型、字符型，其中数值型分为整型和浮点型。\u003c/p\u003e\n","title":"Java中的数据类型转换"},{"content":"\r\n\r\n在图书馆拿这本书，起初是因为它的名字吸引了我;后来在阅读了一章之后，才发现吸引我的是宿命;读完了整本书，直到现在，其实真正让我感同身受的是\"自由\"。\r\n\r\n+ 有时候我宁愿相信，人生的诸多不顺，只是因为最适合你的那条路尚未出现。\r\n+ 人最终要走上一条由自我意志推动的路。那种自我意志你可能一时看不清，却能感受到它和周围磕磕绊绊的摩擦。摩擦越剧烈，人就越痛苦。而你越痛苦，就越说明周遭处境和你的意志之间不匹配。于是你不得不改变你的处境。很多时候，是痛苦而不是欲望，推动着你在一个个处境之间跳来跳去，直到最终安定下来。在那之前，你不知道要往哪走，不知道什么时候被捉住，不知道在哪儿撞墙死掉，但你知道，不动是无论如何不成的。\r\n+ 当你停下来，你就成为了你。那时你才知道，一切纠结，一切转折，都只是自我意志在拣选它的归宿。\r\n\r\n我记得轻云爸爸那被宿命或生活给予的愧疚，于父亲，于妻子于孩子。\r\n\r\n+ 最终，爸爸在同学和红卫兵的带头人的带领下，走上了高台，当着众人的面喊了口号，念了批判书，与爷爷划清界限，并在爷爷头顶上啐了一口唾沫。\r\n+ 就是这一口唾沫，成为了爸爸心里的梗。等到他下乡时，他已经十七岁，这口唾沫开始在深夜里浮上他心头，并且变得不那么理直气壮了;十八岁时，他见到王老西挡在批斗他爹的红卫兵身前，挥舞着流氓拳一阵乱打，脸上都是血，虽然寡不敌众，但那种不要命的样子却当真把众人吓退了;二十二岁，他见到黑白电视里的审判和一系列平反……\r\n+ 后来，在漫长的岁月里，那口唾沫总是像心脏里埋着的一颗小石头，不鲜明、不显著，却总是硌得他生疼，尤其是喝了点酒、心被酒泡软了的时候，那石头的边缘几乎把心划破……\r\n\r\n轻云的父亲在倒卖外汇中被调查，谢家父子帮他重新回到厂子，但却时刻面临着调查组或公安局的调查与追捕，他不想和王老西一起做生意，但想和他一起走，南下，避风头。他也不会想到自己会请求同与厂子谈判的英国人帮他出国，更不会想到在轻云出生后将十年见不到她和她的妈妈。\r\n\r\n我记得谢一凡对员工的同情、对父亲遗命的遵从、对微月的关怀、对轻云及她妈妈的照顾。\r\n\r\n还有轻云从They are watching you到寻找自我的经历！\r\n\r\n+ 对于内心中经历过的痛苦感受，我觉得最重要的不是痛苦的来源，也不是痛苦的类型，而是自我对痛苦的意识以及之后的反应。有时候我们会误解痛苦的意义。我们走不出痛苦，不仅因为痛苦过于沉重，也因为我们沉溺其中，缺乏走出的动力。时常听到“痛苦孕育深刻”、“苦难造就伟大”之类的说辞，这对经历痛苦的人有一种诱惑的误导。可是实际上，痛苦并不是让人沉溺的东西，也不是让人用来自我标榜，或者向世界索取报偿的东西。人的命运由自己负责，世界并不负责为你的痛苦给你补偿。最终是人对痛苦的跨越，而不是痛苦本身，标示了人的价值。只有走出痛苦才能肯定它的意义。\r\n+ 对人如此，对国度也是如此。\r\n\r\n**生于一九八四，郝景芳/著**","cover":"/images/born-in-1984.jpeg","link":"born-in-1984-reading-notes.html","preview":"\u003cp\u003e有时候我宁愿相信，人生的诸多不顺，只是因为最适合你的那条路尚未出现。\u003c/p\u003e\n","title":"《生于一九八四》·阅读小记"},{"content":"\r\n\r\n一部《万历十五年》,就是一部简明扼要的明朝兴衰史。黄仁宇以独到的眼光以六个人物为代表并以万历年间为切入点 深 入阐述了一个王朝由盛极衰的原因。作者在本书中渗透的历史观足以让每一位读者对中国古代封建社会形成更为深入的理解。\r\n\r\n**皇帝以儒家伦理纲常为基维护统治秩序而又不得不与文官集团相抗衡。**\r\n\r\n封建王朝统治秩序的维护在很大程度上是依靠封建伦理道德实现的。自汉武帝罢黜百家独尊儒术确立儒家思想的正统地位伊始,直至清廷覆灭,两千年的封建社会高度契合,几无例外。上至天子,下到百姓,无不遵守。文官集团是儒家伦理的极力推动者与坚决维护者,一方面他们以此维护整个地主阶级的统治利益,另一方面他们也以此与皇帝对抗保全小集团私利。庞大的帝国并不是有一位励精图治殚精竭虑的君主就可以实现统治的,维系统治的纽带正是这各级文官与文官集团推崇的伦理纲常。英明的君主会洞悉这种 “ 潜规则 ” ,合理利用文官集团中的矛盾不仅可以牵制双方而且能够达到自己维护统治秩序稳定的目的。这万历皇帝自小就熟悉各种礼仪,受张居正的影响 ( 正面影响 ) 是具备成为好皇帝的潜质的。但权倾朝野的首辅张居正去世之后,在文官集团的检举之下其种种劣端行径暴露无疑,这位曾经被万历极度推崇依赖的首辅竟是在自己面前一套背地里一套,这给了万历莫大的打击,也为万历皇帝日后的懒政埋下了隐患。自小被礼仪伦理捆绑,为文官教导的万历就越想挣脱这种束缚,就以不上朝等行为对抗文官集团。\r\n\r\n不得不说,以伦理纲常维护统治秩序这确是一大创举,成效也是卓著的,其在诛心。程朱理学存天理灭人欲以达到维护统治秩序的目的,而由皇室与文官集团表现出来的尊卑有序君为臣纲更是为⺠间提供了一套典范,以此便能使得统治秩序的稳定。但是这也是一种愚⺠政策,在三纲五常的捆绑之下⺠智不开社会思想就难以激流勇进,发展到清朝末期其弊端显而易⻅。","cover":"/images/the-Fifteen-Years-of-Wanli.jpg","link":"thoughts-on-the-fifteen-years-of-wanli.html","preview":"\u003cp\u003e一部《万历十五年》,就是一部简明扼要的明朝兴衰史。\u003c/p\u003e\n","title":"关于《万历十五年》的一点思考"},{"content":"\r\n\r\n暑假在读客官微上看到了关于清明上河图密码的一期推送,说实话,我对悬疑推理小说兴致并不高,但我却是一个十足的历史爱好者,受这一因素的驱动,于收假后特意买来拜读。\r\n\r\n虽说我是一个典型的文科生,但是于历史而言更多的只是历史课本上学到的,以悬疑推理的方式 深 入历史还是第一次,倒也兴致高涨。故事定位在北宋末年,以《清明上河图》为原型,以四个不同领域的人物 ( 当前共出了四本 ) 为线索较为完整的串联起了北宋社会的士农工商兵等方方面面,书名也绝非沽名钓誉,确实配的上这幅画的思想精髓。\r\n\r\n一幅清明上河图就是一部北宋兴衰史,北宋帝国承平日久,图中一片欣欣向荣之景,但事实上已经危机四伏。方腊掣肘,金兵为患,辽国、西夏、高丽亦对中原王朝⻁视眈眈。清明上河图完成不久金兵便大举入侵焚城杀人,北宋繁华一夕扫尽。\r\n\r\n第一部以宗室子弟讼绝赵不尤破八子案、赵墨儿破香袋案、赵瓣儿破范楼案、宗室子弟赵不弃破变身案、以及最后搁浅的梅船案来展开布局,尤其是梅船案,目前看来这一案件是贯穿四部书的线索。本部书主要涉及到的是士子,即士农工商兵中的 “ 士 ” 。八子案中以东水八子的恩怨纠葛阐明了改革派与守成派之间的矛盾,八子案也是整部书的引子,贯穿四部书的梅船案更是与八子案密不可分。\r\n\r\n第二部是以牙绝冯赛跌宕起伏的人生经历为眉目展开的。包括金篇银篇铜篇三大部分,分别是三商案、百万案、⻜钱案。猪行、碳行、⻥行的货源被截一时间供货紧张,百万⻜钱不翼而⻜,牙绝冯赛在妻女失踪家产被抄的困境下揪出贯穿本案的引子 “ 母钱 ” 以及背后主使者广宁监的几位工人。牵扯到的社会阶层为 “ 商 ” 。而最终又回到范楼与梅船,照应了本书的主题,紧密联系了第一部,同时也给第三部埋下了伏笔。\r\n\r\n第三部以斗绝梁兴破化灰案、⻝儿案、空仓案、骷髅案为着墨点。至第三部就牵扯到了方腊,一时间读者联系前两部的各种悬疑,就会更 深 入的了解清明上河图密码之所以为密码的原因。该部书梁兴本是军中之人,因此涉及到的社会阶层是 “ 兵 ” 。\r\n\r\n第四部以作绝张用破萝卜案、焦船案、艮岳案、秘阁案为线索,一个整日疯疯癫癫的人却聪明绝顶连破四大案件,究其疯癫的原因不料确是装出来的,这里面的苦心孤诣不是三言两语能够道的清的。本部书以皇室修建艮岳为起因而揭示了日益激化的阶级矛盾,再加上⺠族矛盾使得读者很容易感觉到北宋帝国的危在旦夕。本部书主要涉及到的社会阶层为 “ 工 ” 。而社会阶层 “ 农 ” 则贯穿于每部书,毕竟农业才是封建王朝的根本。\r\n\r\n总之,就目前出的这四部书看来,作者的布局是相当庞大的,而每一部书的构思又极为精巧,每一个案件的推理与展开更是显得恰到好处而游刃有余,最为精妙的当属作者的填词。从书中看得出作者对北宋社会的⻛貌研究的很透彻,对清明上河图观察的很独到,真心希望本书能够尽快出版第五部与第六部,以飨读者!","cover":"/images/qingmingshanghetu.jpg","link":"a-domestic-masterpiece-of-conscientious-suspicious-reasoning.html","preview":"\u003cp\u003e一幅清明上河图就是一部北宋兴衰史,北宋帝国承平日久,图中一片欣欣向荣之景,但事实上已经危机四伏。\u003c/p\u003e\n","title":"《清明上河图密码》一部良心的国产悬疑推理大作"},{"content":"\r\n\r\n犹记栗城那处,华灯初上薄幕。君杵何顾?且看银霄暗度。暗度,暗度,沉醉莫知归路。\r\n\r\n京兆独酌天禄,夜半微息闭目。汝亦何故?往昔佳期如梦。如梦,如梦,无眠遥赋情愫。\r\n\r\n农历丁酉年三月十五日作于长安\r\n\r\n\r\n","cover":"/images/xijaingyue.jpg","link":"xijiang-moon.html","preview":"\u003cp\u003e犹记栗城那处,华灯初上薄幕。君杵何顾?且看银霄暗度。暗度,暗度,沉醉莫知归路。\u003c/p\u003e\n","title":"西江月 · 犹记栗城那处"},{"content":"\r\n彭衙故邑,白水新府,居渭水之北,栖洛河之滨。北极梁雁,依高屋建瓴之险势 ; 南接重泉,傍平原易野之秦川 ; 西至同官,有仰韶人文之辉耀 ; 东与徵城,汲孔洛二河之灵气。故邑荣昌,人杰地灵。\r\n\r\n仓颉先师,乃轩辕皇帝之史官也,⻰颜四目,生有睿德。 上古史前,寥无文字,凡事皆以结绳而记之,事大大结其绳,事小小结其绳,义或然也。然时过境迁,物事繁多,绳有穷而事不可终。仓圣登阳虚之山,临玄扈之水,启于灵龟负书,上观于奎星圜曲之势,下察以⻦兽蹄爪之迹,始做书契,以代结绳之政遂开华夏文明之基,而百官以治,万⺠以察。由是雅以文祖,成字圣之美誉。\r\n\r\n江水泱泱,山高水⻓。先师革结绳记事之陋,先天下之忧而忧而造福部邦,是为上善 ; 开文明盛世之基,后天下之乐而乐而瑞泽万⺠,实为有德。今之圣朝,沐浴清化,国泰⺠安,朝堂皆以德法治国,所欲跻身于世间非德厚而不能至也。先师言为士则 , 行为世范,故吾等应效法先师壹是皆以修身为本然树以凌云磅礴之志,如此而已,则我华夏复兴有望而盛世可期。\r\n\r\n大学有言 : 古之欲明明德于天下者,先治其国 ; 欲治其国者,先⻬其家 ; 欲⻬其家者,先修其身 ; 欲修其身者,先正其心 ; 欲正其心者,先诚其意 ; 欲诚其意者,先致其知 ; 致知在格物。物格而后知致,知致而后意诚,意诚而后心正,心正而后身修,身修而后家⻬,家⻬而后国治,国治而后天下平。由此观之,吾等皆应以从事微薄之事伊始,若学于庠序之间,宜诚意正心,悉心研习教义,学究天人满腹经纶以达身修之所望 ; 如居于家舍之中,应承欢膝下,苛求孝悌忠信,敬恭桑梓扇枕温衾以达家⻬之所要 ; 假处于世间之内,得尊老敬贤,追求讲信修睦,精诚团结群策群力以达国治之所需。此乃先师为人处世之义理,望吾辈勤学之,若与先师同居一邑而未谙于世故岂不痛哉!\r\n\r\n汉字之美,美在多维。自先师创字以来,多有更变。甲⻣文者,笔拙而苍劲 ; 金文者,笔肥而朴茂 ; 大篆者,因形而立意 ; 小篆者,体正而势圆 ; 隶书者,点划而方扁 ; 楷书者,因字而赋形 ; 行书者,形态而多变 ; 草书者,纵任而奔逸。此皆汉字之形体,多而不亢,千秋各异,称之曰奇。古之才高八斗学富五⻋而无以善书者亦不能结榜于市庭者也,故古之善书者云屯雾集矣。\r\n\r\n汉字者,民族之魂更甚者乃华夏之根。天地玄⻩,宇宙洪荒,世间文明古国者有四,除华夏文明外皆湮灭于史,究其缘由乃我汉字之功,故源远流⻓者而非吾华夏莫属。世人皆言华夏文明博大精 深,其犹以史书典籍为要,此乃文明源远流⻓之本。西汉扬雄曰 : 书,心画也。人常道 : 字如其人。 笔大且粗者多好动不羁,字正且方者多心细刚直,是之理也。或言⺠族笃学勉仁之雅性亦由汉字所立。\r\n\r\n呜呼,昔者仓圣作书,天雨粟,⻤夜啼,功震千秋而富盛名。今者吾辈应谨记先师之德、传承先师之字、效行先师之为、志立先师之功,以名扬天下而富庶故邑,犹不枉负先师之名。今日所幸,拙笔一篇,难书吾于先师之仰慕,言有穷而情不可终,斯已矣。\r\n\r\n农历丁酉年三月初七作于长安\r\n\r\n\r\n","cover":"/images/cangjiezaozi.jpg","link":"preface-of-cangsheng's-words.html","preview":"\u003cp\u003e彭衙故邑,白水新府,居渭水之北,栖洛河之滨。北极梁雁,依高屋建瓴之险势 ; 南接重泉,傍平原易野之秦川 ; 西至同官,有仰韶人文之辉耀 ; 东与徵城,汲孔洛二河之灵气。故邑荣昌,人杰地灵。\u003c/p\u003e\n","title":"仓圣造字序"},{"content":"\r\n\r\n一二一五六,一二一五七,一二一九二十一。\r\n\r\n二二二五六,二二二五七,二二二九三十一。\r\n\r\n三二三五六,三二三五七,三二三九四十一。\r\n\r\n四二四五六,四二四五七,四二四九五十一。\r\n\r\n\r\n\r\n改编自童谣《马兰开花二十一》\r\n\r\n农历丙申年十二月三日作于渭水","cover":"/images/malankaihua.jpg","link":"080911.html","preview":"\u003cp\u003e一二一五六,一二一五七,一二一九二十一。\u003c/p\u003e\n","title":"零八零九一十一"},{"content":"\r\n\r\n巍巍秦岭钟南山,浩浩八水绕长安。\r\n\r\n初雪晚来秋亦晚,一叶止秋夜至冬。\r\n\r\n北风萧萧惊留鸟,柳絮翩翩漫秦城。\r\n\r\n空闻胡琴弹古调,只道长安醉今宵。\r\n\r\n农历丙申年十月二十三日作于渭水","cover":"/images/changan-weihe.jpg","link":"drunk-changan.html","preview":"\u003cp\u003e北风萧萧惊留鸟,柳絮翩翩漫秦城。空闻胡琴弹古调,只道长安醉今宵。\u003c/p\u003e\n","title":"醉长安"},{"content":"\r\n\r\n物换星移,匆匆荼靡,只道是,逝者如斯而已矣。白驹过隙,浮生若梦,古人云,朱颜辞镜花辞树。\r\n\r\n破学数载,举步维艰,吾甚昧之,每每思于怀,犹幸愚决意于泥淖之中、从事于茫然之时。勤学两载有余,夙兴夜寐,固当结榜于市庭以盛感父母抚育之效及恩师诱导之善。时运不⻬,或愚自弃以它事,终其能,无所成,竭人力为之而遂用猖蹶,痛失之,甚悔矣。所幸甚,余心未泯,难释败殆之耻,自应晋决于笠年之时。焚膏油以继晷,恒兀兀以穷年,冬寒抱冰,夏热握火,未敢相忘鸿鹄之志于闹市之中,斯已矣。\r\n\r\n呜呼,时值今日,贡举既克,于人善哉,于己壮矣。须臾间,居此逾月而已。仲夏既过,孟秋已至,桂花初绽性轻柔,何处幽栖十里香。独问问:一思尚存,此志不懈?是故无冥冥之志者无昭昭之明,无惛惛之事者无赫赫之功。犹相忆,余曾示皓月以坦荡之心,放大言于韶华之时,未曾企及怎敢相忘于江湖之中,实为愧悔。今日提笔一书,虽无万丈之豪情,独具吾心之衷情。望愚此生上不愧亲师祈首之盼,下不负平生⻘云之志。\r\n\r\n国庆已至,普天同庆,谨以衷心一颗寄予吾 深 爱之国土,愿中华与天地比寿同日月⻬光。\r\n\r\n农历丙申年八月三十日作于彭衙","cover":"/images/Love-Reminiscences.jpg","link":"love-reminiscences.html","preview":"\u003cp\u003e物换星移,匆匆荼靡,只道是,逝者如斯而已矣。白驹过隙,浮生若梦,古人云,朱颜辞镜花辞树。\u003c/p\u003e\n","title":"诉衷情"},{"content":"\r\n\r\n昨夜⻛雨洒庭轩,心微凉,夜茫茫。最是相逢仲夏晚,无料,难吟月光寒。\r\n\r\n前年漫流华表语,何所似,孤鸿影。一生难再此佳年,莫惧,蓑雨任平生。\r\n\r\n农历丙申年六月十五日作于故邑","cover":"/images/huanxisha.jpg","link":"rain-sprinkled-the-courtyard-las-night.html","preview":"\u003cp\u003e一生难再此佳年,莫惧,蓑雨任平生。\u003c/p\u003e\n","title":"浣溪沙 · 昨夜风雨洒庭轩"}]